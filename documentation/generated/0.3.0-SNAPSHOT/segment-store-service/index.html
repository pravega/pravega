



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="Documentation to help you get familiar with Pravega">
      
      
        <link rel="canonical" href="http://pravega.io/docs/segment-store-service/">
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-0.17.2, mkdocs-material-2.2.1">
    
    
      
        <title>Segment Store Service - Exploring Pravega</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.41c6761c.css">
      
    
    
      <script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
    
  </head>
  
    <body>
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="http://pravega.io/docs" title="Exploring Pravega" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                Exploring Pravega
              </span>
              <span class="md-header-nav__topic">
                Segment Store Service
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" required placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset">&#xE5CD;</button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/pravega/pravega/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <span class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </span>
    Exploring Pravega
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/pravega/pravega/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../getting-started/" title="Getting Started" class="md-nav__link">
      Getting Started
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Understanding Pravega
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Understanding Pravega
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../pravega-concepts/" title="Pravega Concepts" class="md-nav__link">
      Pravega Concepts
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../terminology/" title="Terminology" class="md-nav__link">
      Terminology
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../key-features/" title="Key Features" class="md-nav__link">
      Key Features
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../faq/" title="Pravega FAQ" class="md-nav__link">
      Pravega FAQ
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
    <a href="./" title="Segment Store Service" class="md-nav__link md-nav__link--active">
      Segment Store Service
    </a>
    
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Developing Pravega Applications
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Developing Pravega Applications
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../javadoc/" title="Java API Reference" class="md-nav__link">
      Java API Reference
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../rest/restapis/" title="REST API - Controller" class="md-nav__link">
      REST API - Controller
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../connectors/" title="Pravega Connectors" class="md-nav__link">
      Pravega Connectors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../basic-reader-and-writer/" title="Working with Reader and Writer" class="md-nav__link">
      Working with Reader and Writer
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../reader-group-notifications/" title="Working with Reader Group notifications" class="md-nav__link">
      Working with Reader Group notifications
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../state-synchronizer/" title="Working with State Synchronizer" class="md-nav__link">
      Working with State Synchronizer
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../transactions/" title="Working with Transactions" class="md-nav__link">
      Working with Transactions
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Running Pravega
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Running Pravega
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../deployment/deployment/" title="Deployment Overview" class="md-nav__link">
      Deployment Overview
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../deployment/run-local/" title="Running Locally" class="md-nav__link">
      Running Locally
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../deployment/manual-install/" title="Manual Install" class="md-nav__link">
      Manual Install
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../deployment/docker-swarm/" title="Deployment in Docker Swarm" class="md-nav__link">
      Deployment in Docker Swarm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../deployment/dcos-install/" title="Deployment on DC/OS" class="md-nav__link">
      Deployment on DC/OS
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../deployment/aws-install/" title="Running in the Cloud (AWS)" class="md-nav__link">
      Running in the Cloud (AWS)
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      Contributing to Pravega
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        Contributing to Pravega
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../contributing/" title="Coding guildelines" class="md-nav__link">
      Coding guildelines
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../roadmap/" title="Pravega Roadmap" class="md-nav__link">
      Pravega Roadmap
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../join-community/" title="Join the Community" class="md-nav__link">
      Join the Community
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/pravega/pravega/tree/master/docs/segment-store-service.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <!--
Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0
-->

<h1 id="pravega-segment-store-service">Pravega Segment Store Service</h1>
<p>The Pravega Segment Store Service is a subsystem that lies at the heart of the entire Pravega deployment. It is the main access point for managing Stream Segments, providing the ability to create, delete and modify/access their contents. The Pravega Client communicates with the Pravega Stream Controller to figure out which Segments need to be used (for a Stream), and both the Stream Controller and the Client deal with the Segment Store Service to actually operate on them.</p>
<p>The basic idea behind the Segment Store Service is that it buffers incoming data in a very fast and durable append-only medium (Tier 1), and syncs it to a high-throughput (but not necessarily low latency) system (Tier 2) in the background, while aggregating multiple (smaller) operations to a Segment into a fewer (but larger) ones.</p>
<p>The Pravega Segment Store Service can provide the following guarantees:
- Stream Segments that are unlimited in length, with append-only semantics, yet supporting arbitrary-offset reads.
- No throughput degradation when performing small appends, regardless of the performance of the underlying Tier-2 storage system.
- Multiple concurrent writers to the same Segment.
 - Order is guaranteed within the context of a single writer, but appends from multiple concurrent writers will be added in the order in which they were received (appends are atomic without interleaving their contents).
- Writing to and reading from a Segment concurrently with relatively low latency between writing and reading.</p>
<h1 id="terminology">Terminology</h1>
<p>Throughout the rest of this document, we will use the following terminology:
- <em>Stream Segment</em> or <em>Segment</em>: A contiguous sequence of bytes. Similar to a file with no size limit. This is a part of a Stream, limited both temporally and laterally (by key). The scope of Streams and mapping Stream Segments to such Streams is beyond the purpose of this document.
- <em>Tier-2 storage</em> or <em>Permanent Storage</em>: The final resting place of the data.
- <em>Tier-1 storage</em>: Fast append storage, used for durably buffering incoming appends before distribution to Tier-2 Storage.
- <em>Cache</em>: A key-value local cache with no expectation of durability.
- <em>Pravega Segment Store Service</em> or <em>Segment Store</em>: The Service that this document describes. 
- <em>Transaction</em>: A sequence of appends that are related to a Segment, which, if persisted, would make up a contiguous range of bytes within it. This is used for ingesting very large records or for accumulating data that may or may not be persisted into the Segment (but its fate cannot be determined until later in the future).
    - Note that at the Pravega level, a Transaction applies to an entire Stream. In this document, a Transaction applies to a single Segment.</p>
<h1 id="architecture">Architecture</h1>
<p>The <em>Segment Store</em> is made up of the following components:
- <em>Pravega Node</em>: a host running a Pravega Process.
- <em>Stream Segment Container</em> (or <em>Segment Container</em>): A logical grouping of Stream Segments. The mapping of Segments to Containers is deterministic and does not require any persistent store; Segments are mapped to Containers via a hash function (based on the Segment's name).
- <em>Durable Data Log Adapter</em> (or <em>DurableDataLog</em>): an abstraction layer for Tier-1 Storage.
- <em>Storage Adapter</em>: an abstraction layer for Tier-2 Storage.
- <em>Cache</em>: an abstraction layer for append data caching.
- <em>Streaming Client</em>: an API that can be used to communicate with the Pravega Segment Store.
- <em>Segment Container Manager</em>: a component that can be used to determine the lifecycle of Segment Containers on a Pravega Node. This is used to start or stop Segment Containers based on an external coordination service (such as the Pravega Controller).</p>
<p>The Segment Store handles writes by first writing them to a log (Durable Data Log) on a fast storage (SSDs preferably) and immediately acking back to the client after they have been persisted there. Subsequently, those writes are then aggregated into larger chunks and written in the background to Tier-2 storage. Data for appends that have been acknowledged (and are in Tier-1) but not yet in Tier-2 is stored in the Cache (in addition to Tier-1). Once such data has been written to Tier-2 Storage, it may or may not be kept in the Cache, depending on a number of factors, such as Cache utilization/pressure and access patterns.</p>
<p>More details about each component described above can be found in the <strong>Components</strong> section (below).</p>
<h2 id="system-diagram">System Diagram</h2>
<p><img alt="System Diagram" src="../img/Segment.Store.Components.png" /></p>
<p>In this image, we show the major components of the Segment Store (for simplicity, only one Segment Container is depicted). All Container components and major links between them (how they interact with each other) are shown. The <em>Container Metadata</em> component is not shown, because every other component communicates with it in one form or another, and adding it would only clutter the diagram.</p>
<p>More detailed diagrams can be found under the <strong>Data Flow</strong> section (below).</p>
<h1 id="components">Components</h1>
<h2 id="segment-containers">Segment Containers</h2>
<p>Segment Containers are a logical grouping of Segments, and are responsible for all operations on those Segments within their span. A Segment Container is made of multiple sub-components:
- <em>Segment Container Metadata</em>: A collection of Segment-specific metadata that describe the current state of each Segment (how much data in Tier-2, how much in Tier-1, whether it is sealed, etc.), as well as other misc info about each Container.
- <em>Durable Log</em>: The Container writes every operation it receives to this log and acks back only when the log says it has been accepted and durably persisted..
- <em>Read Index</em>: An in-memory index of where data can be read from. The Container delegates all read requests to it, and it is responsible for fetching the data from wherever it is currently located (Cache, Tier-1 Storage or Tier-2 Storage).
- <em>Cache</em>: Used to store data for appends that exist in Tier-1 only (not yet in Tier-2), as well as blocks of data that support reads.
- <em>Storage Writer</em>: Processes the durable log operations and applies them to Tier-2 storage (in the order in which they were received). This component is also the one that coalesces multiple operations together, for better back-end throughput.</p>
<h3 id="segment-container-metadata">Segment Container Metadata</h3>
<p>The Segment Container Metadata is critical to the good functioning and synchronization of its components. This metadata is shared across all components and it comes at two levels: Container-wide Metadata and per-Segment Metadata. Each serves a different purpose and is described below.</p>
<h4 id="container-metadata">Container Metadata</h4>
<p>Each <strong>Segment Container</strong> needs to keep some general-purpose metadata that affects all operations inside the container:</p>
<ul>
<li><em>Operation Sequence Number</em>: The largest sequence number assigned by the <em>Durable Log</em>. Every time a new Operation is received and successfully processed by the <em>Durable Log</em>, this number is incremented (its value never decreases or otherwise roll back, even if an operation failed to be persisted).<ul>
<li>The Operation Sequence Number is guaranteed to be strict-monotonic increasing (no two Operations have the same value, and an Operation will always have a larger Sequence Number than all Operations before it).</li>
</ul>
</li>
<li><em>Epoch</em>: A number that is incremented every time a successful recovery (Container Start) happens. This value is durably incremented and stored as part of recovery and can be used for a number of cases (a good use is Tier-2 fencing for HDFS, which doesn't provide a good, native mechanism for that).</li>
<li><em>Active Segment Metadata</em>: Information about each active Segment (see next section below). A Segment is active if it has had activity (read or write) recently and is currently loaded in memory. If a Segment is not used for a while, or if there are many Segments currently active, a Segment becomes inactive by having its outstanding metadata flushed to Tier-2 Storage and evicted from memory.</li>
<li><em>Tier-1 Metadata</em>: Various pieces of information that can be used to accurately truncate the Tier-1 Storage Log once all operations prior to that point have been durably stored to Tier-2.</li>
<li><em>Checkpoints</em>: Container Metadata is periodically checkpointed by having its entire snapshot (including Active Segments) serialized to Tier-1. A Checkpoint serves as a Truncation Point for Tier-1, meaning it contains all the updates that have been made to the Container via all the processed operations before it so we no longer need those operations in order to reconstruct the Metadata. If we truncate Tier-1 on a Checkpoint, then we can use information from Tier-2 and this Checkpoint to reconstruct what is in the Metadata previously, without relying on any operation prior to it in Tier-1. </li>
</ul>
<h4 id="segment-metadata">Segment Metadata</h4>
<p>Each Segment Container needs to keep per-segment metadata, which it uses to keep track of the state of each segment as it processes operations for it. The metadata can be volatile (it can be fully rebuilt upon recovery) and contains the following properties for each segment that is currently in use:</p>
<ul>
<li><code>Name</code> the name of the Segment.</li>
<li><code>Id</code>: Internally assigned unique Segment Id. This is used to refer to Segments, which is preferred to the Name. This Id is sticky for the lifetime of the Segment, which means that even if the Segment becomes inactive, a future reactivation will have it mapped to the same Id.</li>
<li><code>StartOffset</code> (also known as <code>TruncationOffset</code>): the lowest offset of the data that is available for reading. A non-truncated segment will have Start Offset equal to 0, while subsequent Truncate operations will increase (but never decrease) this number. </li>
<li><code>StorageLength</code>: the highest offset of the data that exists in Tier-2 Storage.</li>
<li><code>Length</code>: the highest offset of the committed data in Tier-1 Storage.</li>
<li><code>LastModified</code>: the timestamp of the last processed (and acknowledged) append.</li>
<li><code>IsSealed</code>: whether the Segment is closed for appends (this value may not have been applied to Tier-2 Storage yet).</li>
<li><code>IsSealedInStorage</code>: whether the Segment is closed for appends (and this has been persisted in Tier-2 Storage).</li>
<li><code>IsMerged</code>: whether this Segment has been merged into another one (but this has not yet been persisted in Tier-2 Storage). This only applies for Transactions. Once the merger is persisted into Tier-2, the Transaction Segment does not exist anymore (so <code>IsDeleted</code> will become true).</li>
<li><code>IsDeleted</code>: whether the Segment is deleted or has recently been merged into another Segment. This only applies for recently deleted Segments, and not for Segments that never existed.</li>
</ul>
<p>The following are <strong>always</strong> true for any Segment:</p>
<ul>
<li><code>StorageLength</code> &lt;= <code>Length</code></li>
<li><code>StartOffset</code> &lt;= <code>Length</code></li>
</ul>
<h3 id="log-operations">Log Operations</h3>
<p>A <em>Log Operation</em> is the basic unit that is enqueued in the Durable Log. It does not represent an action, per se, but is the base for several serializable operations (we can serialize multiple types of operations, not just Appends). Each Operation is the result of an external action (which denote the alteration of a Segment), or an internal trigger, such as Metadata maintenance operations.</p>
<p>Every Log Operation has the following elements:
- <code>SequenceNumber</code>: the unique sequence number assigned to this entry (see more under <em>Container Metadata</em>).</p>
<p>These are the various types of Log Operations: 
- <em>Storage Operations</em> represent operations that need to be applied to the underlying Tier-2 Storage:
    - <code>StreamSegmentAppendOperation</code>: Represents an Append to a particular Segment.
    - <code>CachedStreamSegmentAppendOperation</code>: Same as <code>StreamSegmentAppendOperation</code>, but this is for internal use (instead of having an actual data payload, it points to a location in the cache from where the data can be retrieved).
    - <code>StreamSegmentSealOperation</code>: When processed, it sets a flag in the in-memory metadata that no more appends can be received. When the Storage Writer processes it, it marks the Segment as read-only in Tier-2 Storage.
    - <code>StreamSegmentTruncateOperation</code>: Truncates a Segment at a particular offset. This causes the Segment's <code>StartOffset</code> to change.
    - <code>MergeTransactionOperation</code>: Indicates that a Transaction is to be merged into its parent Segment.
- <em>Metadata Operations</em> are auxiliary operations that indicate a change to the Container Metadata. They can be the result of an external operation (we received an request for a Segment we never knew about before, so we must assign a unique Id to it) or to snapshot the entire Metadata (which helps with recovery and cleaning up Tier-1 Storage). The purpose of the <em>Metadata Operations</em> is to reduce the amount of time needed for failover recovery (when needed):
    - <code>StreamSegmentMapOperation</code>: maps an Id to a Segment Name.
    - <code>TransactionMapOperation</code>: maps an Id to a Transaction and to its Parent Segment.
    - <code>UpdateAttributesOperation</code>: Updates any attributes on a Segment.
    - <code>MetadataCheckpoint</code> includes an entire snapshot of the Metadata. This can be useful when during recovery - this contains all metadata up to this point, which is a sufficient base for all operations after it.</p>
<h3 id="durable-log">Durable Log</h3>
<p>The <em>Durable Log</em> is the central component that handles all Log Operations. All Operations (which are created by the Container) are added to the Durable Log, which processes them in the order in which they were received. It is made up of a few other components, all of which are working towards a single goal of processing all incoming operations as quickly as possible, without compromising data integrity.</p>
<h4 id="information-flow-in-the-durable-log">Information Flow in the Durable Log</h4>
<ol>
<li>All received operations are added to an <em>Operation Queue</em>  (the caller receives a Future which will be completed when the operation is durably persisted)</li>
<li>The <em>Operation Processor</em> picks all operations currently available in the queue (if the queue is empty, it will wait until at least one Operation is added).</li>
<li>The <em>Operation Processor</em> runs as a continuous loop (in a background thread), and has four main stages.<ol>
<li>Dequeue all outstanding Operations from the Operation Queue (described above)</li>
<li>Pre-process the Operations (validate that they are correct and would not cause undesired behavior, assign offsets (where needed), assign Sequence Numbers, etc.)</li>
<li>Write the operations to a <em>Data Frame Builder</em>, which serializes and packs the operations in <em>Data Frames</em>. Once a Data Frame is complete (full or no more operations to add), the Data Frame Builder sends the Data Frame to the _Durable Data Log. Note that an Operation may span multiple DataFrames - the goal is to make best use of the Durable Data Log throughput capacity by making writes as large as possible (but also taking into account that there may be a maximum size limit per write).</li>
</ol>
</li>
<li>When a DataFrame has been durably persisted in the Durable Data Log, the Operation Processor post-processes all operations that were fully written so far (adds them to in-memory structures, updates indices, etc.) and completes the Futures associated with them.</li>
<li>The <em>Operation Processor</em> works asynchronously, in that it does not wait for a particular Data Frame to be written before starting another one and sending it to the Durable Data Log. As such, multiple DataFrames may be in flight (but in a specific order), and the Operation Processor relies on certain ordering guarantees from the Durable Data Log (if a particular DataFrame was acked, then all DataFrames prior to that were also committed successfully, in the right order).  <ul>
<li>The Operation Processor does not do any write throttling (it leaves that to the Durable Data Log implementation), but it control the size of the Data Frames that get sent to it.</li>
</ul>
</li>
</ol>
<h4 id="truncation">Truncation</h4>
<p>Based on supplied configuration, the Durable Log auto-adds a special kind of operation, named <code>MetadataCheckpointOperation</code>. This operation, when processed by the Operation Processor, collects a snapshot of the entire Container Metadata and serializes it to the Durable Data Log. This special Operation marks a <em>Truncation Point</em> - a place in the stream of Log Operations where we can issue Truncate operations. It is very important that after every truncation, the first operation to be found in the log is a <code>MetadataCheckpointOperation</code>, because without the prior operations to reconstruct metadata, this is the only way to be able to process subsequent operations.</p>
<p>Note: Durable Data Log (Tier-1) truncation should not be confused with Segment Truncation. They serve different purposes and are applied to different targets.</p>
<h4 id="operation-processor">Operation Processor</h4>
<p>The <em>Operation Processor</em> is a sub-component of the Durable Log that deals with incoming Log Operations. Its purpose is to validate, persist, and update Metadata and other internal structures based on the contents of each operation.</p>
<h4 id="operation-metadata-updater">Operation Metadata Updater</h4>
<p>The <em>Operation Metadata Updater</em> is a sub-component of the Durable Log that is responsible with validating operations based on the current state of the metadata, as well as update the Metadata after a successful committal of an operation. Internally it has various mechanisms to cope with failures, and it can rollback certain changes in failure situations.</p>
<h4 id="durable-data-log">Durable Data Log</h4>
<p>The _Durable Data Log is an abstraction layer to an external component that provides append-only semantics. It is supposed to be a system which provides very fast appends to a log, that guarantees the durability and consistency of the written data. The read performance is not so much a factor, because we do not read directly from this component - we only read from it when we need to recover the contents of the Durable Log.</p>
<p>As explained above, Log Operations are serialized into Data Frames (with a single Operation able to span multiple such Frames if needed), and these Data Frames are then serialized as entries into this Durable Data Log. This is used only as a fail-safe, and we only need to read these Frames back if we need to perform recovery (in which case we need to deserialize all Log Operations contained in them, in the same order in which they were received).</p>
<h4 id="in-memory-operation-log">In-Memory Operation Log</h4>
<p>The <em>In-Memory Operation Log</em> contains committed (and replicated) Log Operations in the exact same order as they were added to the Durable Data Log. While the Durable Data Log contains a sequence of Data Frames (which contain serializations of Operations), the Memory Log contains the actual Operations, which can be used throughout the Durable Log (and the Storage Writer).</p>
<p>The Memory Log is essentially a chain of Log Operations ordered by the time when the Operation was received. We always add at one end, and we remove from the other. When we truncate the Durable Data Log the Memory Log is also truncated at the same location.</p>
<h3 id="read-index">Read Index</h3>
<p>The <em>Read Index</em> helps the Segment Container perform reads from streams at arbitrary offsets. While the Durable Log records (and can only replay) data in the order in which it is received, the Read Index can access the data in a random fashion. The Read Index is made of multiple <em>Segment Read Indices</em> (one per live segment).</p>
<p>The <em>Segment Read Index</em> is a data structure that is used to serve reads from memory, as well as pull data from Tier-2 Storage and provide <em>Future Reads</em> (tail reads) when data is not yet available. When a read request is received, the Segment Read Index returns a read iterator that will return data as long as the read request parameters have not yet been satisfied. The iterator will either fetch data that is immediately available in memory, or request data from Tier-2 storage (and bring it to memory) or, if it reached the current end of the Segment, return a Future that will be completed when new data is added (thus providing tailing or future reads).</p>
<p>At the heart of the <em>Segment Read Index</em> lies a sorted index of entries (indexed by their start offsets) which is used to locate the requested data when needed. The index itself is implemented by a custom balanced binary search tree (AVL Tree to be more precise) with a goal of minimizing memory usage while not sacrificing insert or access performance. The entries themselves do not contain data, rather some small amount of metadata that is used to locate the data in the <em>Cache</em> and to determine usage patterns (good for cache evictions).</p>
<h3 id="cache">Cache</h3>
<p>The <em>Cache</em> is a component where all data (whether from new appends or that was pulled from Tier-2 storage) is stored. It is a key-value store entirely managed by the Read Index. </p>
<p>The Cache is defined as an abstraction layer, and there are two implementations of it:
- In-memory implementation (via a <code>HashMap</code>). This is currently only used for unit tests.
- Memory-disk hybrid, powered by <strong>RocksDB</strong>. This is the preferred (and default) implementation, since it is not limited by available heap space or machine RAM. Performance is comparable to the in-memory implementation.</p>
<h3 id="storage-writer">Storage Writer</h3>
<p>Pravega is by no means the final resting place of the data, nor is it meant to be a storage service. The Tier-2 Storage is where we want data to be in the long term and Pravega is only used to store a very short tail-end of it (using Tier-1 Storage), enough to make appends fast and aggregate them into bigger chunks for committal to Tier-2 Storage. In order to perform this, it needs another component (Storage Writer) that reads data from the Durable Log in the order in which it was received, aggregates it, and sends it to Tier-2 Storage.</p>
<p>Just like the Durable Log, there is one Storage Writer per Segment Container. Each Writer reads Log Operations from the In-Memory Operation Log (exposed via the <code>read()</code> method in the Durable Log) in the order they were processed. It keeps track of the last read item by means of its Sequence Number. This state is not persisted, and upon recovery, it can just start from the beginning of the available Durable Log.</p>
<p>The Storage Writer can process any Storage Operation (Append, Seal, Merge), and since Pravega is the sole actor modifying such data in Tier-2, it applies them without restraint. It has several mechanisms to detect and recover from possible data loss or external actors modifying data concurrently.</p>
<h1 id="integration-with-controller">Integration with Controller</h1>
<p>Actual methods for how Segment Containers are mapped to hosts and what rules are used for moving from from one to another are beyond the scope of this document. Here, we just describe how the Segment Store Service interacts with the <em>Controller</em> and how it manages the lifecycle of Segment Containers based on external events.</p>
<h2 id="segment-container-manager">Segment Container Manager</h2>
<p>Each instance of a Segment Store Service needs a <em>Segment Container Manager</em>. The role of this component is to manage the lifecycle of the Segment Containers that are assigned to that node (service). It performs the following duties:
- Connects to the Controller Service-Side Client (i.e., a client that deals only with Segment Container events, and not with the management of Streams and listens to all changes that pertain to Containers that pertain to its own instance.
- When it receives a notification that it needs to start a Segment Container for a particular Container Id, it initiates the process of bootstrapping such an object. It does not notify the requesting client of success until the operation completes without error.
- When it receives a notification that it needs to stop a Segment Container for a particular Container Id, it initiates the process of shutting it down. It does not notify the requesting client of success until the operation completes without error.
- If the Segment Container shuts down unexpectedly (whether during Start, or during its normal operation), it will not attempt to restart it locally; instead it will notify the Controller of the fact.</p>
<h1 id="storage-abstractions">Storage Abstractions</h1>
<p>The Segment Store was not designed with particular implementations for Tier-1 or Tier-2 in mind. Instead, all these components have been abstracted out in simple, well-defined interfaces, which can be implemented against any standard file system (Tier-2) or append-only log system (Tier-1). </p>
<p>Possible candidates for Tier-1 storage:
- <strong>Apache BookKeeper</strong> (preferred, adapter is fully implemented as part of Pravega)
- Non-durable, non-replicated solutions:
    - In-Memory (Single node deployment only - Pravega becomes a volatile buffer for Tier-2 storage; data loss is unavoidable and unrecoverable from in the case of process crash or system restart).
        - This is used for unit test only.
    - Local File System (Single node deployment only - Pravega becomes a semi-durable buffer for Tier-2 storage; data loss is unavoidable and unrecoverable from in the case of complete node failure)</p>
<p>Possible candidates for Tier-2 storage:
- <strong>HDFS</strong> (implementation available)
- <strong>Extended S3</strong> (implementation available)
- <strong>NFS</strong> (general <strong>FileSystem</strong>) (implementation available)
- In-Memory (Single node deployment only - limited usefulness; data loss is unavoidable and unrecoverable from in the case of process crash or system restart) 
    - This is used for unit test only.</p>
<p>A note about <strong>Tier-2 Truncation</strong>:
- The Segment Store supports Segment truncation at a particular offset, which means that, once that request is complete, no offset below that one will be available for reading.
- This above is only a metadata update operation, however this also needs to be supported by Tier-2 so that the truncated data is physically deleted from it.
- If a Tier-2 implementation does not natively support truncation from the beginning of a file with offset preservation (i.e., a Segment of length 100 is truncated at offset 50, then offsets 0..49 are deleted, but offsets 50-99 are available and are not shifted down), then the <strong>Segment Store</strong> provides a wrapper on top of a generic Tier-2 implementation that can do that
- The <code>RollingStorage</code> Tier-2 wrapper splits a Segment into multiple <em>Segment Chunks</em> and exposes them as a single Segment to the upper layers. <em>Segment Chunks</em> that have been truncated out are deleted automatically. This is not a very precise application (since it relies heavily on a rollover policy dictating granularity), but it is a practical solution for those cases when the real Tier-2 implementation does not provide the features that we need.  </p>
<h1 id="data-flow">Data Flow</h1>
<p>Here are a few examples on how data flows inside the Pravega Segment Store Service.</p>
<h2 id="appends">Appends</h2>
<p><img alt="Segment Store Appends" src="../img/Segment.Store.Appends.png" /></p>
<p>The diagram above depicts these steps (note the step numbers may not match, but the order is the same):</p>
<ol>
<li><strong>Segment Store</strong> receives append request with params: Segment Name, Payload and AttributeUpdates.</li>
<li><strong>Segment Store</strong> determines the ContainerId for the given Segment and verifies that the <strong>Segment Container</strong> is registered locally. If not, it returns an appropriate error code.</li>
<li><strong>Segment Store</strong> delegates request to the appropriate <strong>Segment Container</strong> instance.<ol>
<li><strong>Segment Container</strong> verifies that the Segment belongs to the Segment Container and that the Segment actually exists. If not, it returns an appropriate error code. <ul>
<li>During this process, it also get an existing Segment Id or assigns a new one (by using the <strong>Segment Mapper</strong> component).</li>
</ul>
</li>
<li>Segment Container creates a <code>StreamSegmentAppendOperation</code> with the input data and sends it to the <strong>Durable Log</strong>.</li>
</ol>
</li>
<li><strong>Durable Log</strong> takes the Append Operation and processes it according to the algorithm described in the <strong>Durable Log</strong> section.  <ol>
<li>Puts it in its Operation Queue.</li>
<li>Operation Processor pulls all operations off the Queue.</li>
<li>Operation Processor uses the Data Frame Builder to construct Data Frames with the operations it has.</li>
<li>Data Frame Builder writes the Data Frame to the <strong>Durable Data Log</strong></li>
<li>Metadata is updated and the Operation is added to the <strong>Memory Operation Log</strong>.</li>
<li>The above process is asynchronous, which means the Operation Processor will have multiple Data Frames in flight (not illustrated). </li>
</ol>
</li>
<li>Upon completion:<ol>
<li><strong>Success</strong>: Append Operation is added to the <strong>Read Index</strong> and any Future Reads for the Segment are activated, if they meet the trigger criteria.</li>
<li><strong>Failure</strong>: The call is failed with an appropriate error code.</li>
</ol>
</li>
</ol>
<p>This process applies for every single operation that the <strong>Segment Store</strong> supports. All <em>modify</em> operations go through the Operation Processor and have a similar path.</p>
<h2 id="reads">Reads</h2>
<p><img alt="Segment Store Reads" src="../img/Segment.Store.Reads.png" /></p>
<p>The diagram above depicts these steps (note the step numbers may not match, but the order is the same):
0. <strong>Segment Store</strong> receives read request with params: Segment Name, Read Offset, Max-Length.
    1. <strong>Segment Store</strong> determines the ContainerId for the given Segment and verifies if it is Leader for given <strong>Segment Container</strong>. If not, it returns an appropriate error code.
    2. <strong>Segment Store</strong> delegates request to the <strong>Segment Container</strong> instance.
1. <strong>Segment Container</strong> verifies that the Segment belongs to that Container and that it actually exists. If not, it returns an appropriate error code to the client. 
    - During this process, it also get an existing Segment Id or assigns a new one (by using the <strong>Segment Mapper</strong> component).
2. <strong>Segment Container</strong> delegates the request to its <strong>Read Index</strong>, which processes the read as described in the <strong>Read Index</strong> section, by issuing Reads from <strong>Storage</strong> (for data that is not in the <strong>Cache</strong>), and querying/updating the <strong>Cache</strong> as needed.</p>
<h2 id="synchronization-with-tier-2-storage-writer">Synchronization with Tier-2 (Storage Writer)</h2>
<p><img alt="Segment Store Sync Tier-2" src="../img/Segment.Store.SyncTier2.png" /></p>
<p>The diagram above depicts these steps (note the step numbers may not match, but the order is the same):</p>
<ol>
<li>The <strong>Storage Writer</strong>'s main loop is the sub-component that triggers all these operations</li>
<li>Read next Operation from the <strong>Durable Log</strong> (in between each loop, the Writer remembers what the Sequence Number of the last processed Operation was)</li>
<li>All operations are processed, and added to the internal <strong>Segment Aggregators</strong> (one Aggregator per Segment)</li>
<li>Eligible Segment Aggregators are flushed to <strong>Storage</strong> (eligibility depends on the amount of data collected in each aggregator, and whether there are any Seal, Merge or Truncate operations queued up)<ul>
<li>Each time an Append operation is encountered, a trip to the <strong>Read Index</strong> may be required in order to get the contents of the append</li>
</ul>
</li>
<li>After every successful modification (write/seal/concat/truncate) to <strong>Storage</strong>, the <strong>Container Metadata</strong> is updated to reflect the changes.</li>
<li>The <strong>Durable Log</strong> is truncated (if eligible).</li>
</ol>
<h2 id="container-startup-normalrecovery">Container Startup (Normal/Recovery)</h2>
<p><img alt="Segment Store Container Startup" src="../img/Segment.Store.Recovery.png" /></p>
<p>The diagram above depicts these steps (note the step numbers may not match, but the order is the same):</p>
<ol>
<li>The <strong>Container Manager</strong> receives a request to start a Container in this instance of the <strong>Segment Store Service</strong>.<ul>
<li>It creates, registers, and starts the Container.</li>
</ul>
</li>
<li>The <strong>Container</strong> starts the <strong>Durable Log</strong> component.</li>
<li><strong>Durable Log</strong> initiates the recovery process (coordinated by the <strong>Recovery Executor</strong>).</li>
<li><strong>Recovery Executor</strong> reads all Data Frames from <strong>Durable Data Log</strong>.</li>
<li>Deserialized Operations from the read Data Frames are added to the <strong>Memory Operation Log</strong>.</li>
<li>The <strong>Container Metadata</strong> is updated by means of the <strong>Operation Metadata Updater</strong> (same as the one used inside Operation Processor).</li>
<li>The <strong>Read Index</strong> is populated with the contents of those Operations that apply to it.</li>
<li>The <strong>Container</strong> Starts the <strong>Storage Writer</strong>.<ul>
<li>The <strong>Storage Writer</strong>'s Main Loop starts processing operations from the <strong>Durable Log</strong>, and upon first encountering a new Segment, it reconciles its content (and metadata) with the reality that exists in <strong>Storage</strong>.</li>
</ul>
</li>
<li>After both the <strong>Durable Log</strong> and the <strong>Storage Writer</strong> have started, the <strong>Container</strong> is ready to start accepting new external requests.</li>
</ol>
                
                  
                
              
              
                
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../faq/" title="Pravega FAQ" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Pravega FAQ
              </span>
            </div>
          </a>
        
        
          <a href="../javadoc/" title="Java API Reference" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Java API Reference
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.6cdc17f0.js"></script>
      
      <script>app.initialize({version:"0.17.2",url:{base:".."}})</script>
      
    
    
      
        <script>!function(e,a,t,n,o,c,i){e.GoogleAnalyticsObject=o,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),i=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",i.parentNode.insertBefore(c,i)}(window,document,"script",0,"ga"),ga("create","UA-1508605-1","pravega.io"),ga("set","anonymizeIp",!0),ga("send","pageview");var links=document.getElementsByTagName("a");Array.prototype.map.call(links,function(e){e.host!=document.location.host&&e.addEventListener("click",function(){var a=e.getAttribute("data-md-action")||"follow";ga("send","event","outbound",a,e.href)})});var query=document.forms.search.query;query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})</script>
      
    
  </body>
</html>