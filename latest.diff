diff --git a/authplugin/src/main/java/io/pravega/auth/AuthHandler.java b/authplugin/src/main/java/io/pravega/auth/AuthHandler.java
new file mode 100644
index 0000000..2fdfc1f
--- /dev/null
+++ b/authplugin/src/main/java/io/pravega/auth/AuthHandler.java
@@ -0,0 +1,64 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.auth;
+
+import java.util.Map;
+
+/**
+ * Custom authorization/authentication handlers implement this interface.
+ * The implementations are loaded from the classpath using `ServiceLoader` (https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html)
+ * Pravega controller also implements this interface through {@link #PasswordAuthHandler}.
+ *
+ * Each custom auth handler is registered with a unique name.
+ * A client selects its auth handler by setting a grpc header with a name "method". T
+ * his is done by implementing `PravegaCredentials` interface and passing it to client calls.
+ *
+ */
+public interface AuthHandler {
+
+    enum Permissions {
+        NONE,
+        READ,
+        READ_UPDATE
+    }
+
+    /**
+     * Returns name of the handler. Only the first implementation with a unique name will be loaded.
+     * @return The unique name assigned to the handler.
+     */
+    String getHandlerName();
+
+    /**
+     * Authenticates a given request. Pravega controller passes the HTTP headers associated with the call.
+     * The custom implementation returns whether the user represented by these headers is authenticated.
+     *
+     * @param headers the key-value pairs passed through grpc.
+     * @return Returns true when the user is authenticated.
+     */
+    boolean authenticate(Map<String, String> headers);
+
+    /**
+     * Authorizes the access to a given resource. Pravega controller passes the HTTP headers associated with the call.
+     * The implementations of this interface should return the maximum level of authorization possible for the user represented
+     * by the headers.
+     *
+     * @param resource the resource that needs to be accessed.
+     * @param headers the context for authorization.
+     * @return The level of authorization.
+     */
+    Permissions authorize(String resource, Map<String, String> headers);
+
+    /**
+     * Sets the configuration. If the auth handler needs to access the server configuration, it can be accessed though this var.
+     *
+     * @param serverConfig The server configuration.
+     */
+    void initialize(ServerConfig serverConfig);
+}
diff --git a/authplugin/src/main/java/io/pravega/auth/ServerConfig.java b/authplugin/src/main/java/io/pravega/auth/ServerConfig.java
new file mode 100644
index 0000000..4b61afa
--- /dev/null
+++ b/authplugin/src/main/java/io/pravega/auth/ServerConfig.java
@@ -0,0 +1,16 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.auth;
+
+/**
+ * Represents the configuration object passed down to the custom plugin.
+ */
+public interface ServerConfig {
+}
diff --git a/build.gradle b/build.gradle
index c6d8827..d446016 100644
--- a/build.gradle
+++ b/build.gradle
@@ -91,6 +91,20 @@ project('common') {
 def withoutLogger = { exclude group: 'org.slf4j', module: 'slf4j-log4j12'
                       exclude group: 'org.slf4j', module: 'slf4j-simple' }
 
+project('authplugin') {
+    dependencies {
+    }
+
+    javadoc {
+        title = "Pravega Auth API"
+        failOnError = false
+
+        source {
+            sourceSets.main.java
+        }
+    }
+}
+
 project ('shared') {
     dependencies {
         compile project(':common')
@@ -145,7 +159,9 @@ project('client') {
         compile group: 'org.projectlombok', name: 'lombok', version: lombokVersion
         compile group: 'com.google.code.findbugs', name: 'annotations', version: findbugsVersion
         compile group: 'io.netty', name: 'netty-all', version: nettyVersion
+
         compile project(':common')
+   //     compile project(':authplugin')/
         compile project(':shared')
         compile project(':shared:protocol')
         compile project(":shared:controller-api")
@@ -160,6 +176,7 @@ project('client') {
         exclude "**/impl/**";
     }
 }
+
 project('test:testcommon') {
     dependencies {
         compile group: 'junit', name :'junit', version: junitVersion
@@ -245,6 +262,7 @@ project('segmentstore:server:host') {
 
     dependencies {
         compile project(':common')
+        compile project(":authplugin")
         compile project(':segmentstore:contracts')
         compile project(':client')
         compile project(':segmentstore:storage')
@@ -257,6 +275,7 @@ project('segmentstore:server:host') {
         testCompile group: 'org.apache.hadoop', name: 'hadoop-minicluster', version: hadoopVersion, withoutLogger
         testCompile project(path:':segmentstore:storage:impl', configuration:'testRuntime')
         testCompile group: 'commons-httpclient', name: 'commons-httpclient', version: '3.1'
+        compile 'io.jsonwebtoken:jjwt:0.9.0'
     }
 
     task createAppWithGCLogging(type: CreateStartScripts) {
@@ -391,6 +410,13 @@ project('shared:controller-api') {
         compile group: 'com.google.code.findbugs', name: 'annotations', version: findbugsVersion
         compile group: 'commons-io', name: 'commons-io', version: commonsioVersion
         compile group: 'io.netty', name: 'netty-all', version: nettyVersion
+
+        compile "io.grpc:grpc-netty:" + grpcVersion
+        compile "io.grpc:grpc-all:" + grpcVersion
+        compile "io.grpc:grpc-protobuf:" + grpcVersion
+        compile "io.grpc:grpc-stub:" + grpcVersion
+        // https://mvnrepository.com/artifact/io.netty/netty-tcnative-boringssl-static
+        compile group: 'io.netty', name: 'netty-tcnative-boringssl-static', version: '2.0.6.Final'
     }
 
     javadoc {
@@ -411,15 +437,31 @@ project('controller') {
                                  "-Dlogback.configurationFile=PRAVEGA_APP_HOME/conf/logback.xml",
                                  "-Dlog.dir=PRAVEGA_APP_HOME/logs",
                                  "-Dlog.name=controller"]
-
+    startScripts {
+        classpath += files('$APP_HOME/pluginlib')
+        doLast {
+            def scriptFile = file getUnixScript()
+            scriptFile.text = scriptFile.text.replace('$APP_HOME/lib/pluginlib', '$APP_HOME/pluginlib/*')
+        }
+    }
     applicationDistribution.from('src/conf') {
         into "conf"
         rename "application.conf", "controller.conf"
     }
 
+    applicationDistribution.into('') {
+        def pluginDirBase = new File('/tmp/dummy-dir')
+        pluginDirBase.mkdirs()
+        def logDir = new File(pluginDirBase.absolutePath + '/pluginlib')
+        logDir.mkdirs()
+
+        from {pluginDirBase}
+    }
+
     dependencies {
         compile project(':common')
         compile project(":shared:controller-api")
+        compile project(":authplugin")
         compile project(":client")
         compile project(":shared:metrics")
         runtime group: 'ch.qos.logback', name: 'logback-classic', version: qosLogbackVersion
@@ -438,6 +480,10 @@ project('controller') {
         compile group: 'org.glassfish.jersey.media', name: 'jersey-media-json-jackson', version: jerseyVersion
         testCompile project(':test:testcommon')
         testCompile group: 'org.apache.curator', name: 'curator-test', version: apacheCuratorVersion
+        compile 'io.jsonwebtoken:jjwt:0.9.0'
+        // https://mvnrepository.com/artifact/io.netty/netty-tcnative-boringssl-static
+        compile group: 'io.netty', name: 'netty-tcnative-boringssl-static', version: '2.0.6.Final'
+
     }
 
     task createAppWithGCLogging(type: CreateStartScripts) {
@@ -467,7 +513,16 @@ project('standalone') {
     applicationDefaultJvmArgs = ["-server", "-Xmx4g", "-XX:+HeapDumpOnOutOfMemoryError",
                                  "-Dlogback.configurationFile=PRAVEGA_APP_HOME/conf/logback.xml",
                                  "-Dlog.dir=PRAVEGA_APP_HOME/logs",
-                                 "-Dlog.name=pravega"]
+                                 "-Dlog.name=pravega",
+                                 "-Xdebug",
+                                 "-Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=y"]
+    startScripts {
+        classpath += files('./pluginlib')
+        doLast {
+            def scriptFile = file getUnixScript()
+            scriptFile.text = scriptFile.text.replace('$APP_HOME/lib/pluginlib', '$APP_HOME/pluginlib/*')
+        }
+    }
 
     dependencies {
         compile project(':common')
@@ -487,6 +542,8 @@ project('standalone') {
         compile group: 'org.apache.hadoop', name: 'hadoop-common', version: hadoopVersion, withoutLogger
         compile group: 'org.apache.hadoop', name: 'hadoop-hdfs', version: hadoopVersion, withoutLogger
         compile group: 'org.apache.hadoop', name: 'hadoop-minicluster', version: hadoopVersion, withoutLogger
+        // https://mvnrepository.com/artifact/io.netty/netty-tcnative-boringssl-static
+        compile group: 'io.netty', name: 'netty-tcnative-boringssl-static', version: '2.0.6.Final'
 
         testCompile project(':test:testcommon')
         testCompile project(path:':common', configuration:'testRuntime')
@@ -504,6 +561,11 @@ project('standalone') {
         classpath = sourceSets.main.runtimeClasspath
         systemProperties System.getProperties()
         systemProperties 'logback.configurationFile' : new File('config/logback.xml').absolutePath
+
+        if (systemProperties.get("extDirs") != null) {
+            classpath += files(systemProperties.get("extDirs"))
+        }
+
         jvmArgs "-Xdebug", "-Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n"
     }
 }
@@ -680,6 +742,7 @@ subprojects {
 }
 
 task publishAllJars() {
+    dependsOn ':authplugin:publish'
     dependsOn ':client:publish'
     dependsOn ':common:publish'
     dependsOn ':shared:publish'
@@ -751,6 +814,8 @@ distributions {
     client {
         baseName = "pravega-client"
         contents {
+            from { project(":authplugin").configurations.runtime }
+            from { project(":authplugin").configurations.runtime.allArtifacts.files }
             from { project(":client").configurations.runtime }
             from { project(":client").configurations.runtime.allArtifacts.files }
         }
diff --git a/checkstyle/import-control.xml b/checkstyle/import-control.xml
index 628ad20..6a3f29b 100644
--- a/checkstyle/import-control.xml
+++ b/checkstyle/import-control.xml
@@ -33,6 +33,7 @@
     <allow pkg="org.glassfish.hk2"/>
     <allow pkg="io.swagger"/>
     <allow pkg="javax.validation"/>
+    <allow pkg="javax.crypto"/>
     <allow pkg="com.fasterxml.jackson"/>
     <allow pkg="mesosphere"/>
     <allow pkg="feign"/>
@@ -42,5 +43,6 @@
     <allow pkg="org.jclouds" />
     <allow pkg="org.glassfish.grizzly" />
     <allow pkg="com.spotify" />
+    <allow pkg="io.jsonwebtoken" />
 
 </import-control>
diff --git a/checkstyle/suppressions.xml b/checkstyle/suppressions.xml
index 91928e3..f43a6bb 100644
--- a/checkstyle/suppressions.xml
+++ b/checkstyle/suppressions.xml
@@ -8,5 +8,7 @@
     <suppress checks="JavadocStyle" files=".+Test\.java" />
     <suppress checks="JavadocMethod" files=".+Test\.java" />
     <suppress files="[\\/]generated[\\/]" checks="[a-zA-Z0-9]*"/>
+    <suppress files="\.pem" checks="[a-zA-Z0-9]*"/>
+    <suppress files="passwd" checks="[a-zA-Z0-9]*"/>
 </suppressions>
 
diff --git a/client/src/main/java/io/pravega/client/ClientConfig.java b/client/src/main/java/io/pravega/client/ClientConfig.java
new file mode 100644
index 0000000..55c2feb
--- /dev/null
+++ b/client/src/main/java/io/pravega/client/ClientConfig.java
@@ -0,0 +1,60 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.client;
+
+import com.google.common.annotations.Beta;
+import io.pravega.client.stream.impl.Credentials;
+import java.net.URI;
+import lombok.Builder;
+import lombok.Data;
+
+/**
+ * This class contains configuration that is passed on to Pravega client.
+ * Please note that this is an experimental object and the contents and their interpretation may change
+ * in future.
+ */
+@Data
+@Builder
+@Beta
+public class ClientConfig {
+    /** controllerURI The controller rpc URI. This can be of 2 types
+     1. tcp://ip1:port1,ip2:port2,...
+        This is used if the controller endpoints are static and can be directly accessed.
+     2. pravega://ip1:port1,ip2:port2,...
+        This is used to autodiscovery the controller endpoints from an initial controller list.
+    */
+    @Builder.Default
+    private final URI controllerURI = URI.create("tcp://localhost");
+
+    /**
+     * Credentials to be passed on to the Pravega controller for authentication and authorization.
+     */
+    private final Credentials credentials;
+
+    /**
+     * Path to an optional truststore. If this is null or empty, the default JVM trust store is used.
+     * This is currently expected to be a signing certificate for the certification authority.
+     */
+    private final String trustStore;
+
+    /**
+     * If the flag {@link #isEnableTls is set, this flag decides whether to enable host name validation or not.
+     */
+    private boolean validateHostName;
+
+    public boolean isEnableTls() {
+        return this.controllerURI.getScheme().equals("tls") || this.controllerURI.getScheme().equals("ssl")
+                || this.controllerURI.getScheme().equals("pravegas");
+    }
+
+    public static final class PravegaClientConfigBuilder {
+        private boolean validateHostName = true;
+    }
+}
diff --git a/client/src/main/java/io/pravega/client/ClientFactory.java b/client/src/main/java/io/pravega/client/ClientFactory.java
index 0f69aed..5a0acb8 100644
--- a/client/src/main/java/io/pravega/client/ClientFactory.java
+++ b/client/src/main/java/io/pravega/client/ClientFactory.java
@@ -28,9 +28,8 @@ import io.pravega.client.stream.ReaderGroup;
 import io.pravega.client.stream.Serializer;
 import io.pravega.client.stream.impl.ClientFactoryImpl;
 import io.pravega.client.stream.impl.ControllerImpl;
-import java.net.URI;
-
 import io.pravega.client.stream.impl.ControllerImplConfig;
+import java.net.URI;
 import lombok.val;
 
 /**
@@ -46,7 +45,7 @@ import lombok.val;
  * {@link EventStreamWriter#writeEvent(String, Object)}. Events within a routing key are strictly
  * ordered (i.e. They must go the the same reader or its replacement). However because
  * {@link ReaderGroup}s process events in parallel there is no ordering between different readers.
- * 
+ *
  * <p>
  * A note on scaling: Because a stream can grow in its event rate, streams are divided into
  * Segments. For the most part this is an implementation detail. However its worth understanding
@@ -63,8 +62,19 @@ public interface ClientFactory extends AutoCloseable {
      * @return Instance of ClientFactory implementation.
      */
     static ClientFactory withScope(String scope, URI controllerUri) {
-        val connectionFactory = new ConnectionFactoryImpl(false);
-        return new ClientFactoryImpl(scope, new ControllerImpl(controllerUri, ControllerImplConfig.builder().build(),
+        return withScope(scope, ClientConfig.builder().controllerURI(controllerUri).build());
+    }
+
+    /**
+     * Creates a new instance of Client Factory.
+     *
+     * @param scope The scope string.
+     * @param config Configuration for the client.
+     * @return Instance of ClientFactory implementation.
+     */
+    static ClientFactory withScope(String scope, ClientConfig config) {
+        val connectionFactory = new ConnectionFactoryImpl(config);
+        return new ClientFactoryImpl(scope, new ControllerImpl(ControllerImplConfig.builder().clientConfig(config).build(),
                 connectionFactory.getInternalExecutor()), connectionFactory);
     }
 
@@ -91,7 +101,7 @@ public interface ClientFactory extends AutoCloseable {
      * <p>
      * Note that calling reader offline while the reader is still online may result in multiple
      * reader within the group receiving the same events.
-     * 
+     *
      * @param readerId A unique name (within the group) for this readers.
      * @param readerGroup The name of the group to join.
      * @param s The serializer for events.
@@ -103,7 +113,7 @@ public interface ClientFactory extends AutoCloseable {
 
     /**
      * Creates a new RevisionedStreamClient that will work with the specified stream.
-     * 
+     *
      * @param streamName The name of the stream for the synchronizer
      * @param serializer The serializer for updates.
      * @param config The client configuration
@@ -112,12 +122,12 @@ public interface ClientFactory extends AutoCloseable {
      */
     <T> RevisionedStreamClient<T> createRevisionedStreamClient(String streamName, Serializer<T> serializer,
             SynchronizerConfig config);
-    
+
     /**
      * Creates a new StateSynchronizer that will work on the specified stream.
-     * 
+     *
      * @param <StateT> The type of the state being synchronized.
-     * @param <UpdateT> The type of the updates being written. 
+     * @param <UpdateT> The type of the updates being written.
      * @param <InitT> The type of the initial update used.
      * @param streamName The name of the stream for the synchronizer
      * @param updateSerializer The serializer for updates.
@@ -130,18 +140,18 @@ public interface ClientFactory extends AutoCloseable {
                                                       Serializer<UpdateT> updateSerializer,
                                                       Serializer<InitT> initSerializer,
                                                       SynchronizerConfig config);
-    
+
     /**
      * Create a new batch client. A batch client can be used to perform bulk unordered reads without
      * the need to create a reader group.
-     * 
+     *
      * Please note this is an experimental API.
-     * 
+     *
      * @return A batch client
      */
     @Beta
     BatchClient createBatchClient();
-    
+
     /**
      * Closes the client factory. This will close any connections created through it.
      * @see java.lang.AutoCloseable#close()
diff --git a/client/src/main/java/io/pravega/client/admin/ReaderGroupManager.java b/client/src/main/java/io/pravega/client/admin/ReaderGroupManager.java
index f0e9b13..9bad0ea 100644
--- a/client/src/main/java/io/pravega/client/admin/ReaderGroupManager.java
+++ b/client/src/main/java/io/pravega/client/admin/ReaderGroupManager.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.client.admin;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
@@ -23,7 +24,7 @@ import java.util.Set;
  * Used to create and manage reader groups.
  */
 public interface ReaderGroupManager extends AutoCloseable {
-    
+
     /**
      * Creates a new instance of ReaderGroupManager.
      *
@@ -32,9 +33,20 @@ public interface ReaderGroupManager extends AutoCloseable {
      * @return Instance of Stream Manager implementation.
      */
     public static ReaderGroupManager withScope(String scope, URI controllerUri) {
-        return new ReaderGroupManagerImpl(scope, controllerUri, new ConnectionFactoryImpl(false));
+        return withScope(scope, ClientConfig.builder().controllerURI(controllerUri).build());
     }
-    
+
+    /**
+     * Creates a new instance of ReaderGroupManager.
+     *
+     * @param scope The Scope string.
+     * @param clientConfig Configuration for the client.
+     * @return Instance of Stream Manager implementation.
+     */
+    public static ReaderGroupManager withScope(String scope, ClientConfig clientConfig) {
+        return new ReaderGroupManagerImpl(scope, clientConfig, new ConnectionFactoryImpl(clientConfig));
+    }
+
     /**
      * Creates a new ReaderGroup
      * 
diff --git a/client/src/main/java/io/pravega/client/admin/StreamManager.java b/client/src/main/java/io/pravega/client/admin/StreamManager.java
index cbca1a6..a602877 100644
--- a/client/src/main/java/io/pravega/client/admin/StreamManager.java
+++ b/client/src/main/java/io/pravega/client/admin/StreamManager.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.client.admin;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.admin.impl.StreamManagerImpl;
 import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.client.stream.StreamCut;
@@ -19,7 +20,6 @@ import java.net.URI;
  * Used to create, delete, and manage Streams and ReaderGroups.
  */
 public interface StreamManager extends AutoCloseable {
-
     /**
      * Creates a new instance of StreamManager.
      *
@@ -27,9 +27,19 @@ public interface StreamManager extends AutoCloseable {
      * @return Instance of Stream Manager implementation.
      */
     public static StreamManager create(URI controller) {
-        return new StreamManagerImpl(controller);
+        return create(ClientConfig.builder().controllerURI(controller).build());
     }
-    
+
+    /**
+     * Creates a new instance of StreamManager.
+     *
+     * @param clientConfig Configuration for the client connection to Pravega.
+     * @return Instance of Stream Manager implementation.
+     */
+    public static StreamManager create(ClientConfig clientConfig) {
+        return new StreamManagerImpl(clientConfig);
+    }
+
     /**
      * Creates a new stream
      * <p>
diff --git a/client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java b/client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java
index e76ac15..8c8045a 100644
--- a/client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java
+++ b/client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.client.admin.impl;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.netty.impl.ConnectionFactory;
@@ -27,7 +28,6 @@ import io.pravega.client.stream.impl.JavaSerializer;
 import io.pravega.client.stream.impl.ReaderGroupImpl;
 import io.pravega.client.stream.impl.StreamImpl;
 import io.pravega.shared.NameUtils;
-import java.net.URI;
 import java.util.Arrays;
 import java.util.Set;
 import lombok.Lombok;
@@ -47,10 +47,11 @@ public class ReaderGroupManagerImpl implements ReaderGroupManager {
     private final Controller controller;
     private final ConnectionFactory connectionFactory;
 
-    public ReaderGroupManagerImpl(String scope, URI controllerUri, ConnectionFactory connectionFactory) {
+    public ReaderGroupManagerImpl(String scope, ClientConfig config, ConnectionFactory connectionFactory) {
         this.scope = scope;
-        this.controller = new ControllerImpl(controllerUri, ControllerImplConfig.builder().build(),
+        this.controller = new ControllerImpl(ControllerImplConfig.builder().clientConfig(config).build(),
                 connectionFactory.getInternalExecutor());
+
         this.connectionFactory = connectionFactory;
         this.clientFactory = new ClientFactoryImpl(scope, this.controller, connectionFactory);
     }
diff --git a/client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java b/client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java
index 97f59d7..5f6ba42 100644
--- a/client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java
+++ b/client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java
@@ -11,6 +11,7 @@ package io.pravega.client.admin.impl;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.admin.StreamManager;
 import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.client.stream.impl.Controller;
@@ -20,10 +21,8 @@ import io.pravega.client.stream.StreamCut;
 import io.pravega.common.concurrent.ExecutorServiceHelpers;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.shared.NameUtils;
-import lombok.extern.slf4j.Slf4j;
-
-import java.net.URI;
 import java.util.concurrent.ScheduledExecutorService;
+import lombok.extern.slf4j.Slf4j;
 
 /**
  * A stream manager. Used to bootstrap the client.
@@ -35,9 +34,10 @@ public class StreamManagerImpl implements StreamManager {
 
     private final ScheduledExecutorService executor; 
     
-    public StreamManagerImpl(URI controllerUri) {
+    public StreamManagerImpl(ClientConfig clientConfig) {
         this.executor = ExecutorServiceHelpers.newScheduledThreadPool(1, "StreamManager-Controller");
-        this.controller = new ControllerImpl(controllerUri, ControllerImplConfig.builder().build(), executor);
+        this.controller = new ControllerImpl(ControllerImplConfig.builder().clientConfig(clientConfig) .build(), executor);
+
     }
 
     @VisibleForTesting
diff --git a/client/src/main/java/io/pravega/client/batch/impl/BatchClientImpl.java b/client/src/main/java/io/pravega/client/batch/impl/BatchClientImpl.java
index 98e0614..1c812eb 100644
--- a/client/src/main/java/io/pravega/client/batch/impl/BatchClientImpl.java
+++ b/client/src/main/java/io/pravega/client/batch/impl/BatchClientImpl.java
@@ -27,11 +27,14 @@ import io.pravega.client.stream.Stream;
 import io.pravega.client.stream.impl.Controller;
 import io.pravega.client.stream.impl.StreamCutImpl;
 import io.pravega.client.stream.impl.StreamImpl;
+import io.pravega.client.stream.impl.StreamSegmentSuccessors;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.SortedSet;
 import java.util.TreeSet;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.concurrent.GuardedBy;
 import lombok.Cleanup;
 import org.apache.commons.lang3.NotImplementedException;
 
@@ -44,10 +47,14 @@ public class BatchClientImpl implements BatchClient {
     private final SegmentInputStreamFactory inputStreamFactory;
     private final SegmentMetadataClientFactory segmentMetadataClientFactory;
 
+    @GuardedBy("this")
+    private final AtomicReference<String> latestDelegationToken;
+
     public BatchClientImpl(Controller controller, ConnectionFactory connectionFactory) {
         this.controller = controller;
         inputStreamFactory = new SegmentInputStreamFactoryImpl(controller, connectionFactory);
         segmentMetadataClientFactory = new SegmentMetadataClientFactoryImpl(controller, connectionFactory);
+        latestDelegationToken = new AtomicReference<String>();
     }
 
     private StreamInfo getStreamInfo(Stream stream) {
@@ -72,22 +79,32 @@ public class BatchClientImpl implements BatchClient {
                                                              RuntimeException::new);
         SortedSet<Segment> result = new TreeSet<>();
         result.addAll(segments.keySet());
-        result.addAll(getAndHandleExceptions(controller.getSuccessors(new StreamCutImpl(stream, segments)),
-                                             RuntimeException::new));
+        StreamSegmentSuccessors successors = getAndHandleExceptions(controller.getSuccessors(new StreamCutImpl(stream, segments)),
+                RuntimeException::new);
+
+        result.addAll(successors.getSegments());
+        synchronized (this) {
+            latestDelegationToken.set(successors.getDelegationToken());
+        }
         return Iterators.transform(result.iterator(), s -> segmentToInfo(s));
     }
 
     private SegmentInfo segmentToInfo(Segment s) {
         @Cleanup
         SegmentMetadataClient client = segmentMetadataClientFactory.createSegmentMetadataClient(s);
-        return client.getSegmentInfo();
+
+        String delegationToken;
+        synchronized (this) {
+            delegationToken = latestDelegationToken.get();
+        }
+        return client.getSegmentInfo(delegationToken);
     }
 
     @Override
     public <T> SegmentIterator<T> readSegment(Segment segment, Serializer<T> deserializer) {
         @Cleanup
         SegmentMetadataClient metadataClient = segmentMetadataClientFactory.createSegmentMetadataClient(segment);
-        SegmentInfo segmentInfo = metadataClient.getSegmentInfo();
+        SegmentInfo segmentInfo = metadataClient.getSegmentInfo(latestDelegationToken.get());
         return new SegmentIteratorImpl<>(inputStreamFactory, segment, deserializer, segmentInfo.getStartingOffset(), segmentInfo.getWriteOffset());
     }
 
@@ -95,7 +112,7 @@ public class BatchClientImpl implements BatchClient {
     public <T> SegmentIterator<T> readSegment(Segment segment, Serializer<T> deserializer, long startingOffset) {
         @Cleanup
         SegmentMetadataClient metadataClient = segmentMetadataClientFactory.createSegmentMetadataClient(segment);
-        SegmentInfo segmentInfo = metadataClient.getSegmentInfo();
+        SegmentInfo segmentInfo = metadataClient.getSegmentInfo(latestDelegationToken.get());
         return new SegmentIteratorImpl<>(inputStreamFactory, segment, deserializer, startingOffset, segmentInfo.getWriteOffset());
     }
 
diff --git a/client/src/main/java/io/pravega/client/netty/impl/ConnectionFactoryImpl.java b/client/src/main/java/io/pravega/client/netty/impl/ConnectionFactoryImpl.java
index 0ac14b5..1acde14 100644
--- a/client/src/main/java/io/pravega/client/netty/impl/ConnectionFactoryImpl.java
+++ b/client/src/main/java/io/pravega/client/netty/impl/ConnectionFactoryImpl.java
@@ -11,6 +11,7 @@ package io.pravega.client.netty.impl;
 
 
 import com.google.common.base.Preconditions;
+import com.google.common.base.Strings;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
@@ -29,8 +30,10 @@ import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslContextBuilder;
+import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.ssl.util.FingerprintTrustManagerFactory;
 import io.netty.util.concurrent.GlobalEventExecutor;
+import io.pravega.client.ClientConfig;
 import io.pravega.common.Exceptions;
 import io.pravega.common.concurrent.ExecutorServiceHelpers;
 import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;
@@ -41,11 +44,14 @@ import io.pravega.shared.protocol.netty.ExceptionLoggingHandler;
 import io.pravega.shared.protocol.netty.PravegaNodeUri;
 import io.pravega.shared.protocol.netty.ReplyProcessor;
 import io.pravega.shared.protocol.netty.WireCommands;
+import java.io.File;
 import java.security.NoSuchAlgorithmException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLParameters;
 import lombok.extern.slf4j.Slf4j;
 
 @Slf4j
@@ -54,9 +60,9 @@ public final class ConnectionFactoryImpl implements ConnectionFactory {
     private static final Integer POOL_SIZE = Integer.valueOf(
             System.getProperty("pravega.client.internal.threadpool.size",
                     String.valueOf(Runtime.getRuntime().availableProcessors())));
-    private final boolean ssl;
     private EventLoopGroup group;
     private boolean nio = false;
+    private final ClientConfig clientConfig;
     private final AtomicBoolean closed = new AtomicBoolean(false);
     private final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(POOL_SIZE,
                                                                                                     "clientInternal");
@@ -64,11 +70,10 @@ public final class ConnectionFactoryImpl implements ConnectionFactory {
 
     /**
      * Actual implementation of ConnectionFactory interface.
-     *
-     * @param ssl Whether connection should use SSL or not.
+     * @param clientConfig Configuration object holding details about connection to the segmentstore.
      */
-    public ConnectionFactoryImpl(boolean ssl) {
-        this.ssl = ssl;
+    public ConnectionFactoryImpl(ClientConfig clientConfig) {
+        this.clientConfig = clientConfig;
         try {
             this.group = new EpollEventLoopGroup();
         } catch (ExceptionInInitializerError | UnsatisfiedLinkError | NoClassDefFoundError e) {
@@ -83,12 +88,17 @@ public final class ConnectionFactoryImpl implements ConnectionFactory {
         Preconditions.checkNotNull(location);
         Exceptions.checkNotClosed(closed.get(), this);
         final SslContext sslCtx;
-        if (ssl) {
+        if (clientConfig.isEnableTls()) {
             try {
-                sslCtx = SslContextBuilder.forClient()
-                                          .trustManager(FingerprintTrustManagerFactory
-                                                  .getInstance(FingerprintTrustManagerFactory.getDefaultAlgorithm()))
-                                          .build();
+                SslContextBuilder sslCtxFactory = SslContextBuilder.forClient();
+                if (Strings.isNullOrEmpty(clientConfig.getTrustStore())) {
+                    sslCtxFactory = sslCtxFactory.trustManager(FingerprintTrustManagerFactory
+                                                      .getInstance(FingerprintTrustManagerFactory.getDefaultAlgorithm()));
+                } else {
+                    sslCtxFactory = SslContextBuilder.forClient()
+                                              .trustManager(new File(clientConfig.getTrustStore()));
+                }
+                sslCtx = sslCtxFactory.build();
             } catch (SSLException | NoSuchAlgorithmException e) {
                 throw new RuntimeException(e);
             }
@@ -106,7 +116,15 @@ public final class ConnectionFactoryImpl implements ConnectionFactory {
              public void initChannel(SocketChannel ch) throws Exception {
                  ChannelPipeline p = ch.pipeline();
                  if (sslCtx != null) {
-                     p.addLast(sslCtx.newHandler(ch.alloc(), location.getEndpoint(), location.getPort()));
+                     SslHandler sslHandler = sslCtx.newHandler(ch.alloc(), location.getEndpoint(), location.getPort());
+
+                     if (clientConfig.isValidateHostName()) {
+                         SSLEngine sslEngine = sslHandler.engine();
+                         SSLParameters sslParameters = sslEngine.getSSLParameters();
+                         sslParameters.setEndpointIdentificationAlgorithm("HTTPS");
+                         sslEngine.setSSLParameters(sslParameters);
+                     }
+                     p.addLast(sslHandler);
                  }
                  // p.addLast(new LoggingHandler(LogLevel.INFO));
                  p.addLast(new ExceptionLoggingHandler(location.getEndpoint()),
diff --git a/client/src/main/java/io/pravega/client/segment/impl/AsyncSegmentInputStreamImpl.java b/client/src/main/java/io/pravega/client/segment/impl/AsyncSegmentInputStreamImpl.java
index f74216f..aa3e5cf 100644
--- a/client/src/main/java/io/pravega/client/segment/impl/AsyncSegmentInputStreamImpl.java
+++ b/client/src/main/java/io/pravega/client/segment/impl/AsyncSegmentInputStreamImpl.java
@@ -15,6 +15,7 @@ import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.stream.impl.ConnectionClosedException;
 import io.pravega.client.stream.impl.Controller;
 import io.pravega.common.Exceptions;
+import io.pravega.common.auth.AuthenticationException;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.common.util.Retry;
 import io.pravega.common.util.Retry.RetryWithBackoff;
@@ -50,6 +51,7 @@ class AsyncSegmentInputStreamImpl extends AsyncSegmentInputStream {
     private final ResponseProcessor responseProcessor = new ResponseProcessor();
     private final AtomicBoolean closed = new AtomicBoolean(false);
     private final Controller controller;
+    private final String delegationToken;
 
     private final class ResponseProcessor extends FailingReplyProcessor {
 
@@ -115,7 +117,13 @@ class AsyncSegmentInputStreamImpl extends AsyncSegmentInputStream {
             log.warn("Processing failure: ", error);
             closeConnection(error);
         }
-        
+
+        @Override
+        public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+            log.warn("Auth failed {}", authTokenCheckFailed);
+            closeConnection(new AuthenticationException(authTokenCheckFailed.toString()));
+        }
+
         private void checkSegment(String segment) {
             Preconditions.checkState(segmentId.getScopedName().equals(segment),
                     "Operating on segmentId {} but received sealed for segment {}",
@@ -124,8 +132,9 @@ class AsyncSegmentInputStreamImpl extends AsyncSegmentInputStream {
         }
     }
 
-    public AsyncSegmentInputStreamImpl(Controller controller, ConnectionFactory connectionFactory, Segment segment) {
+    public AsyncSegmentInputStreamImpl(Controller controller, ConnectionFactory connectionFactory, Segment segment, String delegationToken) {
         super(segment);
+        this.delegationToken = delegationToken;
         Preconditions.checkNotNull(controller);
         Preconditions.checkNotNull(connectionFactory);
         Preconditions.checkNotNull(segment);
@@ -149,7 +158,7 @@ class AsyncSegmentInputStreamImpl extends AsyncSegmentInputStream {
     @Override
     public CompletableFuture<SegmentRead> read(long offset, int length) {
         Exceptions.checkNotClosed(closed.get(), this);
-        WireCommands.ReadSegment request = new WireCommands.ReadSegment(segmentId.getScopedName(), offset, length);
+        WireCommands.ReadSegment request = new WireCommands.ReadSegment(segmentId.getScopedName(), offset, length, this.delegationToken);
 
         return backoffSchedule.retryingOn(Exception.class)
                 .throwingOn(ConnectionClosedException.class)
diff --git a/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamFactoryImpl.java b/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamFactoryImpl.java
index 6276609..a3596b4 100644
--- a/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamFactoryImpl.java
+++ b/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamFactoryImpl.java
@@ -9,12 +9,12 @@
  */
 package io.pravega.client.segment.impl;
 
-import java.util.concurrent.ExecutionException;
+import com.google.common.annotations.VisibleForTesting;
 import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.stream.impl.Controller;
 import io.pravega.common.Exceptions;
-import com.google.common.annotations.VisibleForTesting;
-
+import io.pravega.common.concurrent.Futures;
+import java.util.concurrent.ExecutionException;
 import lombok.RequiredArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
 
@@ -33,7 +33,8 @@ public class SegmentInputStreamFactoryImpl implements SegmentInputStreamFactory
 
     @Override
     public SegmentInputStream createInputStreamForSegment(Segment segment, int bufferSize) {
-    AsyncSegmentInputStreamImpl result = new AsyncSegmentInputStreamImpl(controller, cf, segment);
+        String delegationToken = Futures.getAndHandleExceptions(controller.getOrRefreshDelegationTokenFor(segment.getScope(), segment.getStream().getStreamName()), RuntimeException::new);
+    AsyncSegmentInputStreamImpl result = new AsyncSegmentInputStreamImpl(controller, cf, segment, delegationToken);
         try {
             Exceptions.handleInterrupted(() -> result.getConnection().get());
         } catch (ExecutionException e) {
diff --git a/client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClient.java b/client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClient.java
index 55b56ba..fced01a 100644
--- a/client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClient.java
+++ b/client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClient.java
@@ -18,17 +18,19 @@ public interface SegmentMetadataClient extends AutoCloseable {
     
     /**
      * Returns info for the current segment.
-     * 
+     *
+     * @param delegationToken token to be passed on to segmentstore for validation.
      * @return Metadata about the segment.
      */
-    abstract SegmentInfo getSegmentInfo();
+    abstract SegmentInfo getSegmentInfo(String delegationToken);
     
     /**
      * Returns the length of the current segment. i.e. the total length of all data written to the segment.
      *
+     * @param delegationToken token to be passed on to segmentstore for validation.
      * @return The length of the current segment.
      */
-    abstract long fetchCurrentSegmentLength();
+    abstract long fetchCurrentSegmentLength(String delegationToken);
 
     /**
      * Gets the current value of the provided attribute.
@@ -43,18 +45,20 @@ public interface SegmentMetadataClient extends AutoCloseable {
      * @param attribute The attribute to set
      * @param expectedValue The value the attribute is expected to be
      * @param newValue The new value for the attribute
+     * @param delegationToken delegation token to be handed to the segmentstore.
      * @return If the replacement occurred. (False if the attribute was not expectedValue)
      */
-    abstract boolean compareAndSetAttribute(SegmentAttribute attribute, long expectedValue, long newValue);
+    abstract boolean compareAndSetAttribute(SegmentAttribute attribute, long expectedValue, long newValue, String delegationToken);
     
     /**
      * Deletes all data before the offset of the provided segment.
      * This data will no longer be readable. Existing offsets are not affected by this operations. 
-     * The new startingOffset will be reflected in {@link SegmentMetadataClient#getSegmentInfo().startingOffset}.
+     * The new startingOffset will be reflected in {@link SegmentMetadataClient#getSegmentInfo(String).startingOffset}.
      * @param segment The segment to truncate.
      * @param offset The offset the segment should be truncated at.
+     * @param delegationToken delegation token to be handed to the segmentstore.
      */
-    abstract void truncateSegment(Segment segment, long offset);
+    abstract void truncateSegment(Segment segment, long offset, String delegationToken);
     
     @Override
     abstract void close();
diff --git a/client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClientImpl.java b/client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClientImpl.java
index 0474dd3..a7b10da 100644
--- a/client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClientImpl.java
+++ b/client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClientImpl.java
@@ -15,6 +15,7 @@ import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.stream.impl.ConnectionClosedException;
 import io.pravega.client.stream.impl.Controller;
 import io.pravega.common.Exceptions;
+import io.pravega.common.auth.AuthenticationException;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.common.util.Retry;
 import io.pravega.common.util.Retry.RetryWithBackoff;
@@ -39,8 +40,8 @@ import java.util.function.Supplier;
 import javax.annotation.concurrent.GuardedBy;
 import lombok.RequiredArgsConstructor;
 import lombok.SneakyThrows;
-import lombok.val;
 import lombok.extern.slf4j.Slf4j;
+import lombok.val;
 
 @RequiredArgsConstructor
 @Slf4j
@@ -114,7 +115,7 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
                 future.complete(segmentTruncated);
             }
         }
-        
+
         @Override
         public void segmentIsTruncated(SegmentIsTruncated segmentIsTruncated) {
             log.debug("Received segment is truncated {}", segmentIsTruncated);
@@ -128,7 +129,7 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
                 future.complete(new SegmentTruncated(segmentIsTruncated.getRequestId(), segmentIsTruncated.getSegment()));
             }
         }
-        
+
         @Override
         public void connectionDropped() {
             closeConnection(new ConnectionFailedException());
@@ -149,6 +150,11 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
             log.warn("Processing failure: ", error);
             closeConnection(error);
         }
+
+        @Override
+        public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+            closeConnection(new AuthenticationException(authTokenCheckFailed.toString()));
+        }
     }
 
     private void closeConnection(Throwable exceptionToInflightRequests) {
@@ -204,7 +210,7 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
         });
     }
     
-    private CompletableFuture<WireCommands.StreamSegmentInfo> getStreamSegmentInfo() {
+    private CompletableFuture<WireCommands.StreamSegmentInfo> getStreamSegmentInfo(String delegationToken) {
         CompletableFuture<WireCommands.StreamSegmentInfo> result = new CompletableFuture<>();
         long requestId = requestIdGenerator.get();
         synchronized (lock) {
@@ -212,7 +218,7 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
         }
         getConnection().thenAccept(c -> {
             log.debug("Getting segment info for segment: {}", segmentId);
-            send(c, new WireCommands.GetStreamSegmentInfo(requestId, segmentId.getScopedName()));
+            send(c, new WireCommands.GetStreamSegmentInfo(requestId, segmentId.getScopedName(), delegationToken));
         }).exceptionally(e -> {
             closeConnection(e);
             return null;
@@ -231,17 +237,21 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
         synchronized (lock) {
             getAttributeRequests.put(requestId, result);
         }
-        getConnection().thenAccept(c -> {
-            log.debug("Getting segment attribute: {}", attributeId);
-            send(c, new WireCommands.GetSegmentAttribute(requestId, segmentId.getScopedName(), attributeId));
-        }).exceptionally(e -> {
+        getConnection()
+                .thenCombine(controller.getOrRefreshDelegationTokenFor(segmentId.getScope(), segmentId.getStreamName()),
+                        (c, token) -> {
+                            log.debug("Getting segment attribute: {}", attributeId);
+                            send(c, new WireCommands.GetSegmentAttribute(requestId, segmentId.getScopedName(),
+                                    attributeId, token));
+                            return null;
+                        }).exceptionally(e -> {
             closeConnection(e);
             return null;
         });
         return result;
     }
     
-    private CompletableFuture<WireCommands.SegmentAttributeUpdated> updatePropertyAsync(UUID attributeId, long expected, long value) {
+    private CompletableFuture<WireCommands.SegmentAttributeUpdated> updatePropertyAsync(UUID attributeId, String delegationToken, long expected, long value) {
         CompletableFuture<WireCommands.SegmentAttributeUpdated> result = new CompletableFuture<>();
         long requestId = requestIdGenerator.get();
         synchronized (lock) {
@@ -249,15 +259,15 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
         }
         getConnection().thenAccept(c -> {
             log.trace("Updating segment attribute: {}", attributeId);
-            send(c, new WireCommands.UpdateSegmentAttribute(requestId, segmentId.getScopedName(), attributeId, value, expected));
+            send(c, new WireCommands.UpdateSegmentAttribute(requestId, segmentId.getScopedName(), attributeId, value, expected, delegationToken));
         }).exceptionally(e -> {
             closeConnection(e);
             return null;
         });
         return result;
     }
-    
-    private CompletableFuture<WireCommands.SegmentTruncated> truncateSegmentAsync(Segment segment, long offset) {
+
+    private CompletableFuture<WireCommands.SegmentTruncated> truncateSegmentAsync(Segment segment, long offset, String delegationToken) {
         CompletableFuture<WireCommands.SegmentTruncated> result = new CompletableFuture<>();
         long requestId = requestIdGenerator.get();
         synchronized (lock) {
@@ -265,20 +275,20 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
         }
         getConnection().thenAccept(c -> {
             log.trace("Truncating segment: {}", segment);
-            send(c, new WireCommands.TruncateSegment(requestId, segment.getScopedName(), offset));
+            send(c, new WireCommands.TruncateSegment(requestId, segment.getScopedName(), offset, delegationToken));
         }).exceptionally(e -> {
             closeConnection(e);
             return null;
         });
         return result;
     }
-    
+
     @Override
-    public long fetchCurrentSegmentLength() {
+    public long fetchCurrentSegmentLength(String delegationToken) {
         Exceptions.checkNotClosed(closed.get(), this);
         val future = RETRY_SCHEDULE.retryingOn(ConnectionFailedException.class)
                                    .throwingOn(NoSuchSegmentException.class)
-                                   .runAsync(() -> getStreamSegmentInfo(), connectionFactory.getInternalExecutor());
+                                   .runAsync(() -> getStreamSegmentInfo(delegationToken), connectionFactory.getInternalExecutor());
         return Futures.getThrowingException(future).getWriteOffset();
     }
 
@@ -293,11 +303,11 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
     }
 
     @Override
-    public boolean compareAndSetAttribute(SegmentAttribute attribute, long expectedValue, long newValue) {
+    public boolean compareAndSetAttribute(SegmentAttribute attribute, long expectedValue, long newValue, String delegationToken) {
         Exceptions.checkNotClosed(closed.get(), this);
         val future = RETRY_SCHEDULE.retryingOn(ConnectionFailedException.class)
                                    .throwingOn(NoSuchSegmentException.class)
-                                   .runAsync(() -> updatePropertyAsync(attribute.getValue(), expectedValue, newValue),
+                                   .runAsync(() -> updatePropertyAsync(attribute.getValue(), delegationToken, expectedValue, newValue),
                                              connectionFactory.getInternalExecutor());
         return Futures.getThrowingException(future).isSuccess();
     }
@@ -311,19 +321,19 @@ class SegmentMetadataClientImpl implements SegmentMetadataClient {
     }
 
     @Override
-    public SegmentInfo getSegmentInfo() {
+    public SegmentInfo getSegmentInfo(String delegationToken) {
         val future = RETRY_SCHEDULE.retryingOn(ConnectionFailedException.class)
                                    .throwingOn(NoSuchSegmentException.class)
-                                   .runAsync(() -> getStreamSegmentInfo(), connectionFactory.getInternalExecutor());
+                                   .runAsync(() -> getStreamSegmentInfo(delegationToken), connectionFactory.getInternalExecutor());
         StreamSegmentInfo info = future.join();
         return new SegmentInfo(segmentId, info.getStartOffset(), info.getWriteOffset(), info.isSealed(), info.getLastModified());
     }
 
     @Override
-    public void truncateSegment(Segment segment, long offset) {
+    public void truncateSegment(Segment segment, long offset, String delegationToken) {
         val future = RETRY_SCHEDULE.retryingOn(ConnectionFailedException.class)
                                    .throwingOn(NoSuchSegmentException.class)
-                                   .runAsync(() -> truncateSegmentAsync(segment, offset),
+                                   .runAsync(() -> truncateSegmentAsync(segment, offset, delegationToken),
                                              connectionFactory.getInternalExecutor());
         future.join();
     }
diff --git a/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamFactory.java b/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamFactory.java
index 7c02966..863f02c 100644
--- a/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamFactory.java
+++ b/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamFactory.java
@@ -25,9 +25,10 @@ public interface SegmentOutputStreamFactory {
      * @param txId    The transaction id.
      * @param segmentSealedCallback Method to be executed on receiving SegmentSealed from SSS.
      * @param config  The configuration for the writer
+     * @param delegationToken token to pass on to segmentstore to authenticate access to the segment.
      * @return New instance of SegmentOutputStream with an open transaction.
      */
-    SegmentOutputStream createOutputStreamForTransaction(Segment segment, UUID txId, Consumer<Segment> segmentSealedCallback, EventWriterConfig config);
+    SegmentOutputStream createOutputStreamForTransaction(Segment segment, UUID txId, Consumer<Segment> segmentSealedCallback, EventWriterConfig config, String delegationToken);
 
     /**
      * Creates a stream for an existing segment. This operation will fail if the segment does not
@@ -37,9 +38,10 @@ public interface SegmentOutputStreamFactory {
      * in the same process space).
      *
      * @param segment The segment.
-     * @param config  The configuration for the writer
      * @param segmentSealedCallback Method to be executed on receiving SegmentSealed from SSS.
+     * @param config  The configuration for the writer
+     * @param delegationToken token to pass on to segmentstore to authenticate access to the segment.
      * @return New instance of SegmentOutputStream for writing.
      */
-    SegmentOutputStream createOutputStreamForSegment(Segment segment, Consumer<Segment> segmentSealedCallback, EventWriterConfig config);
+    SegmentOutputStream createOutputStreamForSegment(Segment segment, Consumer<Segment> segmentSealedCallback, EventWriterConfig config, String delegationToken);
 }
diff --git a/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamFactoryImpl.java b/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamFactoryImpl.java
index 6ad7285..30ea05e 100644
--- a/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamFactoryImpl.java
+++ b/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamFactoryImpl.java
@@ -32,15 +32,15 @@ public class SegmentOutputStreamFactoryImpl implements SegmentOutputStreamFactor
 
     @Override
     public SegmentOutputStream createOutputStreamForTransaction(Segment segment, UUID txId, Consumer<Segment> segmentSealedCallback,
-                                                                EventWriterConfig config) {
+                                                                EventWriterConfig config, String delegationToken) {
         return new SegmentOutputStreamImpl(StreamSegmentNameUtils.getTransactionNameFromId(segment.getScopedName(), txId), controller, cf,
-                UUID.randomUUID(), segmentSealedCallback, getRetryFromConfig(config));
+                UUID.randomUUID(), segmentSealedCallback, getRetryFromConfig(config), delegationToken);
     }
 
     @Override
-    public SegmentOutputStream createOutputStreamForSegment(Segment segment, Consumer<Segment> segmentSealedCallback, EventWriterConfig config) {
+    public SegmentOutputStream createOutputStreamForSegment(Segment segment, Consumer<Segment> segmentSealedCallback, EventWriterConfig config, String delegationToken) {
         SegmentOutputStreamImpl result = new SegmentOutputStreamImpl(segment.getScopedName(), controller, cf,
-                UUID.randomUUID(), segmentSealedCallback, getRetryFromConfig(config));
+                UUID.randomUUID(), segmentSealedCallback, getRetryFromConfig(config), delegationToken);
         try {
             result.getConnection();
         } catch (RetriesExhaustedException | SegmentSealedException e) {
diff --git a/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java b/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java
index 96b6011..aa7ec13 100644
--- a/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java
+++ b/client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java
@@ -17,6 +17,7 @@ import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.stream.impl.Controller;
 import io.pravega.client.stream.impl.PendingEvent;
 import io.pravega.common.Exceptions;
+import io.pravega.common.auth.AuthenticationException;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.common.util.Retry;
 import io.pravega.common.util.Retry.RetryWithBackoff;
@@ -26,6 +27,7 @@ import io.pravega.shared.protocol.netty.Append;
 import io.pravega.shared.protocol.netty.ConnectionFailedException;
 import io.pravega.shared.protocol.netty.FailingReplyProcessor;
 import io.pravega.shared.protocol.netty.PravegaNodeUri;
+import io.pravega.shared.protocol.netty.WireCommands;
 import io.pravega.shared.protocol.netty.WireCommands.AppendSetup;
 import io.pravega.shared.protocol.netty.WireCommands.ConditionalCheckFailed;
 import io.pravega.shared.protocol.netty.WireCommands.DataAppended;
@@ -79,7 +81,8 @@ class SegmentOutputStreamImpl implements SegmentOutputStream {
     private final ResponseProcessor responseProcessor = new ResponseProcessor();
     private final RetryWithBackoff retrySchedule;
     private final Object writeOrderLock = new Object();
-    
+    private final String delegationToken;
+
     /**
      * Internal object that tracks the state of the connection.
      * All mutations of data occur inside of this class. All operations are protected by the lock object.
@@ -412,6 +415,12 @@ class SegmentOutputStreamImpl implements SegmentOutputStream {
         public void processingFailure(Exception error) {
             failConnection(error);
         }
+
+        @Override
+        public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+            log.warn("Auth failed {}", authTokenCheckFailed);
+            failConnection(new AuthenticationException(authTokenCheckFailed.toString()));
+        }
     }
 
     /**
@@ -529,7 +538,7 @@ class SegmentOutputStreamImpl implements SegmentOutputStream {
                          return connectionFactory.establishConnection(uri, responseProcessor);
                      }, connectionFactory.getInternalExecutor()).thenComposeAsync(connection -> {
                          CompletableFuture<Void> connectionSetupFuture = state.newConnection(connection);
-                         SetupAppend cmd = new SetupAppend(requestIdGenerator.get(), writerId, segmentName);
+                         SetupAppend cmd = new SetupAppend(requestIdGenerator.get(), writerId, segmentName, delegationToken);
                          try {
                              connection.send(cmd);
                          } catch (ConnectionFailedException e1) {
diff --git a/client/src/main/java/io/pravega/client/state/impl/RevisionedStreamClientImpl.java b/client/src/main/java/io/pravega/client/state/impl/RevisionedStreamClientImpl.java
index 06d69c0..b90eaa4 100644
--- a/client/src/main/java/io/pravega/client/state/impl/RevisionedStreamClientImpl.java
+++ b/client/src/main/java/io/pravega/client/state/impl/RevisionedStreamClientImpl.java
@@ -21,6 +21,7 @@ import io.pravega.client.state.Revision;
 import io.pravega.client.state.RevisionedStreamClient;
 import io.pravega.client.stream.Serializer;
 import io.pravega.client.stream.TruncatedDataException;
+import io.pravega.client.stream.impl.Controller;
 import io.pravega.client.stream.impl.PendingEvent;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.shared.protocol.netty.WireCommands;
@@ -50,6 +51,9 @@ public class RevisionedStreamClientImpl<T> implements RevisionedStreamClient<T>
     @GuardedBy("lock")
     private final SegmentMetadataClient meta;
     private final Serializer<T> serializer;
+    private final Controller controller;
+    private final String delegationToken;
+
     private final Object lock = new Object();
 
     @Override
@@ -102,7 +106,7 @@ public class RevisionedStreamClientImpl<T> implements RevisionedStreamClient<T>
     public Iterator<Entry<Revision, T>> readFrom(Revision start) {
         synchronized (lock) {
             long startOffset = start.asImpl().getOffsetInSegment();
-            SegmentInfo segmentInfo = meta.getSegmentInfo();
+            SegmentInfo segmentInfo = meta.getSegmentInfo(delegationToken);
             long endOffset = segmentInfo.getWriteOffset();
             if (startOffset < segmentInfo.getStartingOffset()) {
                 throw new TruncatedDataException("Data at the supplied revision has been truncated.");
@@ -115,7 +119,7 @@ public class RevisionedStreamClientImpl<T> implements RevisionedStreamClient<T>
     @Override
     public Revision fetchLatestRevision() {
         synchronized (lock) {
-            long streamLength = meta.fetchCurrentSegmentLength();
+            long streamLength = meta.fetchCurrentSegmentLength(delegationToken);
             return new RevisionImpl(segment, streamLength, 0);
         }
     }
@@ -148,10 +152,10 @@ public class RevisionedStreamClientImpl<T> implements RevisionedStreamClient<T>
                     data = in.read();
                 } catch (EndOfSegmentException e) {
                     throw new IllegalStateException(
-                            "SegmentInputStream: " + in + " shrunk from its original length: " + endOffset);
-                } catch (SegmentTruncatedException e) {
-                    throw new TruncatedDataException(e);
-                }
+                        "SegmentInputStream: " + in + " shrunk from its original length: " + endOffset);
+            } catch (SegmentTruncatedException e) {
+                throw new TruncatedDataException(e);
+            }
                 offset.set(in.getOffset());
                 revision = new RevisionImpl(segment, offset.get(), 0);
             }
@@ -172,19 +176,19 @@ public class RevisionedStreamClientImpl<T> implements RevisionedStreamClient<T>
         long expectedValue = expected == null ? NULL_VALUE : expected.asImpl().getOffsetInSegment();
         long newValue = newLocation == null ? NULL_VALUE : newLocation.asImpl().getOffsetInSegment();
         synchronized (lock) {
-            return meta.compareAndSetAttribute(RevisionStreamClientMark, expectedValue, newValue);
+            return meta.compareAndSetAttribute(RevisionStreamClientMark, expectedValue, newValue, delegationToken);
         }
     }
 
     @Override
     public Revision fetchOldestRevision() {
-        long startingOffset = meta.getSegmentInfo().getStartingOffset();
+        long startingOffset = meta.getSegmentInfo(delegationToken).getStartingOffset();
         return new RevisionImpl(segment, startingOffset, 0);
     }
-    
+
     @Override
     public void truncateToRevision(Revision newStart) {
-        meta.truncateSegment(newStart.asImpl().getSegment(), newStart.asImpl().getOffsetInSegment());
+        meta.truncateSegment(newStart.asImpl().getSegment(), newStart.asImpl().getOffsetInSegment(), delegationToken);
     }
 
     @Override
diff --git a/client/src/main/java/io/pravega/client/state/impl/StateSynchronizerImpl.java b/client/src/main/java/io/pravega/client/state/impl/StateSynchronizerImpl.java
index a6737d6..9b59d78 100644
--- a/client/src/main/java/io/pravega/client/state/impl/StateSynchronizerImpl.java
+++ b/client/src/main/java/io/pravega/client/state/impl/StateSynchronizerImpl.java
@@ -25,8 +25,8 @@ import java.util.function.Function;
 import javax.annotation.concurrent.GuardedBy;
 import lombok.Synchronized;
 import lombok.ToString;
-import lombok.val;
 import lombok.extern.slf4j.Slf4j;
+import lombok.val;
 
 @Slf4j
 @ToString(of = { "segment", "currentState" })
diff --git a/client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java b/client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java
index 705d115..9271357 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java
@@ -11,6 +11,7 @@ package io.pravega.client.stream.impl;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.batch.BatchClient;
 import io.pravega.client.batch.impl.BatchClientImpl;
@@ -45,11 +46,11 @@ import io.pravega.client.stream.Stream;
 import io.pravega.common.concurrent.ExecutorServiceHelpers;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.shared.NameUtils;
-import lombok.extern.slf4j.Slf4j;
-import lombok.val;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import lombok.val;
 
 @Slf4j
 public class ClientFactoryImpl implements ClientFactory {
@@ -72,7 +73,7 @@ public class ClientFactoryImpl implements ClientFactory {
         Preconditions.checkNotNull(controller);
         this.scope = scope;
         this.controller = controller;
-        this.connectionFactory = new ConnectionFactoryImpl(false);
+        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         this.inFactory = new SegmentInputStreamFactoryImpl(controller, connectionFactory);
         this.outFactory = new SegmentOutputStreamFactoryImpl(controller, connectionFactory);
         this.metaFactory = new SegmentMetadataClientFactoryImpl(controller, connectionFactory);
@@ -88,13 +89,13 @@ public class ClientFactoryImpl implements ClientFactory {
     @VisibleForTesting
     public ClientFactoryImpl(String scope, Controller controller, ConnectionFactory connectionFactory) {
         this(scope, controller, connectionFactory, new SegmentInputStreamFactoryImpl(controller, connectionFactory),
-             new SegmentOutputStreamFactoryImpl(controller, connectionFactory),
-             new SegmentMetadataClientFactoryImpl(controller, connectionFactory));
+                new SegmentOutputStreamFactoryImpl(controller, connectionFactory),
+                new SegmentMetadataClientFactoryImpl(controller, connectionFactory));
     }
 
     @VisibleForTesting
     public ClientFactoryImpl(String scope, Controller controller, ConnectionFactory connectionFactory,
-            SegmentInputStreamFactory inFactory, SegmentOutputStreamFactory outFactory, SegmentMetadataClientFactory metaFactory) {
+                             SegmentInputStreamFactory inFactory, SegmentOutputStreamFactory outFactory, SegmentMetadataClientFactory metaFactory) {
         Preconditions.checkNotNull(scope);
         Preconditions.checkNotNull(controller);
         Preconditions.checkNotNull(inFactory);
@@ -108,6 +109,7 @@ public class ClientFactoryImpl implements ClientFactory {
         this.metaFactory = metaFactory;
     }
 
+
     @Override
     public <T> EventStreamWriter<T> createEventWriter(String streamName, Serializer<T> s, EventWriterConfig config) {
         log.info("Creating writer for stream: {} with configuration: {}", streamName, config);
@@ -149,9 +151,12 @@ public class ClientFactoryImpl implements ClientFactory {
         Consumer<Segment> segmentSealedCallBack = s -> {
             throw new IllegalStateException("RevisionedClient: Segmentsealed exception observed for segment:" + s);
         };
-        SegmentOutputStream out = outFactory.createOutputStreamForSegment(segment, segmentSealedCallBack, config.getEventWriterConfig());
+        String delegationToken = Futures.getAndHandleExceptions(controller.getOrRefreshDelegationTokenFor(segment.getScope(),
+                segment.getStreamName()), RuntimeException::new);
+        SegmentOutputStream out = outFactory.createOutputStreamForSegment(segment, segmentSealedCallBack,
+                config.getEventWriterConfig(), delegationToken);
         SegmentMetadataClient meta = metaFactory.createSegmentMetadataClient(segment);
-        return new RevisionedStreamClientImpl<>(segment, in, out, meta, serializer);
+        return new RevisionedStreamClientImpl<>(segment, in, out, meta, serializer, controller, delegationToken);
     }
 
     @Override
diff --git a/client/src/main/java/io/pravega/client/stream/impl/Controller.java b/client/src/main/java/io/pravega/client/stream/impl/Controller.java
index 42f62f9..605e006 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/Controller.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/Controller.java
@@ -17,10 +17,8 @@ import io.pravega.client.stream.StreamCut;
 import io.pravega.client.stream.Transaction;
 import io.pravega.client.stream.TxnFailedException;
 import io.pravega.shared.protocol.netty.PravegaNodeUri;
-
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
@@ -246,9 +244,9 @@ public interface Controller extends AutoCloseable {
      * Returns all the segments that come after the provided cutpoint. 
      * 
      * @param from The position from which to find the remaining bytes.
-     * @return The total number of bytes beyond the provided positions.
+     * @return The segments beyond a given cut position.
      */
-    CompletableFuture<Set<Segment>> getSuccessors(StreamCut from);
+    CompletableFuture<StreamSegmentSuccessors> getSuccessors(StreamCut from);
 
     // Controller Apis that are called by writers and readers
 
@@ -280,4 +278,11 @@ public interface Controller extends AutoCloseable {
     @Override
     void close();
 
+    /**
+     * Refreshes an expired/non-existent delegation token.
+     * @param scope         Scope of the stream.
+     * @param streamName    Name of the stream.
+     * @return              The delegation token for the given stream.
+     */
+    CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName);
 }
diff --git a/client/src/main/java/io/pravega/client/stream/impl/ControllerImpl.java b/client/src/main/java/io/pravega/client/stream/impl/ControllerImpl.java
index 1abdab7..5c326bd 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/ControllerImpl.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/ControllerImpl.java
@@ -11,13 +11,17 @@ package io.pravega.client.stream.impl;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
-
+import com.google.common.base.Strings;
 import io.grpc.ManagedChannel;
 import io.grpc.ManagedChannelBuilder;
 import io.grpc.StatusRuntimeException;
+import io.grpc.auth.MoreCallCredentials;
+import io.grpc.netty.GrpcSslContexts;
+import io.grpc.netty.NegotiationType;
 import io.grpc.netty.NettyChannelBuilder;
 import io.grpc.stub.StreamObserver;
 import io.grpc.util.RoundRobinLoadBalancerFactory;
+import io.netty.handler.ssl.SslContextBuilder;
 import io.pravega.client.segment.impl.Segment;
 import io.pravega.client.stream.InvalidStreamException;
 import io.pravega.client.stream.PingFailedException;
@@ -57,10 +61,7 @@ import io.pravega.controller.stream.api.grpc.v1.Controller.TxnStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.UpdateStreamStatus;
 import io.pravega.controller.stream.api.grpc.v1.ControllerServiceGrpc;
 import io.pravega.shared.protocol.netty.PravegaNodeUri;
-import lombok.extern.slf4j.Slf4j;
-import lombok.val;
-
-import java.net.URI;
+import java.io.File;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -73,10 +74,14 @@ import java.util.Set;
 import java.util.TreeMap;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.stream.Collectors;
+import javax.net.ssl.SSLException;
+import lombok.extern.slf4j.Slf4j;
+import lombok.val;
 
 import static io.pravega.common.concurrent.Futures.getAndHandleExceptions;
 
@@ -99,37 +104,31 @@ public class ControllerImpl implements Controller {
     // Flag to indicate if the client is closed.
     private final AtomicBoolean closed = new AtomicBoolean(false);
 
-    // The gRPC client for the Controller Service.
-    private final ControllerServiceGrpc.ControllerServiceStub client;
-
     // io.grpc.Channel used by the grpc client for Controller Service.
     private final ManagedChannel channel;
 
+    // The gRPC client for the Controller Service.
+    private final ControllerServiceGrpc.ControllerServiceStub client;
+
     /**
      * Creates a new instance of the Controller client class.
      *
-     * @param controllerURI The controller rpc URI. This can be of 2 types
-     *                      1. tcp://ip1:port1,ip2:port2,...
-     *                          This is used if the controller endpoints are static and can be directly accessed.
-     *                      2. pravega://ip1:port1,ip2:port2,...
-     *                          This is used to autodiscovery the controller endpoints from an initial controller list.
      * @param config        The configuration for this client implementation.
      * @param executor      The executor service to be used for handling retries.
      */
-    public ControllerImpl(final URI controllerURI, final ControllerImplConfig config,
+    public ControllerImpl(final ControllerImplConfig config,
                           final ScheduledExecutorService executor) {
-        this(NettyChannelBuilder.forTarget(controllerURI.toString())
-                .nameResolverFactory(new ControllerResolverFactory())
-                .loadBalancerFactory(RoundRobinLoadBalancerFactory.getInstance())
-                .keepAliveTime(DEFAULT_KEEPALIVE_TIME_MINUTES, TimeUnit.MINUTES)
-                .usePlaintext(true), config, executor);
-        log.info("Controller client connecting to server at {}", controllerURI.getAuthority());
+        this(NettyChannelBuilder.forTarget(config.getClientConfig().getControllerURI().toString())
+                                .nameResolverFactory(new ControllerResolverFactory())
+                                .loadBalancerFactory(RoundRobinLoadBalancerFactory.getInstance())
+                                .keepAliveTime(DEFAULT_KEEPALIVE_TIME_MINUTES, TimeUnit.MINUTES),
+                config, executor);
+        log.info("Controller client connecting to server at {}", config.getClientConfig().getControllerURI().getAuthority());
     }
 
     /**
      * Creates a new instance of the Controller client class.
-     *
-     * @param channelBuilder The channel builder to connect to the service instance.
+     *  @param channelBuilder The channel builder to connect to the service instance.
      * @param config         The configuration for this client implementation.
      * @param executor       The executor service to be used internally.
      */
@@ -140,12 +139,34 @@ public class ControllerImpl implements Controller {
         this.executor = executor;
         this.retryConfig = Retry.withExpBackoff(config.getInitialBackoffMillis(), config.getBackoffMultiple(),
                 config.getRetryAttempts(), config.getMaxBackoffMillis())
-                .retryingOn(StatusRuntimeException.class)
-                .throwingOn(Exception.class);
-
+                                .retryingOn(StatusRuntimeException.class)
+                                .throwingOn(Exception.class);
+
+        if (config.getClientConfig().isEnableTls()) {
+            SslContextBuilder sslContextBuilder = null;
+            String trustStore = config.getClientConfig().getTrustStore();
+            sslContextBuilder = GrpcSslContexts.forClient();
+            if (!Strings.isNullOrEmpty(trustStore)) {
+                sslContextBuilder = sslContextBuilder.trustManager(new File(trustStore));
+            }
+            try {
+                channelBuilder = ((NettyChannelBuilder) channelBuilder).sslContext(sslContextBuilder.build())
+                                                                       .negotiationType(NegotiationType.TLS);
+            } catch (SSLException e) {
+                throw new CompletionException(e);
+            }
+        } else {
+            channelBuilder = ((NettyChannelBuilder) channelBuilder).negotiationType(NegotiationType.PLAINTEXT);
+        }
         // Create Async RPC client.
         this.channel = channelBuilder.build();
-        this.client = ControllerServiceGrpc.newStub(this.channel);
+        ControllerServiceGrpc.ControllerServiceStub client = ControllerServiceGrpc.newStub(this.channel);
+        Credentials credentials = config.getClientConfig().getCredentials();
+        if (credentials != null) {
+            PravegaCredsWrapper wrapper = new PravegaCredsWrapper(credentials);
+            client = client.withCallCredentials(MoreCallCredentials.from(wrapper));
+        }
+        this.client = client;
     }
 
     @Override
@@ -591,7 +612,7 @@ public class ControllerImpl implements Controller {
             for (SuccessorResponse.SegmentEntry entry : successors.getSegmentsList()) {
                 result.put(ModelHelper.encode(entry.getSegment()), entry.getValueList());
             }
-            return new StreamSegmentsWithPredecessors(result);
+            return new StreamSegmentsWithPredecessors(result, successors.getDelegationToken());
         }).whenComplete((x, e) -> {
             if (e != null) {
                 log.warn("getSuccessors failed: ", e);
@@ -599,15 +620,17 @@ public class ControllerImpl implements Controller {
             LoggerHelpers.traceLeave(log, "getSuccessors", traceId);
         });
     }
-    
+
     @Override
-    public CompletableFuture<Set<Segment>> getSuccessors(StreamCut from) {
+    public CompletableFuture<StreamSegmentSuccessors> getSuccessors(StreamCut from) {
         Exceptions.checkNotClosed(closed.get(), this);
         Stream stream = from.asImpl().getStream();
         long traceId = LoggerHelpers.traceEnter(log, "getSuccessorsFromCut", stream);
         HashSet<Segment> unread = new HashSet<>(from.asImpl().getPositions().keySet());
         val currentSegments = getAndHandleExceptions(getCurrentSegments(stream.getScope(), stream.getStreamName()),
-                                                     RuntimeException::new);
+                RuntimeException::new);
+
+        String delegationToken = currentSegments.getDelegationToken();
         unread.addAll(computeKnownUnreadSegments(currentSegments, from));
         ArrayDeque<Segment> toFetchSuccessors = new ArrayDeque<>();
         for (Segment toFetch : from.asImpl().getPositions().keySet()) {
@@ -628,7 +651,7 @@ public class ControllerImpl implements Controller {
             }
         }
         LoggerHelpers.traceLeave(log, "getSuccessorsFromCut", traceId);
-        return CompletableFuture.completedFuture(unread);
+        return CompletableFuture.completedFuture(new StreamSegmentSuccessors(unread, delegationToken));
     }
 
     private List<Segment> computeKnownUnreadSegments(StreamSegments currentSegments, StreamCut from) {
@@ -657,19 +680,18 @@ public class ControllerImpl implements Controller {
             return callback.getFuture();
         }, this.executor);
         return result.thenApply(ranges -> {
-                    log.debug("Received the following data from the controller {}", ranges.getSegmentRangesList());
-                    NavigableMap<Double, Segment> rangeMap = new TreeMap<>();
-                    for (SegmentRange r : ranges.getSegmentRangesList()) {
-                        rangeMap.put(r.getMaxKey(), ModelHelper.encode(r.getSegmentId()));
-                    }
-                    return rangeMap;
-                }).thenApply(StreamSegments::new)
-                .whenComplete((x, e) -> {
-                    if (e != null) {
-                        log.warn("getCurrentSegments failed: ", e);
-                    }
-                    LoggerHelpers.traceLeave(log, "getCurrentSegments", traceId);
-                });
+            log.debug("Received the following data from the controller {}", ranges.getSegmentRangesList());
+            NavigableMap<Double, Segment> rangeMap = new TreeMap<>();
+            for (SegmentRange r : ranges.getSegmentRangesList()) {
+                rangeMap.put(r.getMaxKey(), ModelHelper.encode(r.getSegmentId()));
+            }
+            return new StreamSegments(rangeMap, ranges.getDelegationToken());
+        }).whenComplete((x, e) -> {
+                         if (e != null) {
+                             log.warn("getCurrentSegments failed: ", e);
+                         }
+                         LoggerHelpers.traceLeave(log, "getCurrentSegments", traceId);
+                     });
     }
 
     @Override
@@ -750,7 +772,7 @@ public class ControllerImpl implements Controller {
         for (SegmentRange r : response.getActiveSegmentsList()) {
             rangeMap.put(r.getMaxKey(), ModelHelper.encode(r.getSegmentId()));
         }
-        StreamSegments segments = new StreamSegments(rangeMap);
+        StreamSegments segments = new StreamSegments(rangeMap, response.getDelegationToken());
         return new TxnSegments(segments, ModelHelper.encode(response.getTxnId()));
     }
 
@@ -866,6 +888,28 @@ public class ControllerImpl implements Controller {
         }
     }
 
+    @Override
+    public CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName) {
+        Exceptions.checkNotClosed(closed.get(), this);
+        Exceptions.checkNotNullOrEmpty(scope, "scope");
+        Exceptions.checkNotNullOrEmpty(streamName, "stream");
+        long traceId = LoggerHelpers.traceEnter(log, "getOrRefreshDelegationTokenFor", scope, streamName);
+
+        final CompletableFuture<io.pravega.controller.stream.api.grpc.v1.Controller.DelegationToken> result = this.retryConfig.runAsync(() -> {
+            RPCAsyncCallback<io.pravega.controller.stream.api.grpc.v1.Controller.DelegationToken> callback = new RPCAsyncCallback<>();
+            client.getDelegationToken(ModelHelper.createStreamInfo(scope, streamName), callback);
+            return callback.getFuture();
+        }, this.executor);
+
+        return result.thenApply( token -> token.getDelegationToken())
+        .whenComplete((x, e) -> {
+            if (e != null) {
+                log.warn("getCurrentSegments failed: ", e);
+            }
+            LoggerHelpers.traceLeave(log, "getCurrentSegments", traceId);
+        });
+    }
+
     // Local callback definition to wrap gRPC responses in CompletableFutures used by the rest of our code.
     private static final class RPCAsyncCallback<T> implements StreamObserver<T> {
         private T result = null;
diff --git a/client/src/main/java/io/pravega/client/stream/impl/ControllerImplConfig.java b/client/src/main/java/io/pravega/client/stream/impl/ControllerImplConfig.java
index 85593aa..d145683 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/ControllerImplConfig.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/ControllerImplConfig.java
@@ -9,8 +9,8 @@
  */
 package io.pravega.client.stream.impl;
 
+import io.pravega.client.ClientConfig;
 import java.io.Serializable;
-
 import lombok.Builder;
 import lombok.Data;
 
@@ -22,11 +22,14 @@ public class ControllerImplConfig implements Serializable {
     private final int maxBackoffMillis;
     private final int retryAttempts;
     private final int backoffMultiple;
+    private final ClientConfig clientConfig;
 
     public static final class ControllerImplConfigBuilder {
         private int initialBackoffMillis = 1;
         private int maxBackoffMillis = 20000;
         private int retryAttempts = 10;
         private int backoffMultiple = 10;
+        private ClientConfig config = ClientConfig.builder().controllerURI(null)
+                                                  .credentials(null).trustStore("").build();
     }
-}
+}
\ No newline at end of file
diff --git a/client/src/main/java/io/pravega/client/stream/impl/ControllerResolverFactory.java b/client/src/main/java/io/pravega/client/stream/impl/ControllerResolverFactory.java
index 98f72d3..ad24d09 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/ControllerResolverFactory.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/ControllerResolverFactory.java
@@ -48,17 +48,23 @@ public class ControllerResolverFactory extends NameResolver.Factory {
     // Use this scheme when client want to connect to a static set of controller servers.
     // Eg: tcp://ip1:port1,ip2:port2
     private final static String SCHEME_DIRECT = "tcp";
+    //Secure versions of the direct scheme.
+    private final static String SCHEME_DIRECT_TLS = "tls";
+    private final static String SCHEME_DIRECT_SSL = "ssl";
 
     // Use this scheme when client only knows a subset of controllers and wants other controller instances to be
     // auto discovered.
     // Eg: pravega://ip1:port1,ip2:port2
     private final static String SCHEME_DISCOVER = "pravega";
+    //Secure version of discover scheme.
+    private final static String SCHEME_DISCOVER_TLS = "pravegas";
 
     @Nullable
     @Override
     public NameResolver newNameResolver(URI targetUri, Attributes params) {
         final String scheme = targetUri.getScheme();
-        if (!SCHEME_DISCOVER.equals(scheme) && !SCHEME_DIRECT.equals(scheme)) {
+        if (!SCHEME_DISCOVER.equals(scheme) && !SCHEME_DISCOVER_TLS.equals(scheme) &&
+                !SCHEME_DIRECT.equals(scheme) && !SCHEME_DIRECT_SSL.equals(scheme) && !SCHEME_DIRECT_TLS.equals(scheme)) {
             return null;
         }
 
@@ -69,7 +75,7 @@ public class ControllerResolverFactory extends NameResolver.Factory {
             return InetSocketAddress.createUnresolved(strings[0], Integer.valueOf(strings[1]));
         }).collect(Collectors.toList());
 
-        return new ControllerNameResolver(authority, addresses, SCHEME_DISCOVER.equals(scheme));
+        return new ControllerNameResolver(authority, addresses, SCHEME_DISCOVER.equals(scheme) || SCHEME_DISCOVER_TLS.equals(scheme));
     }
 
     @Override
diff --git a/client/src/main/java/io/pravega/client/stream/impl/Credentials.java b/client/src/main/java/io/pravega/client/stream/impl/Credentials.java
new file mode 100644
index 0000000..db0f971
--- /dev/null
+++ b/client/src/main/java/io/pravega/client/stream/impl/Credentials.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.client.stream.impl;
+
+import java.util.Map;
+
+/**
+ * This interface represents the credentials passed to Pravega for authentication and authorizing the access.
+ */
+public interface Credentials {
+    /**
+     * Returns the authentication type.
+     * Pravega can support multiple authentication types in a single deployment.
+     *
+     * @return the authentication type expected by the these credentials.
+     */
+    String getAuthenticationType();
+
+    /**
+     * Returns authorization parameters used by this specific authentication type.
+     * @return The map of authentication headers and values.
+     */
+    Map<String, String> getAuthParameters();
+}
diff --git a/client/src/main/java/io/pravega/client/stream/impl/DefaultCredentials.java b/client/src/main/java/io/pravega/client/stream/impl/DefaultCredentials.java
new file mode 100644
index 0000000..6e00e10
--- /dev/null
+++ b/client/src/main/java/io/pravega/client/stream/impl/DefaultCredentials.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.client.stream.impl;
+
+import com.google.common.collect.ImmutableMap;
+import java.util.Map;
+
+public class DefaultCredentials implements Credentials {
+    private final ImmutableMap<String, String> credsMap;
+
+    public DefaultCredentials(String password, String userName) {
+        credsMap = ImmutableMap.of("userName", userName,
+                "password", password);
+    }
+
+    @Override
+    public String getAuthenticationType() {
+        return "Pravega-Default";
+    }
+
+    @Override
+    public Map<String, String> getAuthParameters() {
+        return credsMap;
+    }
+}
diff --git a/client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java b/client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java
index 4026167..ee59a46 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java
@@ -222,7 +222,7 @@ public class EventStreamReaderImpl<Type> implements EventStreamReader<Type> {
         @Cleanup
         SegmentMetadataClient metadataClient = metadataClientFactory.createSegmentMetadataClient(segmentId);
         try {
-            long startingOffset = metadataClient.getSegmentInfo().getStartingOffset();
+            long startingOffset = metadataClient.getSegmentInfo(groupState.getLatestDelegationToken()).getStartingOffset();
             segmentReader.setOffset(startingOffset);
         } catch (NoSuchSegmentException e) {
             handleEndOfSegment(segmentReader);
diff --git a/client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java b/client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java
index 962a110..6d05e59 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/EventStreamWriterImpl.java
@@ -308,7 +308,8 @@ public class EventStreamWriterImpl<Type> implements EventStreamWriter<Type> {
         UUID txnId = txnSegments.getTxnId();
         Map<Segment, SegmentTransaction<Type>> transactions = new HashMap<>();
         for (Segment s : txnSegments.getSteamSegments().getSegments()) {
-            SegmentOutputStream out = outputStreamFactory.createOutputStreamForTransaction(s, txnId, segmentSealedCallBack, config);
+            SegmentOutputStream out = outputStreamFactory.createOutputStreamForTransaction(s, txnId,
+                    segmentSealedCallBack, config, txnSegments.getSteamSegments().getDelegationToken());
             SegmentTransactionImpl<Type> impl = new SegmentTransactionImpl<>(txnId, out, serializer);
             transactions.put(s, impl);
         }
@@ -327,7 +328,7 @@ public class EventStreamWriterImpl<Type> implements EventStreamWriter<Type> {
         
         Map<Segment, SegmentTransaction<Type>> transactions = new HashMap<>();
         for (Segment s : segments.getSegments()) {
-            SegmentOutputStream out = outputStreamFactory.createOutputStreamForTransaction(s, txId, segmentSealedCallBack, config);
+            SegmentOutputStream out = outputStreamFactory.createOutputStreamForTransaction(s, txId, segmentSealedCallBack, config, segments.getDelegationToken());
             SegmentTransactionImpl<Type> impl = new SegmentTransactionImpl<>(txId, out, serializer);
             transactions.put(s, impl);
         }
diff --git a/client/src/main/java/io/pravega/client/stream/impl/ModelHelper.java b/client/src/main/java/io/pravega/client/stream/impl/ModelHelper.java
index 194fa12..746d774 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/ModelHelper.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/ModelHelper.java
@@ -339,7 +339,7 @@ public final class ModelHelper {
                 .build();
     }
 
-    public static final SuccessorResponse createSuccessorResponse(Map<SegmentRange, List<Integer>> segments) {
+    public static final SuccessorResponse.Builder createSuccessorResponse(Map<SegmentRange, List<Integer>> segments) {
         Preconditions.checkNotNull(segments);
         return SuccessorResponse.newBuilder()
                 .addAllSegments(
@@ -348,7 +348,6 @@ public final class ModelHelper {
                                         .setSegment(segmentRangeListEntry.getKey())
                                         .addAllValue(segmentRangeListEntry.getValue())
                                         .build())
-                                .collect(Collectors.toList()))
-                .build();
+                                .collect(Collectors.toList()));
     }
 }
diff --git a/client/src/main/java/io/pravega/client/stream/impl/PravegaCredsWrapper.java b/client/src/main/java/io/pravega/client/stream/impl/PravegaCredsWrapper.java
new file mode 100644
index 0000000..99bd72b
--- /dev/null
+++ b/client/src/main/java/io/pravega/client/stream/impl/PravegaCredsWrapper.java
@@ -0,0 +1,58 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.client.stream.impl;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+public class PravegaCredsWrapper extends com.google.auth.Credentials {
+    private final Credentials creds;
+
+    public PravegaCredsWrapper(Credentials creds) {
+        this.creds = creds;
+    }
+
+    @Override
+    public String getAuthenticationType() {
+        return creds.getAuthenticationType();
+    }
+
+    @Override
+    public Map<String, List<String>> getRequestMetadata(URI uri) throws IOException {
+        Map<String, String> metadata = creds.getAuthParameters();
+
+        Map<String, List<String>> retVal = metadata.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey,
+                e -> {
+                    List<String> list = Collections.singletonList(e.getValue());
+                    return list;
+                }));
+        retVal.put("method", Collections.singletonList(creds.getAuthenticationType()));
+        return retVal;
+    }
+
+    @Override
+    public boolean hasRequestMetadata() {
+        return true;
+    }
+
+    @Override
+    public boolean hasRequestMetadataOnly() {
+        return true;
+    }
+
+    @Override
+    public void refresh() throws IOException {
+        // All the Pravega credentials are purely map based. They are not supposed to be refreshed through this flow.
+    }
+}
diff --git a/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java b/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java
index 40091ba..25bc63a 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java
@@ -217,11 +217,12 @@ public class ReaderGroupImpl implements ReaderGroup, ReaderGroupMetrics {
 
     private long getRemainingBytes(SegmentMetadataClientFactory metaFactory, StreamCut position) {
         long totalLength = 0;
-        CompletableFuture<Set<Segment>> unread = controller.getSuccessors(position);
-        for (Segment s : Futures.getAndHandleExceptions(unread, RuntimeException::new)) {
+        CompletableFuture<StreamSegmentSuccessors> unread = controller.getSuccessors(position);
+        StreamSegmentSuccessors unreadVal = Futures.getAndHandleExceptions(unread, RuntimeException::new);
+        for (Segment s : unreadVal.getSegments()) {
             @Cleanup
             SegmentMetadataClient metadataClient = metaFactory.createSegmentMetadataClient(s);
-            totalLength += metadataClient.fetchCurrentSegmentLength();
+            totalLength += metadataClient.fetchCurrentSegmentLength(unreadVal.getDelegationToken());
         }
         for (long bytesRead : position.asImpl().getPositions().values()) {
             totalLength -= bytesRead;
diff --git a/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java b/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java
index 858b630..d119f8b 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java
@@ -40,6 +40,7 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Supplier;
+import javax.annotation.concurrent.GuardedBy;
 import lombok.Getter;
 import lombok.val;
 import org.apache.commons.lang3.RandomUtils;
@@ -81,6 +82,9 @@ public class ReaderGroupStateManager {
     private final TimeoutTimer acquireTimer;
     private final TimeoutTimer fetchStateTimer;
     private final TimeoutTimer checkpointTimer;
+    @Getter
+    @GuardedBy("this")
+    private String latestDelegationToken;
 
     ReaderGroupStateManager(String readerId, StateSynchronizer<ReaderGroupState> sync, Controller controller, Supplier<Long> nanoClock) {
         Preconditions.checkNotNull(readerId);
@@ -161,6 +165,9 @@ public class ReaderGroupStateManager {
      */
     void handleEndOfSegment(Segment segmentCompleted) throws ReinitializationRequiredException {
         val successors = getAndHandleExceptions(controller.getSuccessors(segmentCompleted), RuntimeException::new);
+        synchronized (this) {
+            latestDelegationToken = successors.getDelegationToken();
+        }
         AtomicBoolean reinitRequired = new AtomicBoolean(false);
         sync.updateState(state -> {
             if (!state.isReaderOnline(readerId)) {
diff --git a/client/src/main/java/io/pravega/client/stream/impl/SegmentSelector.java b/client/src/main/java/io/pravega/client/stream/impl/SegmentSelector.java
index 83a2921..80b2b4e 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/SegmentSelector.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/SegmentSelector.java
@@ -104,7 +104,7 @@ public class SegmentSelector {
     private List<PendingEvent> updateSegments(StreamSegments newSteamSegments, Consumer<Segment>
             segmentSealedCallBack) {
         currentSegments = newSteamSegments;
-        createMissingWriters(segmentSealedCallBack);
+        createMissingWriters(segmentSealedCallBack, newSteamSegments.getDelegationToken());
         List<PendingEvent> toResend = new ArrayList<>();
         Iterator<Entry<Segment, SegmentOutputStream>> iter = writers.entrySet().iterator();
         while (iter.hasNext()) {
@@ -127,17 +127,17 @@ public class SegmentSelector {
     private List<PendingEvent> updateSegmentsUponSealed(StreamSegments newStreamSegments, Segment sealedSegment,
                                                         Consumer<Segment> segmentSealedCallback) {
         currentSegments = newStreamSegments;
-        createMissingWriters(segmentSealedCallback);
+        createMissingWriters(segmentSealedCallback, newStreamSegments.getDelegationToken());
         log.trace("Fetch unacked events for segment :{}", sealedSegment);
         List<PendingEvent> toResend = writers.get(sealedSegment).getUnackedEventsOnSeal();
         writers.remove(sealedSegment); //remove this sealed segment writer.
         return toResend;
     }
 
-    private void createMissingWriters(Consumer<Segment> segmentSealedCallBack) {
+    private void createMissingWriters(Consumer<Segment> segmentSealedCallBack, String delegationToken) {
         for (Segment segment : currentSegments.getSegments()) {
             if (!writers.containsKey(segment)) {
-                SegmentOutputStream out = outputStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallBack, config);
+                SegmentOutputStream out = outputStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallBack, config, delegationToken);
                 writers.put(segment, out);
             }
         }
diff --git a/client/src/main/java/io/pravega/client/stream/impl/StreamSegmentSuccessors.java b/client/src/main/java/io/pravega/client/stream/impl/StreamSegmentSuccessors.java
new file mode 100644
index 0000000..a8b8c90
--- /dev/null
+++ b/client/src/main/java/io/pravega/client/stream/impl/StreamSegmentSuccessors.java
@@ -0,0 +1,23 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.client.stream.impl;
+
+import io.pravega.client.segment.impl.Segment;
+import java.util.Set;
+import lombok.Data;
+
+/**
+ * Successor segments of a given segment.
+ */
+@Data
+public class StreamSegmentSuccessors {
+    private final Set<Segment> segments;
+    private final String delegationToken;
+}
diff --git a/client/src/main/java/io/pravega/client/stream/impl/StreamSegments.java b/client/src/main/java/io/pravega/client/stream/impl/StreamSegments.java
index d3a9c0a..8ca2521 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/StreamSegments.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/StreamSegments.java
@@ -20,6 +20,7 @@ import java.util.Map.Entry;
 import java.util.NavigableMap;
 import java.util.TreeMap;
 import lombok.EqualsAndHashCode;
+import lombok.Getter;
 
 /**
  * The segments that within a stream at a particular point in time.
@@ -28,15 +29,19 @@ import lombok.EqualsAndHashCode;
 public class StreamSegments {
     private static final HashHelper HASHER = HashHelper.seededWith("EventRouter");
     private final NavigableMap<Double, Segment> segments;
+    @Getter
+    private final String delegationToken;
 
     /**
      * Creates a new instance of the StreamSegments class.
      *
      * @param segments Segments of a stream, keyed by the largest key in their key range.
      *                 i.e. If there are two segments split evenly, the first should have a value of 0.5 and the second 1.0.
+     * @param delegationToken Delegation token to access the segments in the segmentstore
      */
-    public StreamSegments(NavigableMap<Double, Segment> segments) {
+    public StreamSegments(NavigableMap<Double, Segment> segments, String delegationToken) {
         this.segments = Collections.unmodifiableNavigableMap(segments);
+        this.delegationToken = delegationToken;
         verifySegments();
     }
 
@@ -75,6 +80,6 @@ public class StreamSegments {
                 }
             }
         }
-        return new StreamSegments(result);
+        return new StreamSegments(result, delegationToken);
     }
 }
\ No newline at end of file
diff --git a/client/src/main/java/io/pravega/client/stream/impl/StreamSegmentsWithPredecessors.java b/client/src/main/java/io/pravega/client/stream/impl/StreamSegmentsWithPredecessors.java
index ee8ad38..353a54e 100644
--- a/client/src/main/java/io/pravega/client/stream/impl/StreamSegmentsWithPredecessors.java
+++ b/client/src/main/java/io/pravega/client/stream/impl/StreamSegmentsWithPredecessors.java
@@ -18,6 +18,7 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.stream.Collectors;
 import lombok.EqualsAndHashCode;
+import lombok.Getter;
 
 /**
  * The successor segments of a given segment.
@@ -26,8 +27,10 @@ import lombok.EqualsAndHashCode;
 public class StreamSegmentsWithPredecessors {
     private final Map<Segment, List<Integer>> segmentWithPredecessors;
     private final Map<Integer, List<SegmentWithRange>> replacementRanges;
+    @Getter
+    private final String delegationToken;
 
-    public StreamSegmentsWithPredecessors(final Map<SegmentWithRange, List<Integer>> segments) {
+    public StreamSegmentsWithPredecessors(final Map<SegmentWithRange, List<Integer>> segments, String delegationToken) {
         segmentWithPredecessors = Collections.unmodifiableMap(segments.entrySet().stream().collect(
                 Collectors.toMap(entry -> entry.getKey().getSegment(), Map.Entry::getValue)));
 
@@ -43,6 +46,7 @@ public class StreamSegmentsWithPredecessors {
             }
         }
         this.replacementRanges = Collections.unmodifiableMap(replacementRanges);
+        this.delegationToken = delegationToken;
     }
 
     /**
diff --git a/client/src/test/java/io/pravega/client/ClientConfigTest.java b/client/src/test/java/io/pravega/client/ClientConfigTest.java
new file mode 100644
index 0000000..61d26e9
--- /dev/null
+++ b/client/src/test/java/io/pravega/client/ClientConfigTest.java
@@ -0,0 +1,19 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.client;
+
+import org.junit.Test;
+
+public class ClientConfigTest {
+
+    @Test
+    public void isEnableTls() {
+    }
+}
\ No newline at end of file
diff --git a/client/src/test/java/io/pravega/client/batch/impl/SegmentIteratorTest.java b/client/src/test/java/io/pravega/client/batch/impl/SegmentIteratorTest.java
index cfc8f79..379d2dc 100644
--- a/client/src/test/java/io/pravega/client/batch/impl/SegmentIteratorTest.java
+++ b/client/src/test/java/io/pravega/client/batch/impl/SegmentIteratorTest.java
@@ -37,12 +37,12 @@ public class SegmentIteratorTest {
         MockSegmentStreamFactory factory = new MockSegmentStreamFactory();
         Segment segment = new Segment("Scope", "Stream", 1);
         EventWriterConfig config = EventWriterConfig.builder().build();
-        SegmentOutputStream outputStream = factory.createOutputStreamForSegment(segment, c -> { }, config);
+        SegmentOutputStream outputStream = factory.createOutputStreamForSegment(segment, c -> { }, config, "");
         sendData("1", outputStream);
         sendData("2", outputStream);
         sendData("3", outputStream);
         SegmentMetadataClient metadataClient = factory.createSegmentMetadataClient(segment);
-        long length = metadataClient.getSegmentInfo().getWriteOffset();
+        long length = metadataClient.getSegmentInfo("").getWriteOffset();
         @Cleanup
         SegmentIteratorImpl<String> iter = new SegmentIteratorImpl<>(factory, segment, stringSerializer, 0, length);
         assertTrue(iter.hasNext());
@@ -61,12 +61,12 @@ public class SegmentIteratorTest {
         MockSegmentStreamFactory factory = new MockSegmentStreamFactory();
         Segment segment = new Segment("Scope", "Stream", 1);
         EventWriterConfig config = EventWriterConfig.builder().build();
-        SegmentOutputStream outputStream = factory.createOutputStreamForSegment(segment, c -> { }, config);
+        SegmentOutputStream outputStream = factory.createOutputStreamForSegment(segment, c -> { }, config, "");
         sendData("1", outputStream);
         sendData("2", outputStream);
         sendData("3", outputStream);
         SegmentMetadataClient metadataClient = factory.createSegmentMetadataClient(segment);
-        long length = metadataClient.getSegmentInfo().getWriteOffset();
+        long length = metadataClient.getSegmentInfo("").getWriteOffset();
         @Cleanup
         SegmentIteratorImpl<String> iter = new SegmentIteratorImpl<>(factory, segment, stringSerializer, 0, length);
         assertEquals(0, iter.getOffset());
@@ -88,18 +88,18 @@ public class SegmentIteratorTest {
         MockSegmentStreamFactory factory = new MockSegmentStreamFactory();
         Segment segment = new Segment("Scope", "Stream", 1);
         EventWriterConfig config = EventWriterConfig.builder().build();
-        SegmentOutputStream outputStream = factory.createOutputStreamForSegment(segment, c -> { }, config);
+        SegmentOutputStream outputStream = factory.createOutputStreamForSegment(segment, c -> { }, config, "");
         sendData("1", outputStream);
         sendData("2", outputStream);
         sendData("3", outputStream);
         SegmentMetadataClient metadataClient = factory.createSegmentMetadataClient(segment);
-        long length = metadataClient.getSegmentInfo().getWriteOffset();
+        long length = metadataClient.getSegmentInfo("").getWriteOffset();
         @Cleanup
         SegmentIteratorImpl<String> iter = new SegmentIteratorImpl<>(factory, segment, stringSerializer, 0, length);
         assertEquals("1", iter.next());
-        long segmentLength = metadataClient.fetchCurrentSegmentLength();
+        long segmentLength = metadataClient.fetchCurrentSegmentLength("");
         assertEquals(0, segmentLength % 3);
-        metadataClient.truncateSegment(segment, segmentLength * 2 / 3);
+        metadataClient.truncateSegment(segment, segmentLength * 2 / 3, "");
         AssertExtensions.assertThrows(TruncatedDataException.class, () -> iter.next());
         @Cleanup
         SegmentIteratorImpl<String> iter2 = new SegmentIteratorImpl<>(factory, segment, stringSerializer,
@@ -108,7 +108,7 @@ public class SegmentIteratorTest {
         assertEquals("3", iter2.next());
         assertFalse(iter.hasNext());
     }
-    
+
     private void sendData(String data, SegmentOutputStream outputStream) {
         outputStream.write(new PendingEvent("routingKey", stringSerializer.serialize(data), new CompletableFuture<>()));
     }
diff --git a/client/src/test/java/io/pravega/client/netty/impl/ConnectionFactoryImplTest.java b/client/src/test/java/io/pravega/client/netty/impl/ConnectionFactoryImplTest.java
new file mode 100644
index 0000000..71ec475
--- /dev/null
+++ b/client/src/test/java/io/pravega/client/netty/impl/ConnectionFactoryImplTest.java
@@ -0,0 +1,130 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.client.netty.impl;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.epoll.EpollEventLoopGroup;
+import io.netty.channel.epoll.EpollServerSocketChannel;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
+import io.netty.handler.ssl.SslHandler;
+import io.pravega.client.ClientConfig;
+import io.pravega.shared.protocol.netty.ConnectionFailedException;
+import io.pravega.shared.protocol.netty.FailingReplyProcessor;
+import io.pravega.shared.protocol.netty.PravegaNodeUri;
+import io.pravega.shared.protocol.netty.WireCommands;
+import io.pravega.test.common.TestUtils;
+import java.io.File;
+import java.net.URI;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLParameters;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class ConnectionFactoryImplTest {
+
+    boolean ssl = false;
+    private Channel serverChannel;
+    private int port;
+
+    @Before
+    public void setUp() throws Exception {
+        // Configure SSL.
+        port = TestUtils.getAvailableListenPort();
+        final SslContext sslCtx;
+        if (ssl) {
+            try {
+                sslCtx = SslContextBuilder.forServer(new File("../config/cert.pem"), new File("../config/key.pem")).build();
+            } catch (SSLException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            sslCtx = null;
+        }
+        boolean nio = false;
+        EventLoopGroup bossGroup;
+        EventLoopGroup workerGroup;
+        try {
+            bossGroup = new EpollEventLoopGroup(1);
+            workerGroup = new EpollEventLoopGroup();
+        } catch (ExceptionInInitializerError | UnsatisfiedLinkError | NoClassDefFoundError e) {
+            nio = true;
+            bossGroup = new NioEventLoopGroup(1);
+            workerGroup = new NioEventLoopGroup();
+        }
+
+        ServerBootstrap b = new ServerBootstrap();
+        b.group(bossGroup, workerGroup)
+         .channel(nio ? NioServerSocketChannel.class : EpollServerSocketChannel.class)
+         .option(ChannelOption.SO_BACKLOG, 100)
+         .handler(new LoggingHandler(LogLevel.INFO))
+         .childHandler(new ChannelInitializer<SocketChannel>() {
+             @Override
+             public void initChannel(SocketChannel ch) throws Exception {
+                 ChannelPipeline p = ch.pipeline();
+                 if (sslCtx != null) {
+                     SslHandler handler = sslCtx.newHandler(ch.alloc());
+                     SSLEngine sslEngine = handler.engine();
+                     SSLParameters sslParameters = sslEngine.getSSLParameters();
+                     sslParameters.setEndpointIdentificationAlgorithm("LDAPS");
+                     sslEngine.setSSLParameters(sslParameters);
+                     p.addLast(handler);
+                 }
+             }
+         });
+
+        // Start the server.
+        serverChannel = b.bind("localhost", port).awaitUninterruptibly().channel();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        serverChannel.close();
+        serverChannel.closeFuture();
+    }
+
+    @Test
+    public void establishConnection() throws ConnectionFailedException {
+        ConnectionFactoryImpl factory = new ConnectionFactoryImpl(ClientConfig.builder()
+                                                                              .controllerURI(URI.create((this.ssl ? "tls://" : "tcp://") + "localhost"))
+                                                                              .trustStore("../config/cert.pem")
+                                                                              .build());
+        ClientConnection connection = factory.establishConnection(new PravegaNodeUri("localhost", port), new FailingReplyProcessor() {
+            @Override
+            public void connectionDropped() {
+
+            }
+
+            @Override
+            public void processingFailure(Exception error) {
+
+            }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+
+            }
+        }).join();
+
+        connection.send(new WireCommands.Hello(0, 0));
+    }
+}
\ No newline at end of file
diff --git a/client/src/test/java/io/pravega/client/netty/impl/SecureConnectionFactoryImplTest.java b/client/src/test/java/io/pravega/client/netty/impl/SecureConnectionFactoryImplTest.java
new file mode 100644
index 0000000..3974295
--- /dev/null
+++ b/client/src/test/java/io/pravega/client/netty/impl/SecureConnectionFactoryImplTest.java
@@ -0,0 +1,22 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.client.netty.impl;
+
+import org.junit.Before;
+
+public class SecureConnectionFactoryImplTest extends ConnectionFactoryImplTest {
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        this.ssl = true;
+        super.setUp();
+    }
+}
diff --git a/client/src/test/java/io/pravega/client/segment/impl/AsyncSegmentInputStreamTest.java b/client/src/test/java/io/pravega/client/segment/impl/AsyncSegmentInputStreamTest.java
index 71901d7..0470e36 100644
--- a/client/src/test/java/io/pravega/client/segment/impl/AsyncSegmentInputStreamTest.java
+++ b/client/src/test/java/io/pravega/client/segment/impl/AsyncSegmentInputStreamTest.java
@@ -49,7 +49,7 @@ public class AsyncSegmentInputStreamTest {
         MockConnectionFactoryImpl connectionFactory = new MockConnectionFactoryImpl();
         MockController controller = new MockController(endpoint.getEndpoint(), endpoint.getPort(), connectionFactory);
         @Cleanup
-        AsyncSegmentInputStreamImpl in = new AsyncSegmentInputStreamImpl(controller, connectionFactory, segment);
+        AsyncSegmentInputStreamImpl in = new AsyncSegmentInputStreamImpl(controller, connectionFactory, segment, "");
         ClientConnection c = mock(ClientConnection.class);
         InOrder inOrder = Mockito.inOrder(c);
         connectionFactory.provideConnection(endpoint, c);
@@ -62,6 +62,12 @@ public class AsyncSegmentInputStreamTest {
                 return null;            
             }
         }).doAnswer(new Answer<Void>() {
+        @Override
+        public Void answer(InvocationOnMock invocation) throws Throwable {
+            connectionFactory.getProcessor(endpoint).authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(100));
+            return null;
+        }
+        }).doAnswer(new Answer<Void>() {
             @Override
             public Void answer(InvocationOnMock invocation) throws Throwable {
                 connectionFactory.getProcessor(endpoint).segmentRead(segmentRead);
@@ -72,9 +78,11 @@ public class AsyncSegmentInputStreamTest {
         CompletableFuture<SegmentRead> readFuture = in.read(1234, 5678);
         assertEquals(segmentRead, readFuture.join());
         assertTrue(Futures.isSuccessful(readFuture));
-        inOrder.verify(c).sendAsync(new WireCommands.ReadSegment(segment.getScopedName(), 1234, 5678));
+        inOrder.verify(c).sendAsync(new WireCommands.ReadSegment(segment.getScopedName(), 1234,  5678, ""));
+        inOrder.verify(c).close();
+        inOrder.verify(c).sendAsync(new WireCommands.ReadSegment(segment.getScopedName(), 1234,  5678, ""));
         inOrder.verify(c).close();
-        inOrder.verify(c).sendAsync(new WireCommands.ReadSegment(segment.getScopedName(), 1234, 5678));
+        inOrder.verify(c).sendAsync(new WireCommands.ReadSegment(segment.getScopedName(), 1234,   5678, ""));
         verifyNoMoreInteractions(c);
     }
     
@@ -85,7 +93,7 @@ public class AsyncSegmentInputStreamTest {
         MockConnectionFactoryImpl connectionFactory = new MockConnectionFactoryImpl();
         MockController controller = new MockController(endpoint.getEndpoint(), endpoint.getPort(), connectionFactory);
         @Cleanup
-        AsyncSegmentInputStreamImpl in = new AsyncSegmentInputStreamImpl(controller, connectionFactory, segment);
+        AsyncSegmentInputStreamImpl in = new AsyncSegmentInputStreamImpl(controller, connectionFactory, segment, "");
         ClientConnection c = mock(ClientConnection.class);
         connectionFactory.provideConnection(endpoint, c);
         in.getConnection().get(); // Make sure connection is established.
@@ -104,7 +112,7 @@ public class AsyncSegmentInputStreamTest {
         MockController controller = new MockController(endpoint.getEndpoint(), endpoint.getPort(), connectionFactory);
 
         @Cleanup
-        AsyncSegmentInputStreamImpl in = new AsyncSegmentInputStreamImpl(controller, connectionFactory, segment);
+        AsyncSegmentInputStreamImpl in = new AsyncSegmentInputStreamImpl(controller, connectionFactory, segment, "");
         ClientConnection c = mock(ClientConnection.class);
         connectionFactory.provideConnection(endpoint, c);
         
@@ -114,7 +122,7 @@ public class AsyncSegmentInputStreamTest {
             ReplyProcessor processor = connectionFactory.getProcessor(endpoint);
             processor.segmentRead(segmentRead);            
         });
-        verify(c).sendAsync(new WireCommands.ReadSegment(segment.getScopedName(), 1234, 5678));
+        verify(c).sendAsync(new WireCommands.ReadSegment(segment.getScopedName(), 1234,  5678, ""));
         assertTrue(Futures.isSuccessful(readFuture));
         assertEquals(segmentRead, readFuture.join());
         verifyNoMoreInteractions(c);
@@ -129,7 +137,7 @@ public class AsyncSegmentInputStreamTest {
         MockConnectionFactoryImpl connectionFactory = new MockConnectionFactoryImpl();
         MockController controller = new MockController(endpoint.getEndpoint(), endpoint.getPort(), connectionFactory);
         @Cleanup
-        AsyncSegmentInputStreamImpl in = new AsyncSegmentInputStreamImpl(controller, connectionFactory, segment);
+        AsyncSegmentInputStreamImpl in = new AsyncSegmentInputStreamImpl(controller, connectionFactory, segment, "");
         ClientConnection c = mock(ClientConnection.class);
         connectionFactory.provideConnection(endpoint, c);
         CompletableFuture<SegmentRead> readFuture = in.read(1234, 5678);
@@ -138,7 +146,7 @@ public class AsyncSegmentInputStreamTest {
             processor.segmentRead(new WireCommands.SegmentRead(segment.getScopedName(), 1235, false, false, ByteBuffer.wrap(bad)));            
             processor.segmentRead(new WireCommands.SegmentRead(segment.getScopedName(), 1234, false, false, ByteBuffer.wrap(good)));         
         });
-        verify(c).sendAsync(new WireCommands.ReadSegment(segment.getScopedName(), 1234, 5678));
+        verify(c).sendAsync(new WireCommands.ReadSegment(segment.getScopedName(), 1234,  5678, ""));
         assertTrue(Futures.isSuccessful(readFuture));
         assertEquals(ByteBuffer.wrap(good), readFuture.join().getData());
         verifyNoMoreInteractions(c);
diff --git a/client/src/test/java/io/pravega/client/segment/impl/SegmentMetadataClientTest.java b/client/src/test/java/io/pravega/client/segment/impl/SegmentMetadataClientTest.java
index 43aa38c..917d71d 100644
--- a/client/src/test/java/io/pravega/client/segment/impl/SegmentMetadataClientTest.java
+++ b/client/src/test/java/io/pravega/client/segment/impl/SegmentMetadataClientTest.java
@@ -59,8 +59,8 @@ public class SegmentMetadataClientTest {
                                                                   123, 121));
                 return null;
             }
-        }).when(connection).send(new WireCommands.GetStreamSegmentInfo(1, segment.getScopedName()));
-        long length = client.fetchCurrentSegmentLength();
+        }).when(connection).send(new WireCommands.GetStreamSegmentInfo(1, segment.getScopedName(), ""));
+        long length = client.fetchCurrentSegmentLength("");
         assertEquals(123, length);
     }
     
@@ -85,9 +85,9 @@ public class SegmentMetadataClientTest {
                 processor.segmentTruncated(new SegmentTruncated(1, segment.getScopedName()));
                 return null;
             }
-        }).when(connection).send(new WireCommands.TruncateSegment(1, segment.getScopedName(), 123L));
-        client.truncateSegment(segment, 123L);
-        Mockito.verify(connection).send(new WireCommands.TruncateSegment(1, segment.getScopedName(), 123L));
+        }).when(connection).send(new WireCommands.TruncateSegment(1, segment.getScopedName(), 123L, ""));
+        client.truncateSegment(segment, 123L, "");
+        Mockito.verify(connection).send(new WireCommands.TruncateSegment(1, segment.getScopedName(), 123L, ""));
     }  
 
     @Test(timeout = 10000)
@@ -112,7 +112,7 @@ public class SegmentMetadataClientTest {
                 processor.segmentAttribute(new WireCommands.SegmentAttribute(1, 123));
                 return null;
             }
-        }).when(connection).send(new WireCommands.GetSegmentAttribute(1, segment.getScopedName(), attributeId));
+        }).when(connection).send(new WireCommands.GetSegmentAttribute(1, segment.getScopedName(), attributeId, ""));
         long value = client.fetchProperty(SegmentAttribute.RevisionStreamClientMark);
         assertEquals(123, value);
     }
@@ -136,8 +136,8 @@ public class SegmentMetadataClientTest {
                 return null;
             }
         }).when(connection).send(new WireCommands.UpdateSegmentAttribute(1, segment.getScopedName(), attributeId, 1234,
-                                                                         -1234));
-        assertTrue(client.compareAndSetAttribute(SegmentAttribute.RevisionStreamClientMark, -1234, 1234));
+                                                                         -1234, ""));
+        assertTrue(client.compareAndSetAttribute(SegmentAttribute.RevisionStreamClientMark, -1234, 1234, ""));
     }
 
     @Test(timeout = 10000)
@@ -155,7 +155,7 @@ public class SegmentMetadataClientTest {
         SegmentMetadataClientImpl client = new SegmentMetadataClientImpl(segment, controller, cf);
         client.getConnection();
         ReplyProcessor processor = cf.getProcessor(endpoint);
-        WireCommands.GetStreamSegmentInfo getSegmentInfo1 = new WireCommands.GetStreamSegmentInfo(1, segment.getScopedName());
+        WireCommands.GetStreamSegmentInfo getSegmentInfo1 = new WireCommands.GetStreamSegmentInfo(1, segment.getScopedName(), "");
         Mockito.doAnswer(new Answer<Void>() {
             @Override
             public Void answer(InvocationOnMock invocation) throws Throwable {
@@ -163,7 +163,7 @@ public class SegmentMetadataClientTest {
                 return null;
             }
         }).when(connection).send(getSegmentInfo1);
-        WireCommands.GetStreamSegmentInfo getSegmentInfo2 = new WireCommands.GetStreamSegmentInfo(2, segment.getScopedName());
+        WireCommands.GetStreamSegmentInfo getSegmentInfo2 = new WireCommands.GetStreamSegmentInfo(2, segment.getScopedName(), "");
         Mockito.doAnswer(new Answer<Void>() {
             @Override
             public Void answer(InvocationOnMock invocation) throws Throwable {
@@ -172,7 +172,7 @@ public class SegmentMetadataClientTest {
                 return null;
             }
         }).when(connection).send(getSegmentInfo2);
-        long length = client.fetchCurrentSegmentLength();
+        long length = client.fetchCurrentSegmentLength("");
         InOrder order = Mockito.inOrder(connection, cf);
         order.verify(cf).establishConnection(endpoint, processor);
         order.verify(connection).send(getSegmentInfo1);
@@ -206,9 +206,9 @@ public class SegmentMetadataClientTest {
                        return CompletableFuture.completedFuture(connection2);
                    }
                });
-        WireCommands.GetStreamSegmentInfo getSegmentInfo1 = new WireCommands.GetStreamSegmentInfo(2, segment.getScopedName());
+        WireCommands.GetStreamSegmentInfo getSegmentInfo1 = new WireCommands.GetStreamSegmentInfo(2,  segment.getScopedName(), "");
         Mockito.doThrow(new ConnectionFailedException()).when(connection1).send(getSegmentInfo1);
-        WireCommands.GetStreamSegmentInfo getSegmentInfo2 = new WireCommands.GetStreamSegmentInfo(3, segment.getScopedName());
+        WireCommands.GetStreamSegmentInfo getSegmentInfo2 = new WireCommands.GetStreamSegmentInfo(3, segment.getScopedName(), "");
         Mockito.doAnswer(new Answer<Void>() {
             @Override
             public Void answer(InvocationOnMock invocation) throws Throwable {
@@ -220,7 +220,7 @@ public class SegmentMetadataClientTest {
         @Cleanup
         SegmentMetadataClientImpl client = new SegmentMetadataClientImpl(segment, controller, cf);
         InOrder order = Mockito.inOrder(connection1, connection2, cf);
-        long length = client.fetchCurrentSegmentLength();
+        long length = client.fetchCurrentSegmentLength("");
         order.verify(cf, Mockito.times(2)).establishConnection(Mockito.eq(endpoint), Mockito.any());
         order.verify(connection1).send(getSegmentInfo1);
         order.verify(connection1).close();
diff --git a/client/src/test/java/io/pravega/client/segment/impl/SegmentOutputStreamTest.java b/client/src/test/java/io/pravega/client/segment/impl/SegmentOutputStreamTest.java
index 0e9e7ac..4cad9a9 100644
--- a/client/src/test/java/io/pravega/client/segment/impl/SegmentOutputStreamTest.java
+++ b/client/src/test/java/io/pravega/client/segment/impl/SegmentOutputStreamTest.java
@@ -9,7 +9,6 @@
  */
 package io.pravega.client.segment.impl;
 
-
 import com.google.common.collect.ImmutableList;
 import io.netty.buffer.Unpooled;
 import io.pravega.client.netty.impl.ClientConnection;
@@ -53,7 +52,13 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.*;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 
 public class SegmentOutputStreamTest {
@@ -78,9 +83,9 @@ public class SegmentOutputStreamTest {
         MockController controller = new MockController(uri.getEndpoint(), uri.getPort(), cf);
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid,  SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
 
         sendAndVerifyEvent(cid, connection, output, getBuffer("test"), 1, null);
@@ -100,13 +105,13 @@ public class SegmentOutputStreamTest {
         MockController controller = new MockController(uri.getEndpoint(), uri.getPort(), cf);
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
 
         cf.getProcessor(uri).connectionDropped(); // simulate a connection dropped
         //Ensure setup Append is invoked on the executor.
-        verify(connection).send(new SetupAppend(2, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(2, cid, SEGMENT, ""));
     }
 
     @Test(timeout = 10000)
@@ -123,10 +128,10 @@ public class SegmentOutputStreamTest {
         ClientConnection connection = mock(ClientConnection.class);
         doThrow(ConnectionFailedException.class).doNothing().when(connection).send(any(SetupAppend.class));
         cf.provideConnection(uri, connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
-        verify(connection).send(new SetupAppend(2, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
+        verify(connection).send(new SetupAppend(2, cid, SEGMENT, ""));
     }
 
     @Test(timeout = 10000)
@@ -142,19 +147,19 @@ public class SegmentOutputStreamTest {
         MockController controller = new MockController(uri.getEndpoint(), uri.getPort(), cf);
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
 
         //simulate a processing Failure and ensure SetupAppend is executed.
         cf.getProcessor(uri).processingFailure(new IOException());
-        verify(connection).send(new SetupAppend(2, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(2, cid, SEGMENT, ""));
 
         cf.getProcessor(uri).connectionDropped();
-        verify(connection).send(new SetupAppend(3, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(3, cid, SEGMENT, ""));
 
         cf.getProcessor(uri).wrongHost(new WireCommands.WrongHost(3, SEGMENT, "newHost"));
-        verify(connection).send(new SetupAppend(4, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(4, cid, SEGMENT, ""));
     }
 
     protected void implementAsDirectExecutor(ScheduledExecutorService executor) {
@@ -192,9 +197,9 @@ public class SegmentOutputStreamTest {
         MockController controller = new MockController(uri.getEndpoint(), uri.getPort(), cf);
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
 
         sendAndVerifyEvent(cid, connection, output, getBuffer("test"), 1, 0L);
@@ -214,7 +219,7 @@ public class SegmentOutputStreamTest {
         InOrder inOrder = inOrder(connection);
         cf.provideConnection(uri, connection);
         @SuppressWarnings("resource")
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         
         output.reconnect();
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
@@ -230,11 +235,11 @@ public class SegmentOutputStreamTest {
         Append append2 = new Append(SEGMENT, cid, 2, Unpooled.wrappedBuffer(getBuffer("test2")), null);
         Append append3 = new Append(SEGMENT, cid, 3, Unpooled.wrappedBuffer(getBuffer("test3")), null);
         Append append4 = new Append(SEGMENT, cid, 4, Unpooled.wrappedBuffer(getBuffer("test4")), null);
-        inOrder.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        inOrder.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         inOrder.verify(connection).send(append1);
         inOrder.verify(connection).send(append2);
         inOrder.verify(connection).close();
-        inOrder.verify(connection).send(new SetupAppend(2, cid, SEGMENT));
+        inOrder.verify(connection).send(new SetupAppend(2, cid, SEGMENT, ""));
         inOrder.verify(connection).sendAsync(eq(ImmutableList.of(append1, append2)), any());
         inOrder.verify(connection).send(append3);
         inOrder.verify(connection).send(append4);
@@ -273,9 +278,9 @@ public class SegmentOutputStreamTest {
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
 
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
 
@@ -303,9 +308,9 @@ public class SegmentOutputStreamTest {
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
         InOrder order = Mockito.inOrder(connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
 
@@ -341,9 +346,9 @@ public class SegmentOutputStreamTest {
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
         InOrder order = Mockito.inOrder(connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
 
@@ -381,9 +386,9 @@ public class SegmentOutputStreamTest {
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
         InOrder order = Mockito.inOrder(connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
 
@@ -420,10 +425,10 @@ public class SegmentOutputStreamTest {
         MockController controller = new MockController(uri.getEndpoint(), uri.getPort(), cf);
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
         InOrder inOrder = Mockito.inOrder(connection);
-        inOrder.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        inOrder.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
 
@@ -454,7 +459,7 @@ public class SegmentOutputStreamTest {
             cf.getProcessor(uri).appendSetup(new AppendSetup(2, SEGMENT, cid, 0));
         });
         inOrder.verify(connection).send(append);
-        inOrder.verify(connection).send(new SetupAppend(2, cid, SEGMENT));
+        inOrder.verify(connection).send(new SetupAppend(2, cid, SEGMENT, ""));
         inOrder.verify(connection).sendAsync(Mockito.eq(Collections.singletonList(append)), Mockito.any());
         inOrder.verify(connection).send(append2);
         assertEquals(false, acked.isDone());
@@ -478,10 +483,10 @@ public class SegmentOutputStreamTest {
         MockController controller = new MockController(uri.getEndpoint(), uri.getPort(), cf);
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
         InOrder inOrder = Mockito.inOrder(connection);
-        inOrder.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        inOrder.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
         
@@ -514,7 +519,7 @@ public class SegmentOutputStreamTest {
             cf.getProcessor(uri).dataAppended(new WireCommands.DataAppended(cid, 1, 0));
         });
         inOrder.verify(connection).send(new WireCommands.KeepAlive());
-        inOrder.verify(connection).send(new SetupAppend(2, cid, SEGMENT));
+        inOrder.verify(connection).send(new SetupAppend(2, cid, SEGMENT, ""));
         inOrder.verify(connection).sendAsync(Mockito.eq(Collections.singletonList(append)), Mockito.any());
         inOrder.verify(connection).close();
         assertEquals(true, acked.isDone());
@@ -533,9 +538,9 @@ public class SegmentOutputStreamTest {
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
         @Cleanup
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
 
         ByteBuffer data = ByteBuffer.allocate(PendingEvent.MAX_WRITE_SIZE + 1);
@@ -562,9 +567,9 @@ public class SegmentOutputStreamTest {
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
         InOrder order = Mockito.inOrder(connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
 
@@ -589,9 +594,9 @@ public class SegmentOutputStreamTest {
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
         InOrder order = Mockito.inOrder(connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
 
@@ -621,9 +626,9 @@ public class SegmentOutputStreamTest {
         cf.provideConnection(uri, connection);
         InOrder order = Mockito.inOrder(connection);
         SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid,
-                segmentSealedCallback, RETRY_SCHEDULE);
+                segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        order.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
 
@@ -639,13 +644,13 @@ public class SegmentOutputStreamTest {
                 cf.getProcessor(uri).appendSetup(new AppendSetup(3, SEGMENT, cid, 1));
                 return null;
             }
-        }).when(connection).send(new SetupAppend(3, cid, SEGMENT));
+        }).when(connection).send(new SetupAppend(3, cid, SEGMENT, ""));
         Async.testBlocking(() -> {
             output.flush();
         }, () -> {
             cf.getProcessor(uri).connectionDropped();
         });
-        order.verify(connection).send(new SetupAppend(3, cid, SEGMENT));
+        order.verify(connection).send(new SetupAppend(3, cid, SEGMENT, ""));
         assertEquals(true, ack.isDone());
     }
 
@@ -662,7 +667,7 @@ public class SegmentOutputStreamTest {
         InOrder inOrder = inOrder(connection);
         cf.provideConnection(uri, connection);
         @SuppressWarnings("resource")
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         
         output.reconnect();
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
@@ -689,7 +694,7 @@ public class SegmentOutputStreamTest {
                 cf.getProcessor(uri).appendSetup(new AppendSetup(2, SEGMENT, cid, 0));
                 return null;
             }
-        }).when(connection).send(new SetupAppend(2, cid, SEGMENT));
+        }).when(connection).send(new SetupAppend(2, cid, SEGMENT, ""));
         
         cf.getProcessor(uri).connectionDropped();
         Async.testBlocking(() -> output.write(new PendingEvent(null, getBuffer("test3"), new CompletableFuture<>())),
@@ -702,14 +707,14 @@ public class SegmentOutputStreamTest {
         Append append2 = new Append(SEGMENT, cid, 2, Unpooled.wrappedBuffer(getBuffer("test2")), null);
         Append append3 = new Append(SEGMENT, cid, 3, Unpooled.wrappedBuffer(getBuffer("test3")), null);
         Append append4 = new Append(SEGMENT, cid, 4, Unpooled.wrappedBuffer(getBuffer("test4")), null);
-        inOrder.verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        inOrder.verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         inOrder.verify(connection).send(append1);
         inOrder.verify(connection).send(append2);
         inOrder.verify(connection).close();
-        inOrder.verify(connection).send(new SetupAppend(2, cid, SEGMENT));
+        inOrder.verify(connection).send(new SetupAppend(2, cid, SEGMENT, ""));
         inOrder.verify(connection).sendAsync(eq(ImmutableList.of(append1, append2)), any());
         inOrder.verify(connection).close();
-        inOrder.verify(connection).send(new SetupAppend(3, cid, SEGMENT));
+        inOrder.verify(connection).send(new SetupAppend(3, cid, SEGMENT, ""));
         inOrder.verify(connection).sendAsync(eq(ImmutableList.of(append1, append2)), any());
         inOrder.verify(connection).send(append3);
         inOrder.verify(connection).send(append4);
@@ -735,9 +740,9 @@ public class SegmentOutputStreamTest {
                 throw new IllegalStateException();
             }
         };
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, exceptionCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, exceptionCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         ByteBuffer data = getBuffer("test");
 
@@ -750,7 +755,7 @@ public class SegmentOutputStreamTest {
                 cf.getProcessor(uri).appendSetup(new AppendSetup(3, SEGMENT, cid, 0));
                 return null;
             }
-        }).when(connection).send(new SetupAppend(3, cid, SEGMENT));
+        }).when(connection).send(new SetupAppend(3, cid, SEGMENT, ""));
         Async.testBlocking(() -> {
             AssertExtensions.assertThrows(SegmentSealedException.class, () -> output.flush());
         }, () -> {
@@ -775,9 +780,9 @@ public class SegmentOutputStreamTest {
         MockController controller = new MockController(uri.getEndpoint(), uri.getPort(), cf);
         ClientConnection connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
-        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        SegmentOutputStreamImpl output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
 
         cf.getProcessor(uri).noSuchSegment(new NoSuchSegment(1, SEGMENT)); // simulate segment does not exist
         verify(connection).close();
@@ -785,9 +790,9 @@ public class SegmentOutputStreamTest {
         //With an inflight event.
         connection = mock(ClientConnection.class);
         cf.provideConnection(uri, connection);
-        output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE);
+        output = new SegmentOutputStreamImpl(SEGMENT, controller, cf, cid, segmentSealedCallback, RETRY_SCHEDULE, "");
         output.reconnect();
-        verify(connection).send(new SetupAppend(1, cid, SEGMENT));
+        verify(connection).send(new SetupAppend(1, cid, SEGMENT, ""));
         cf.getProcessor(uri).appendSetup(new AppendSetup(1, SEGMENT, cid, 0));
         CompletableFuture<Boolean> ack = new CompletableFuture<>();
         output.write(new PendingEvent("RoutingKey", ByteBuffer.wrap(new byte[] { 1, 2, 3 }), ack));
diff --git a/client/src/test/java/io/pravega/client/stream/impl/ControllerImplLBTest.java b/client/src/test/java/io/pravega/client/stream/impl/ControllerImplLBTest.java
index cb2a81e..62b66e2 100644
--- a/client/src/test/java/io/pravega/client/stream/impl/ControllerImplLBTest.java
+++ b/client/src/test/java/io/pravega/client/stream/impl/ControllerImplLBTest.java
@@ -10,8 +10,9 @@
 package io.pravega.client.stream.impl;
 
 import io.grpc.Server;
-import io.grpc.inprocess.InProcessServerBuilder;
+import io.grpc.netty.NettyServerBuilder;
 import io.grpc.stub.StreamObserver;
+import io.pravega.client.ClientConfig;
 import io.pravega.common.Exceptions;
 import io.pravega.common.util.RetriesExhaustedException;
 import io.pravega.controller.stream.api.grpc.v1.Controller.NodeUri;
@@ -101,9 +102,9 @@ public class ControllerImplLBTest {
             }
         };
 
-        testRPCServer1 = InProcessServerBuilder.forPort(serverPort1).addService(fakeServerImpl1).build().start();
-        testRPCServer2 = InProcessServerBuilder.forPort(serverPort2).addService(fakeServerImpl2).build().start();
-        testRPCServer3 = InProcessServerBuilder.forPort(serverPort3).addService(fakeServerImpl3).build().start();
+        testRPCServer1 = NettyServerBuilder.forPort(serverPort1).addService(fakeServerImpl1).build().start();
+        testRPCServer2 = NettyServerBuilder.forPort(serverPort2).addService(fakeServerImpl2).build().start();
+        testRPCServer3 = NettyServerBuilder.forPort(serverPort3).addService(fakeServerImpl3).build().start();
     }
 
     @After
@@ -122,8 +123,9 @@ public class ControllerImplLBTest {
         @Cleanup("shutdown")
         InlineExecutor executor = new InlineExecutor();
         final ControllerImpl controllerClient = new ControllerImpl(
-                URI.create("pravega://localhost:" + serverPort1 + ",localhost:" + serverPort2),
-                ControllerImplConfig.builder().retryAttempts(1).build(), executor);
+                ControllerImplConfig.builder()
+                                    .clientConfig(ClientConfig.builder().controllerURI(URI.create("pravega://localhost:" + serverPort1 + ",localhost:" + serverPort2)).build())
+                                    .retryAttempts(1).build(), executor);
         final Set<PravegaNodeUri> uris = fetchFromServers(controllerClient, 3);
 
         // Verify we could reach all 3 controllers.
@@ -140,8 +142,9 @@ public class ControllerImplLBTest {
         @Cleanup("shutdown")
         InlineExecutor executor = new InlineExecutor();
         final ControllerImpl controllerClient = new ControllerImpl(
-                URI.create("pravega://" + localIP + ":" + serverPort1 + "," + localIP + ":" + serverPort2),
-                ControllerImplConfig.builder().retryAttempts(1).build(), executor);
+                ControllerImplConfig.builder()
+                                    .clientConfig(ClientConfig.builder().controllerURI(URI.create("pravega://" + localIP + ":" + serverPort1 + "," + localIP + ":" + serverPort2)).build())
+                                    .retryAttempts(1).build(), executor);
         final Set<PravegaNodeUri> uris = fetchFromServers(controllerClient, 3);
 
         // Verify we could reach all 3 controllers.
@@ -159,9 +162,10 @@ public class ControllerImplLBTest {
         Assert.assertTrue(testRPCServer1.isTerminated());
         @Cleanup("shutdown")
         InlineExecutor executor = new InlineExecutor();
-        final ControllerImpl controllerClient = new ControllerImpl(
-                URI.create("pravega://localhost:" + serverPort1 + ",localhost:" + serverPort2),
-                ControllerImplConfig.builder().retryAttempts(1).build(), executor);
+        final ControllerImpl controllerClient = new ControllerImpl( ControllerImplConfig.builder()
+                .clientConfig(ClientConfig.builder().controllerURI(URI.create("pravega://localhost:" + serverPort1 + ",localhost:" + serverPort2)).build())
+                .retryAttempts(1).build(),
+                executor);
 
         // Verify that we can read from the 2 live servers.
         Set<PravegaNodeUri> uris = fetchFromServers(controllerClient, 2);
@@ -186,9 +190,9 @@ public class ControllerImplLBTest {
         testRPCServer3.shutdownNow();
         testRPCServer3.awaitTermination();
         Assert.assertTrue(testRPCServer3.isTerminated());
-        final ControllerImpl client = new ControllerImpl(
-                URI.create("pravega://localhost:" + serverPort1 + ",localhost:" + serverPort2),
-                ControllerImplConfig.builder().retryAttempts(1).build(), executor);
+        final ControllerImpl client = new ControllerImpl( ControllerImplConfig.builder()
+                .clientConfig(ClientConfig.builder().controllerURI(URI.create("pravega://localhost:" + serverPort1 + ",localhost:" + serverPort2)).build())
+                .retryAttempts(1).build(), executor);
         AssertExtensions.assertThrows(RetriesExhaustedException.class, () -> client.getEndpointForSegment("a/b/0").get());
     }
 
@@ -201,9 +205,9 @@ public class ControllerImplLBTest {
         // Directly use all 3 servers and verify.
         @Cleanup("shutdown")
         InlineExecutor executor = new InlineExecutor();
-        final ControllerImpl controllerClient = new ControllerImpl(URI.create("tcp://localhost:" + serverPort1
-                + ",localhost:" + serverPort2 + ",localhost:" + serverPort3),
-                ControllerImplConfig.builder().retryAttempts(1).build(), executor);
+        final ControllerImpl controllerClient = new ControllerImpl( ControllerImplConfig.builder()
+                .clientConfig(ClientConfig.builder().controllerURI(URI.create("tcp://localhost:" + serverPort1 + ",localhost:" + serverPort2 + ",localhost:" + serverPort3)).build())
+                .retryAttempts(1).build(), executor);
         final Set<PravegaNodeUri> uris = fetchFromServers(controllerClient, 3);
         Assert.assertEquals(3, uris.size());
     }
@@ -218,9 +222,9 @@ public class ControllerImplLBTest {
         String localIP = InetAddress.getLoopbackAddress().getHostAddress();
         @Cleanup("shutdown")
         InlineExecutor executor = new InlineExecutor();
-        final ControllerImpl controllerClient = new ControllerImpl(URI.create("tcp://" + localIP + ":" + serverPort1
-                + "," + localIP + ":" + serverPort2 + "," + localIP + ":" + serverPort3),
-                ControllerImplConfig.builder().retryAttempts(1).build(), executor);
+        final ControllerImpl controllerClient = new ControllerImpl( ControllerImplConfig.builder()
+                .clientConfig(ClientConfig.builder().controllerURI(URI.create("tcp://" + localIP + ":" + serverPort1 + "," + localIP + ":" + serverPort2 + "," + localIP + ":" + serverPort3)).build())
+                .retryAttempts(1).build(), executor);
         final Set<PravegaNodeUri> uris = fetchFromServers(controllerClient, 3);
         Assert.assertEquals(3, uris.size());
     }
@@ -238,9 +242,9 @@ public class ControllerImplLBTest {
 
         @Cleanup("shutdown")
         InlineExecutor executor = new InlineExecutor();
-        final ControllerImpl controllerClient = new ControllerImpl(URI.create("tcp://localhost:" + serverPort1
-                + ",localhost:" + serverPort2 + ",localhost:" + serverPort3),
-                ControllerImplConfig.builder().retryAttempts(1).build(), executor);
+        final ControllerImpl controllerClient = new ControllerImpl( ControllerImplConfig.builder()
+                .clientConfig(ClientConfig.builder().controllerURI(URI.create("tcp://localhost:" + serverPort1 + ",localhost:" + serverPort2 + ",localhost:" + serverPort3)).build())
+                .retryAttempts(1).build(), executor);
         Set<PravegaNodeUri> uris = fetchFromServers(controllerClient, 2);
         Assert.assertEquals(2, uris.size());
         Assert.assertFalse(uris.contains(new PravegaNodeUri("localhost1", 1)));
diff --git a/client/src/test/java/io/pravega/client/stream/impl/ControllerImplTest.java b/client/src/test/java/io/pravega/client/stream/impl/ControllerImplTest.java
index 530a147..40a6ac6 100644
--- a/client/src/test/java/io/pravega/client/stream/impl/ControllerImplTest.java
+++ b/client/src/test/java/io/pravega/client/stream/impl/ControllerImplTest.java
@@ -12,9 +12,11 @@ package io.pravega.client.stream.impl;
 import com.google.common.collect.ImmutableSet;
 import io.grpc.Server;
 import io.grpc.Status;
+import io.grpc.netty.GrpcSslContexts;
 import io.grpc.netty.NettyChannelBuilder;
 import io.grpc.netty.NettyServerBuilder;
 import io.grpc.stub.StreamObserver;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.segment.impl.Segment;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.Stream;
@@ -55,6 +57,7 @@ import io.pravega.controller.stream.api.grpc.v1.ControllerServiceGrpc.Controller
 import io.pravega.shared.protocol.netty.PravegaNodeUri;
 import io.pravega.test.common.AssertExtensions;
 import io.pravega.test.common.TestUtils;
+import java.io.File;
 import java.io.IOException;
 import java.net.URI;
 import java.util.ArrayList;
@@ -73,8 +76,8 @@ import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import lombok.val;
 import lombok.extern.slf4j.Slf4j;
+import lombok.val;
 import org.apache.commons.lang3.tuple.Pair;
 import org.junit.After;
 import org.junit.Before;
@@ -96,6 +99,7 @@ public class ControllerImplTest {
 
     @Rule
     public final Timeout globalTimeout = new Timeout(120, TimeUnit.SECONDS);
+    boolean testSecure;
 
     // Global variable to track number of attempts to verify retries.
     private final AtomicInteger retryAttempts = new AtomicInteger(0);
@@ -109,6 +113,8 @@ public class ControllerImplTest {
     // The controller RPC client.
     private ControllerImpl controllerClient = null;
     private ScheduledExecutorService executor;
+    private NettyServerBuilder serverBuilder;
+    private Credentials creds;
 
     @Before
     public void setup() throws IOException {
@@ -585,6 +591,13 @@ public class ControllerImplTest {
             }
 
             @Override
+            public void getDelegationToken(io.pravega.controller.stream.api.grpc.v1.Controller.StreamInfo request,
+                                           io.grpc.stub.StreamObserver<io.pravega.controller.stream.api.grpc.v1.Controller.DelegationToken> responseObserver) {
+                responseObserver.onNext(Controller.DelegationToken.newBuilder().setDelegationToken("token").build());
+                responseObserver.onCompleted();
+            }
+
+            @Override
             public void deleteScope(ScopeInfo request, StreamObserver<DeleteScopeStatus> responseObserver) {
                 if (request.getScope().equals("scope1")) {
                     responseObserver.onNext(DeleteScopeStatus.newBuilder().setStatus(
@@ -611,13 +624,24 @@ public class ControllerImplTest {
         };
 
         serverPort = TestUtils.getAvailableListenPort();
-        testGRPCServer = NettyServerBuilder.forPort(serverPort)
-                .addService(testServerImpl)
+        serverBuilder = NettyServerBuilder.forPort(serverPort)
+                                          .addService(testServerImpl);
+        if (testSecure) {
+         serverBuilder = serverBuilder.useTransportSecurity(new File("../config/cert.pem"),
+                 new File("../config/key.pem"));
+         creds = new DefaultCredentials("1111_aaaa", "admin");
+        }
+        testGRPCServer = serverBuilder
                 .build()
                 .start();
         executor = Executors.newSingleThreadScheduledExecutor();
-        controllerClient = new ControllerImpl(URI.create("tcp://localhost:" + serverPort),
-                ControllerImplConfig.builder().retryAttempts(1).build(), executor);
+        controllerClient = new ControllerImpl( ControllerImplConfig.builder()
+                .clientConfig(
+                        ClientConfig.builder().controllerURI(URI.create((testSecure ? "tls://" : "tcp://") + "localhost:" + serverPort))
+                                    .credentials(new DefaultCredentials("1111_aaaa", "admin"))
+                                    .trustStore("../config/cert.pem")
+                                    .build())
+                .retryAttempts(1).build(), executor);
     }
 
     @After
@@ -630,9 +654,20 @@ public class ControllerImplTest {
     public void testKeepAlive() throws IOException, ExecutionException, InterruptedException {
 
         // Verify that keep-alive timeout less than permissible by the server results in a failure.
-        final ControllerImpl controller = new ControllerImpl(NettyChannelBuilder.forAddress("localhost", serverPort)
-                .keepAliveTime(10, TimeUnit.SECONDS).usePlaintext(true),
-                ControllerImplConfig.builder().retryAttempts(1).build(), this.executor);
+        NettyChannelBuilder builder = NettyChannelBuilder.forAddress("localhost", serverPort)
+                                                         .keepAliveTime(10, TimeUnit.SECONDS);
+        if (testSecure) {
+            builder = builder.sslContext(GrpcSslContexts.forClient().trustManager(new File("../config/cert.pem")).build());
+        } else {
+            builder = builder.usePlaintext(true);
+        }
+        final ControllerImpl controller = new ControllerImpl(builder,
+                ControllerImplConfig.builder().clientConfig(ClientConfig.builder()
+                                                                        .trustStore("../config/cert.pem")
+                                                                        .controllerURI(URI.create((testSecure ? "tls://" : "tcp://") + "localhost:" + serverPort))
+                                                                        .build())
+                                    .retryAttempts(1).build(),
+                this.executor);
         CompletableFuture<Boolean> createStreamStatus = controller.createStream(StreamConfiguration.builder()
                 .streamName("streamdelayed")
                 .scope("scope1")
@@ -643,14 +678,30 @@ public class ControllerImplTest {
 
         // Verify that the same RPC with permissible keepalive time succeeds.
         int serverPort2 = TestUtils.getAvailableListenPort();
-        Server testServer = NettyServerBuilder.forPort(serverPort2)
-                .addService(testServerImpl)
-                .permitKeepAliveTime(5, TimeUnit.SECONDS)
-                .build()
+        NettyServerBuilder testServerBuilder = NettyServerBuilder.forPort(serverPort2)
+                                                                 .addService(testServerImpl)
+                                                                 .permitKeepAliveTime(5, TimeUnit.SECONDS);
+
+        if (testSecure) {
+           testServerBuilder = testServerBuilder.useTransportSecurity(new File("../config/cert.pem"), new File("../config/key.pem"));
+        }
+
+        Server testServer = testServerBuilder.build()
                 .start();
-        final ControllerImpl controller1 = new ControllerImpl(NettyChannelBuilder.forAddress("localhost", serverPort2)
-                .keepAliveTime(10, TimeUnit.SECONDS).usePlaintext(true),
-                ControllerImplConfig.builder().retryAttempts(1).build(), this.executor);
+
+        builder = NettyChannelBuilder.forAddress("localhost", serverPort2)
+                           .keepAliveTime(10, TimeUnit.SECONDS);
+        if (testSecure) {
+            builder = builder.sslContext(GrpcSslContexts.forClient().trustManager(new File("../config/cert.pem")).build());
+        } else {
+            builder = builder.usePlaintext(true);
+        }
+        final ControllerImpl controller1 = new ControllerImpl(builder,
+                ControllerImplConfig.builder().clientConfig(ClientConfig.builder()
+                                                                        .trustStore("../config/cert.pem")
+                                                                        .controllerURI(URI.create((testSecure ? "tls://" : "tcp://") + "localhost:" + serverPort))
+                                                                        .build())
+                                    .retryAttempts(1).build(), this.executor);
         createStreamStatus = controller1.createStream(StreamConfiguration.builder()
                 .streamName("streamdelayed")
                 .scope("scope1")
@@ -664,8 +715,11 @@ public class ControllerImplTest {
     public void testRetries() throws IOException, ExecutionException, InterruptedException {
 
         // Verify retries exhausted error after multiple attempts.
-        final ControllerImpl controller1 = new ControllerImpl(URI.create("tcp://localhost:" + serverPort),
-                ControllerImplConfig.builder().retryAttempts(3).build(), this.executor);
+        final ControllerImpl controller1 = new ControllerImpl( ControllerImplConfig.builder()
+                .clientConfig(ClientConfig.builder()
+                                          .controllerURI(URI.create((testSecure ? "tls://" : "tcp://") + "localhost:" + serverPort))
+                                          .trustStore("../config/cert.pem").build())
+                .retryAttempts(3).build(), this.executor);
         CompletableFuture<Boolean> createStreamStatus = controller1.createStream(StreamConfiguration.builder()
                 .streamName("streamretryfailure")
                 .scope("scope1")
@@ -686,8 +740,11 @@ public class ControllerImplTest {
 
         // The RPC should succeed when internal retry attempts is > 3 which is the hardcoded test value for success.
         this.retryAttempts.set(0);
-        final ControllerImpl controller2 = new ControllerImpl(URI.create("tcp://localhost:" + serverPort),
-                ControllerImplConfig.builder().retryAttempts(4).build(), this.executor);
+        final ControllerImpl controller2 = new ControllerImpl( ControllerImplConfig.builder()
+                .clientConfig(ClientConfig.builder()
+                                          .controllerURI(URI.create((testSecure ? "tls://" : "tcp://") + "localhost:" + serverPort))
+                                          .trustStore("../config/cert.pem").build())
+                .retryAttempts(4).build(), this.executor);
         createStreamStatus = controller2.createStream(StreamConfiguration.builder()
                 .streamName("streamretrysuccess")
                 .scope("scope1")
@@ -697,6 +754,13 @@ public class ControllerImplTest {
     }
 
     @Test
+    public void testGetDelegationToken() throws Exception {
+        CompletableFuture<String> delegationTokenFuture;
+        delegationTokenFuture = controllerClient.getOrRefreshDelegationTokenFor("stream1", "scope1");
+        assertEquals(delegationTokenFuture.get(), "token");
+    }
+
+        @Test
     public void testCreateStream() throws Exception {
         CompletableFuture<Boolean> createStreamStatus;
         createStreamStatus = controllerClient.createStream(StreamConfiguration.builder()
@@ -1123,7 +1187,7 @@ public class ControllerImplTest {
         segments.put(new Segment(scope, stream, 0), 4L);
         segments.put(new Segment(scope, stream, 1), 6L);
         StreamCut cut = new StreamCutImpl(s, segments);
-        Set<Segment> successors = controllerClient.getSuccessors(cut).get();
+        Set<Segment> successors = controllerClient.getSuccessors(cut).get().getSegments();
         assertEquals(ImmutableSet.of(new Segment(scope, stream, 0), new Segment(scope, stream, 1),
                                      new Segment(scope, stream, 2), new Segment(scope, stream, 3),
                                      new Segment(scope, stream, 4), new Segment(scope, stream, 5),
diff --git a/client/src/test/java/io/pravega/client/stream/impl/EventStreamReaderTest.java b/client/src/test/java/io/pravega/client/stream/impl/EventStreamReaderTest.java
index 485ea6c..2852395 100644
--- a/client/src/test/java/io/pravega/client/stream/impl/EventStreamReaderTest.java
+++ b/client/src/test/java/io/pravega/client/stream/impl/EventStreamReaderTest.java
@@ -57,7 +57,7 @@ public class EventStreamReaderTest {
         Mockito.when(groupState.acquireNewSegmentsIfNeeded(0L))
                .thenReturn(ImmutableMap.of(segment, 0L))
                .thenReturn(Collections.emptyMap());
-        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig);
+        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig, "");
         ByteBuffer buffer = writeInt(stream, 1);
         EventRead<byte[]> read = reader.readNextEvent(0);
         byte[] event = read.getEvent();
@@ -82,7 +82,7 @@ public class EventStreamReaderTest {
                                                                            ReaderConfig.builder().build());
         Segment segment = Segment.fromScopedName("Foo/Bar/0");
         Mockito.when(groupState.acquireNewSegmentsIfNeeded(0L)).thenReturn(ImmutableMap.of(segment, 0L)).thenReturn(Collections.emptyMap());
-        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig);
+        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig, "");
         ByteBuffer buffer1 = writeInt(stream, 1);
         ByteBuffer buffer2 = writeInt(stream, 2);
         ByteBuffer buffer3 = writeInt(stream, 3);
@@ -108,8 +108,8 @@ public class EventStreamReaderTest {
         Mockito.when(groupState.acquireNewSegmentsIfNeeded(0L))
                .thenReturn(ImmutableMap.of(segment1, 0L, segment2, 0L))
                .thenReturn(Collections.emptyMap());
-        SegmentOutputStream stream1 = segmentStreamFactory.createOutputStreamForSegment(segment1, segmentSealedCallback, writerConfig);
-        SegmentOutputStream stream2 = segmentStreamFactory.createOutputStreamForSegment(segment2, segmentSealedCallback, writerConfig);
+        SegmentOutputStream stream1 = segmentStreamFactory.createOutputStreamForSegment(segment1, segmentSealedCallback, writerConfig, "");
+        SegmentOutputStream stream2 = segmentStreamFactory.createOutputStreamForSegment(segment2, segmentSealedCallback, writerConfig, "");
         writeInt(stream1, 1);
         writeInt(stream2, 2);
         reader.readNextEvent(0);
@@ -155,8 +155,8 @@ public class EventStreamReaderTest {
                .thenReturn(ImmutableMap.of(segment1, 0L))
                .thenReturn(ImmutableMap.of(segment2, 0L))
                .thenReturn(Collections.emptyMap());
-        SegmentOutputStream stream1 = segmentStreamFactory.createOutputStreamForSegment(segment1, segmentSealedCallback, writerConfig);
-        SegmentOutputStream stream2 = segmentStreamFactory.createOutputStreamForSegment(segment2, segmentSealedCallback, writerConfig);
+        SegmentOutputStream stream1 = segmentStreamFactory.createOutputStreamForSegment(segment1, segmentSealedCallback, writerConfig, "");
+        SegmentOutputStream stream2 = segmentStreamFactory.createOutputStreamForSegment(segment2, segmentSealedCallback, writerConfig, "");
         writeInt(stream1, 1);
         writeInt(stream1, 2);
         writeInt(stream2, 3);
@@ -186,7 +186,7 @@ public class EventStreamReaderTest {
                                                                            ReaderConfig.builder().build());
         Segment segment = Segment.fromScopedName("Foo/Bar/0");
         Mockito.when(groupState.acquireNewSegmentsIfNeeded(0L)).thenReturn(ImmutableMap.of(segment, 0L)).thenReturn(Collections.emptyMap());
-        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig);
+        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig, "");
         ByteBuffer buffer1 = writeInt(stream, 1);
         ByteBuffer buffer2 = writeInt(stream, 2);
         ByteBuffer buffer3 = writeInt(stream, 3);
@@ -215,7 +215,7 @@ public class EventStreamReaderTest {
                                                                            ReaderConfig.builder().build());
         Segment segment = Segment.fromScopedName("Foo/Bar/0");
         Mockito.when(groupState.acquireNewSegmentsIfNeeded(0L)).thenReturn(ImmutableMap.of(segment, 0L)).thenReturn(Collections.emptyMap());
-        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig);
+        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig, "");
         ByteBuffer buffer = writeInt(stream, 1);
         Mockito.when(groupState.getCheckpoint()).thenReturn("Foo").thenReturn(null);
         EventRead<byte[]> eventRead = reader.readNextEvent(0);
@@ -239,7 +239,7 @@ public class EventStreamReaderTest {
                                                                            ReaderConfig.builder().build());
         Segment segment = Segment.fromScopedName("Foo/Bar/0");
         Mockito.when(groupState.acquireNewSegmentsIfNeeded(0L)).thenReturn(ImmutableMap.of(segment, 0L)).thenReturn(Collections.emptyMap());
-        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig);
+        SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback, writerConfig, "");
         ByteBuffer buffer = writeInt(stream, 1);
         Mockito.when(groupState.getCheckpoint()).thenThrow(new ReinitializationRequiredException());
         try {
@@ -267,18 +267,18 @@ public class EventStreamReaderTest {
                .thenReturn(ImmutableMap.of(segment, 0L))
                .thenReturn(Collections.emptyMap());
         SegmentOutputStream stream = segmentStreamFactory.createOutputStreamForSegment(segment, segmentSealedCallback,
-                                                                                       writerConfig);
+                                                                                       writerConfig, "");
         SegmentMetadataClient metadataClient = segmentStreamFactory.createSegmentMetadataClient(segment);
         ByteBuffer buffer1 = writeInt(stream, 1);
         ByteBuffer buffer2 = writeInt(stream, 2);
         ByteBuffer buffer3 = writeInt(stream, 3);
-        long length = metadataClient.fetchCurrentSegmentLength();
+        long length = metadataClient.fetchCurrentSegmentLength("");
         assertEquals(0, length % 3);
         EventRead<byte[]> event1 = reader.readNextEvent(0);
         assertEquals(buffer1, ByteBuffer.wrap(event1.getEvent()));
-        metadataClient.truncateSegment(segment, length / 3);
+        metadataClient.truncateSegment(segment, length / 3, "");
         assertEquals(buffer2, ByteBuffer.wrap(reader.readNextEvent(0).getEvent()));
-        metadataClient.truncateSegment(segment, length);
+        metadataClient.truncateSegment(segment, length, "");
         ByteBuffer buffer4 = writeInt(stream, 4);
         AssertExtensions.assertThrows(TruncatedDataException.class, () -> reader.readNextEvent(0));
         assertEquals(buffer4, ByteBuffer.wrap(reader.readNextEvent(0).getEvent()));
diff --git a/client/src/test/java/io/pravega/client/stream/impl/EventStreamWriterTest.java b/client/src/test/java/io/pravega/client/stream/impl/EventStreamWriterTest.java
index 050058f..000b3f8 100644
--- a/client/src/test/java/io/pravega/client/stream/impl/EventStreamWriterTest.java
+++ b/client/src/test/java/io/pravega/client/stream/impl/EventStreamWriterTest.java
@@ -60,7 +60,7 @@ public class EventStreamWriterTest {
         Controller controller = Mockito.mock(Controller.class);
         Mockito.when(controller.getCurrentSegments(scope, streamName)).thenReturn(getSegmentsFuture(segment));
         MockSegmentIoStreams outputStream = new MockSegmentIoStreams(segment);
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any())).thenReturn(outputStream);
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any(), any())).thenReturn(outputStream);
         EventStreamWriter<String> writer = new EventStreamWriterImpl<>(stream, controller, streamFactory,
                 new JavaSerializer<>(), config, new InlineExecutor());
         writer.writeEvent("Foo");
@@ -77,7 +77,7 @@ public class EventStreamWriterTest {
     private StreamSegments getSegments(Segment segment) {
         NavigableMap<Double, Segment> segments = new TreeMap<>();
         segments.put(1.0, segment);
-        return new StreamSegments(segments);
+        return new StreamSegments(segments, "");
     }
     
     private CompletableFuture<StreamSegments> getSegmentsFuture(Segment segment) {
@@ -87,7 +87,7 @@ public class EventStreamWriterTest {
     private CompletableFuture<StreamSegmentsWithPredecessors> getReplacement(Segment old, Segment repacement) {
         Map<SegmentWithRange, List<Integer>> segments = new HashMap<>();
         segments.put(new SegmentWithRange(repacement, 0, 1), Collections.singletonList(old.getSegmentNumber()));
-        return CompletableFuture.completedFuture(new StreamSegmentsWithPredecessors(segments));
+        return CompletableFuture.completedFuture(new StreamSegmentsWithPredecessors(segments, ""));
     }
 
     @Test
@@ -101,7 +101,7 @@ public class EventStreamWriterTest {
         Controller controller = Mockito.mock(Controller.class);
         Mockito.when(controller.getCurrentSegments(scope, streamName)).thenReturn(getSegmentsFuture(segment));
         SegmentOutputStream outputStream = Mockito.mock(SegmentOutputStream.class);
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any())).thenReturn(outputStream);
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any(), any())).thenReturn(outputStream);
         EventStreamWriter<String> writer = new EventStreamWriterImpl<>(stream, controller, streamFactory,
                 new JavaSerializer<>(), config, new InlineExecutor());
         Mockito.doThrow(new RuntimeException("Intentional exception")).when(outputStream).close();
@@ -221,11 +221,11 @@ public class EventStreamWriterTest {
         FakeSegmentOutputStream outputStream1 = new FakeSegmentOutputStream(segment1);
         FakeSegmentOutputStream outputStream2 = new FakeSegmentOutputStream(segment2);
 
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any())).thenAnswer(i -> {
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any(), any())).thenAnswer(i -> {
             outputStream1.callBackForSealed = i.getArgument(1);
             return outputStream1;
         });
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any())).thenAnswer(i -> {
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any(), any())).thenAnswer(i -> {
             outputStream2.callBackForSealed = i.getArgument(1);
             return outputStream2;
         });
@@ -269,12 +269,12 @@ public class EventStreamWriterTest {
         FakeSegmentOutputStream outputStream1 = new FakeSegmentOutputStream(segment1);
         FakeSegmentOutputStream outputStream2 = new FakeSegmentOutputStream(segment2);
 
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any(), any()))
                 .thenAnswer(i -> {
                     outputStream1.callBackForSealed = i.getArgument(1);
                     return outputStream1;
                 });
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any(), any()))
                 .thenAnswer(i -> {
                     outputStream2.callBackForSealed = i.getArgument(1);
                     return outputStream2;
@@ -331,9 +331,9 @@ public class EventStreamWriterTest {
         FakeSegmentOutputStream bad = new FakeSegmentOutputStream(segment);
         Mockito.when(controller.createTransaction(stream, 0, 0))
                .thenReturn(CompletableFuture.completedFuture(new TxnSegments(getSegments(segment), txid)));
-        Mockito.when(streamFactory.createOutputStreamForTransaction(eq(segment), eq(txid), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForTransaction(eq(segment), eq(txid), any(), any(), any()))
                 .thenReturn(outputStream);
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any())).thenReturn(bad);
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any(), any())).thenReturn(bad);
 
         JavaSerializer<String> serializer = new JavaSerializer<>();
         @Cleanup
@@ -365,9 +365,9 @@ public class EventStreamWriterTest {
         FakeSegmentOutputStream bad = new FakeSegmentOutputStream(segment);
         Mockito.when(controller.createTransaction(stream, 0,  0))
                .thenReturn(CompletableFuture.completedFuture(new TxnSegments(getSegments(segment), txid)));
-        Mockito.when(streamFactory.createOutputStreamForTransaction(eq(segment), eq(txid), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForTransaction(eq(segment), eq(txid), any(), any(), any()))
                 .thenReturn(outputStream);
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any())).thenReturn(bad);
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any(), any())).thenReturn(bad);
 
         JavaSerializer<String> serializer = new JavaSerializer<>();
         @Cleanup
@@ -396,7 +396,7 @@ public class EventStreamWriterTest {
         Controller controller = Mockito.mock(Controller.class);
         FakeSegmentOutputStream outputStream = new FakeSegmentOutputStream(segment);
         Mockito.when(controller.getCurrentSegments(scope, streamName)).thenReturn(getSegmentsFuture(segment));
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any())).thenReturn(outputStream);
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment), any(), any(), any())).thenReturn(outputStream);
 
         JavaSerializer<String> serializer = new JavaSerializer<>();
         @Cleanup
@@ -424,7 +424,7 @@ public class EventStreamWriterTest {
         Mockito.when(controller.getCurrentSegments(scope, streamName))
                .thenReturn(getSegmentsFuture(segment1));
         Mockito.when(controller.getSuccessors(segment1)).thenReturn(getReplacement(segment1, segment2));
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any(), any()))
                 .thenAnswer(i -> {
                     outputStream.callBackForSealed = i.getArgument(1);
                     return outputStream;
@@ -438,13 +438,13 @@ public class EventStreamWriterTest {
         assertTrue(outputStream.getUnackedEventsOnSeal().size() > 0);
 
         MockSegmentIoStreams outputStream2 = new MockSegmentIoStreams(segment2);
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any())).thenReturn(outputStream2);
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any(), any())).thenReturn(outputStream2);
         outputStream.invokeSealedCallBack();
 
         writer.flush();
 
         Mockito.verify(controller, Mockito.times(1)).getCurrentSegments(any(), any());
-        assertTrue(outputStream2.fetchCurrentSegmentLength() > 0);
+        assertTrue(outputStream2.fetchCurrentSegmentLength("") > 0);
         assertEquals(serializer.serialize("Foo"), outputStream2.read());
     }
 
@@ -463,7 +463,7 @@ public class EventStreamWriterTest {
         Mockito.when(controller.getCurrentSegments(scope, streamName))
                 .thenReturn(getSegmentsFuture(segment1));
         Mockito.when(controller.getSuccessors(segment1)).thenReturn(getReplacement(segment1, segment2));
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any(), any()))
                 .thenAnswer(i -> {
                     outputStream.callBackForSealed = i.getArgument(1);
                     return outputStream;
@@ -477,7 +477,7 @@ public class EventStreamWriterTest {
         assertTrue(outputStream.getUnackedEventsOnSeal().size() > 0);
 
         MockSegmentIoStreams outputStream2 = new MockSegmentIoStreams(segment2);
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any())).thenReturn(outputStream2);
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any(), any())).thenReturn(outputStream2);
 
         Async.testBlocking(() -> {
             writer.flush(); // blocking on flush.
@@ -487,7 +487,7 @@ public class EventStreamWriterTest {
         });
 
         Mockito.verify(controller, Mockito.times(1)).getCurrentSegments(any(), any());
-        assertTrue(outputStream2.fetchCurrentSegmentLength() > 0);
+        assertTrue(outputStream2.fetchCurrentSegmentLength("") > 0);
         assertEquals(serializer.serialize("Foo"), outputStream2.read());
     }
 
@@ -506,7 +506,7 @@ public class EventStreamWriterTest {
         Mockito.when(controller.getCurrentSegments(scope, streamName))
                 .thenReturn(getSegmentsFuture(segment1));
         Mockito.when(controller.getSuccessors(segment1)).thenReturn(getReplacement(segment1, segment2));
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any(), any()))
                 .thenAnswer(i -> {
                     outputStream.callBackForSealed = i.getArgument(1);
                     return outputStream;
@@ -520,7 +520,7 @@ public class EventStreamWriterTest {
         assertTrue(outputStream.getUnackedEventsOnSeal().size() > 0);
 
         MockSegmentIoStreams outputStream2 = new MockSegmentIoStreams(segment2);
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any())).thenReturn(outputStream2);
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any(), any())).thenReturn(outputStream2);
 
         Async.testBlocking(() -> {
             writer.close(); // closed invokes flush internally; this call is blocking on flush.
@@ -530,7 +530,7 @@ public class EventStreamWriterTest {
         });
 
         Mockito.verify(controller, Mockito.times(1)).getCurrentSegments(any(), any());
-        assertTrue(outputStream2.fetchCurrentSegmentLength() > 0);
+        assertTrue(outputStream2.fetchCurrentSegmentLength("") > 0);
         assertTrue(outputStream2.isClosed());
         //the connection to outputStream is closed with the failConnection during SegmentSealed Callback.
         assertEquals(serializer.serialize("Foo"), outputStream2.read());
@@ -551,7 +551,7 @@ public class EventStreamWriterTest {
         Mockito.when(controller.getCurrentSegments(scope, streamName))
                 .thenReturn(getSegmentsFuture(segment1));
         Mockito.when(controller.getSuccessors(segment1)).thenReturn(getReplacement(segment1, segment2));
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any(), any()))
                 .thenAnswer(i -> {
                     outputStream1.callBackForSealed = i.getArgument(1);
                     return outputStream1;
@@ -565,13 +565,13 @@ public class EventStreamWriterTest {
         assertTrue(outputStream1.getUnackedEventsOnSeal().size() > 0);
 
         MockSegmentIoStreams outputStream2 = new MockSegmentIoStreams(segment2);
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any())).thenReturn(outputStream2);
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any(), any())).thenReturn(outputStream2);
         outputStream1.invokeSealedCallBack();
 
         writer.close();
 
         Mockito.verify(controller, Mockito.times(1)).getCurrentSegments(any(), any());
-        assertTrue(outputStream2.fetchCurrentSegmentLength() > 0);
+        assertTrue(outputStream2.fetchCurrentSegmentLength("") > 0);
         assertEquals(serializer.serialize("Foo"), outputStream2.read());
     }
 
@@ -596,17 +596,17 @@ public class EventStreamWriterTest {
         Mockito.when(controller.getSuccessors(segment1)).thenReturn(getReplacement(segment1, segment2));
         Mockito.when(controller.getSuccessors(segment2)).thenReturn(getReplacement(segment2, segment3));
 
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment1), any(), any(), any()))
                 .thenAnswer(i -> {
                     outputStream1.callBackForSealed = i.getArgument(1);
                     return outputStream1;
                 });
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment2), any(), any(), any()))
                 .thenAnswer(i -> {
                     outputStream2.callBackForSealed = i.getArgument(1);
                     return outputStream2;
                 });
-        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment3), any(), any()))
+        Mockito.when(streamFactory.createOutputStreamForSegment(eq(segment3), any(), any(), any()))
                 .thenAnswer(i -> {
                     outputStream3.callBackForSealed = i.getArgument(1);
                     return outputStream3;
diff --git a/client/src/test/java/io/pravega/client/stream/impl/ModelHelperTest.java b/client/src/test/java/io/pravega/client/stream/impl/ModelHelperTest.java
index 9d92d2b..ae07900 100644
--- a/client/src/test/java/io/pravega/client/stream/impl/ModelHelperTest.java
+++ b/client/src/test/java/io/pravega/client/stream/impl/ModelHelperTest.java
@@ -189,7 +189,7 @@ public class ModelHelperTest {
         Map<Controller.SegmentRange, List<Integer>> inputMap = new HashMap<>(1);
         inputMap.put(segmentRange, Arrays.asList(1));
 
-        Controller.SuccessorResponse successorResponse = ModelHelper.createSuccessorResponse(inputMap);
+        Controller.SuccessorResponse successorResponse = ModelHelper.createSuccessorResponse(inputMap).build();
         Assert.assertEquals(1, successorResponse.getSegmentsCount());
         final SegmentId resultSegmentID = successorResponse.getSegments(0).getSegment().getSegmentId();
         assertEquals("testScope", resultSegmentID.getStreamInfo().getScope());
diff --git a/client/src/test/java/io/pravega/client/stream/impl/ReaderGroupStateManagerTest.java b/client/src/test/java/io/pravega/client/stream/impl/ReaderGroupStateManagerTest.java
index c29759b..a9668f5 100644
--- a/client/src/test/java/io/pravega/client/stream/impl/ReaderGroupStateManagerTest.java
+++ b/client/src/test/java/io/pravega/client/stream/impl/ReaderGroupStateManagerTest.java
@@ -138,7 +138,7 @@ public class ReaderGroupStateManagerTest {
                 connectionFactory,
                 new StreamSegmentsWithPredecessors(
                         ImmutableMap.of(new SegmentWithRange(successorA, 0.0, 0.5), singletonList(0),
-                                        new SegmentWithRange(successorB, 0.5, 1.0), singletonList(0))));
+                                        new SegmentWithRange(successorB, 0.5, 1.0), singletonList(0)), ""));
         MockSegmentStreamFactory streamFactory = new MockSegmentStreamFactory();
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl(scope, controller, connectionFactory, streamFactory,
@@ -178,7 +178,7 @@ public class ReaderGroupStateManagerTest {
         Segment successor = new Segment(scope, stream, 2);
         MockController controller = new MockControllerWithSuccessors(endpoint.getEndpoint(), endpoint.getPort(),
                 connectionFactory, new StreamSegmentsWithPredecessors(
-                        Collections.singletonMap(new SegmentWithRange(successor, 0.0, 1.0), ImmutableList.of(0, 1))));
+                        Collections.singletonMap(new SegmentWithRange(successor, 0.0, 1.0), ImmutableList.of(0, 1)), ""));
         MockSegmentStreamFactory streamFactory = new MockSegmentStreamFactory();
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl(scope, controller, connectionFactory, streamFactory, streamFactory, streamFactory);
@@ -533,7 +533,7 @@ public class ReaderGroupStateManagerTest {
                 connectionFactory,
                 new StreamSegmentsWithPredecessors(
                         ImmutableMap.of(new SegmentWithRange(successorA, 0.0, 0.5), singletonList(0),
-                                        new SegmentWithRange(successorB, 0.5, 1.0), singletonList(0))));
+                                        new SegmentWithRange(successorB, 0.5, 1.0), singletonList(0)), ""));
         MockSegmentStreamFactory streamFactory = new MockSegmentStreamFactory();
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl(scope, controller, connectionFactory, streamFactory,
@@ -573,7 +573,7 @@ public class ReaderGroupStateManagerTest {
         Segment segment1 = new Segment(scope, stream, 1);
         Segment segment2 = new Segment(scope, stream, 2);
         MockController controller = new MockControllerWithSuccessors(endpoint.getEndpoint(), endpoint.getPort(),
-                connectionFactory, new StreamSegmentsWithPredecessors(ImmutableMap.of()));
+                connectionFactory, new StreamSegmentsWithPredecessors(ImmutableMap.of(), ""));
         MockSegmentStreamFactory streamFactory = new MockSegmentStreamFactory();
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl(scope, controller, connectionFactory, streamFactory,
@@ -611,7 +611,7 @@ public class ReaderGroupStateManagerTest {
         Segment segment1 = new Segment(scope, stream, 1);
         Segment segment2 = new Segment(scope, stream, 2);
         MockController controller = new MockControllerWithSuccessors(endpoint.getEndpoint(), endpoint.getPort(),
-                connectionFactory, new StreamSegmentsWithPredecessors(ImmutableMap.of()));
+                connectionFactory, new StreamSegmentsWithPredecessors(ImmutableMap.of(), ""));
         MockSegmentStreamFactory streamFactory = new MockSegmentStreamFactory();
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl(scope, controller, connectionFactory, streamFactory,
diff --git a/client/src/test/java/io/pravega/client/stream/impl/SecureControllerImplTest.java b/client/src/test/java/io/pravega/client/stream/impl/SecureControllerImplTest.java
new file mode 100644
index 0000000..04f1754
--- /dev/null
+++ b/client/src/test/java/io/pravega/client/stream/impl/SecureControllerImplTest.java
@@ -0,0 +1,29 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.client.stream.impl;
+
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Test;
+
+public class SecureControllerImplTest extends ControllerImplTest {
+    @Override
+    @Before
+    public void setup() throws IOException {
+        this.testSecure = true;
+        super.setup();
+    }
+
+    @Override
+    @Test
+    public void testRetries() {
+
+    }
+}
diff --git a/client/src/test/java/io/pravega/client/stream/impl/SegmentSelectorTest.java b/client/src/test/java/io/pravega/client/stream/impl/SegmentSelectorTest.java
index 297f080..fd81eff 100644
--- a/client/src/test/java/io/pravega/client/stream/impl/SegmentSelectorTest.java
+++ b/client/src/test/java/io/pravega/client/stream/impl/SegmentSelectorTest.java
@@ -41,7 +41,7 @@ public class SegmentSelectorTest {
         segments.put(0.5, new Segment(scope, streamName, 1));
         segments.put(0.75, new Segment(scope, streamName, 2));
         segments.put(1.0, new Segment(scope, streamName, 3));
-        StreamSegments streamSegments = new StreamSegments(segments);
+        StreamSegments streamSegments = new StreamSegments(segments, "");
 
         Mockito.when(controller.getCurrentSegments(scope, streamName))
                .thenReturn(CompletableFuture.completedFuture(streamSegments));
@@ -68,7 +68,7 @@ public class SegmentSelectorTest {
         segments.put(0.5, new Segment(scope, streamName, 1));
         segments.put(0.75, new Segment(scope, streamName, 2));
         segments.put(1.0, new Segment(scope, streamName, 3));
-        StreamSegments streamSegments = new StreamSegments(segments);
+        StreamSegments streamSegments = new StreamSegments(segments, "");
 
         Mockito.when(controller.getCurrentSegments(scope, streamName))
                .thenReturn(CompletableFuture.completedFuture(streamSegments));
@@ -95,7 +95,7 @@ public class SegmentSelectorTest {
         segments.put(0.5, new Segment(scope, streamName, 1));
         segments.put(0.75, new Segment(scope, streamName, 2));
         segments.put(1.0, new Segment(scope, streamName, 3));
-        StreamSegments streamSegments = new StreamSegments(segments);
+        StreamSegments streamSegments = new StreamSegments(segments, "");
 
         Mockito.when(controller.getCurrentSegments(scope, streamName))
                .thenReturn(CompletableFuture.completedFuture(streamSegments));
diff --git a/client/src/test/java/io/pravega/client/stream/impl/StreamSegmentsTest.java b/client/src/test/java/io/pravega/client/stream/impl/StreamSegmentsTest.java
index 9fc1e6a..749d0e0 100644
--- a/client/src/test/java/io/pravega/client/stream/impl/StreamSegmentsTest.java
+++ b/client/src/test/java/io/pravega/client/stream/impl/StreamSegmentsTest.java
@@ -36,7 +36,7 @@ public class StreamSegmentsTest {
         segments.put(0.5, new Segment(scope, streamName, 1));
         segments.put(0.75, new Segment(scope, streamName, 2));
         segments.put(1.0, new Segment(scope, streamName, 3));
-        StreamSegments streamSegments = new StreamSegments(segments);
+        StreamSegments streamSegments = new StreamSegments(segments, "");
         
         int[] counts = new int[4];
         Arrays.fill(counts, 0);
@@ -66,15 +66,15 @@ public class StreamSegmentsTest {
         TreeMap<Double, Segment> segments = new TreeMap<>();
         segments.put(0.5, new Segment(scope, streamName, 0));
         segments.put(1.0, new Segment(scope, streamName, 1));
-        StreamSegments streamSegments = new StreamSegments(segments);
+        StreamSegments streamSegments = new StreamSegments(segments, "");
         Map<SegmentWithRange, List<Integer>> newRange = new HashMap<>();
         newRange.put(new SegmentWithRange(new Segment(scope, streamName, 2), 0, 0.25), ImmutableList.of(0));
         newRange.put(new SegmentWithRange(new Segment(scope, streamName, 3), 0.25, 0.5), ImmutableList.of(0));
-        streamSegments = streamSegments.withReplacementRange(new StreamSegmentsWithPredecessors(newRange));
+        streamSegments = streamSegments.withReplacementRange(new StreamSegmentsWithPredecessors(newRange, ""));
         newRange = new HashMap<>();
         newRange.put(new SegmentWithRange(new Segment(scope, streamName, 4), 0.5, 0.75), ImmutableList.of(1));
         newRange.put(new SegmentWithRange(new Segment(scope, streamName, 5), 0.75, 1.0), ImmutableList.of(1));
-        streamSegments = streamSegments.withReplacementRange(new StreamSegmentsWithPredecessors(newRange));
+        streamSegments = streamSegments.withReplacementRange(new StreamSegmentsWithPredecessors(newRange, ""));
         
         int[] counts = new int[6];
         Arrays.fill(counts, 0);
@@ -98,14 +98,14 @@ public class StreamSegmentsTest {
         segments.put(0.5, new Segment(scope, streamName, 1));
         segments.put(0.75, new Segment(scope, streamName, 2));
         segments.put(1.0, new Segment(scope, streamName, 3));
-        StreamSegments streamSegments = new StreamSegments(segments);
+        StreamSegments streamSegments = new StreamSegments(segments, "");
         Map<SegmentWithRange, List<Integer>> newRange = new HashMap<>();
         newRange.put(new SegmentWithRange(new Segment(scope, streamName, 4), 0, 0.5), ImmutableList.of(0, 1));
         newRange.put(new SegmentWithRange(new Segment(scope, streamName, 5), 0.5, 1.0), ImmutableList.of(2, 3));
-        streamSegments = streamSegments.withReplacementRange(new StreamSegmentsWithPredecessors(newRange));
+        streamSegments = streamSegments.withReplacementRange(new StreamSegmentsWithPredecessors(newRange, ""));
         newRange = new HashMap<>();
         newRange.put(new SegmentWithRange(new Segment(scope, streamName, 6), 0.0, 1.0), ImmutableList.of(4, 5));
-        streamSegments = streamSegments.withReplacementRange(new StreamSegmentsWithPredecessors(newRange));
+        streamSegments = streamSegments.withReplacementRange(new StreamSegmentsWithPredecessors(newRange, ""));
         
         int[] counts = new int[7];
         Arrays.fill(counts, 0);
@@ -130,7 +130,7 @@ public class StreamSegmentsTest {
         segments.put(0.5, new Segment(scope, streamName, 1));
         segments.put(0.75, new Segment(scope, streamName, 2));
         segments.put(1.0, new Segment(scope, streamName, 3));
-        StreamSegments streamSegments = new StreamSegments(segments);
+        StreamSegments streamSegments = new StreamSegments(segments, "");
 
         int[] counts = new int[4];
         Arrays.fill(counts, 0);
diff --git a/client/src/test/java/io/pravega/client/stream/mock/MockClientFactory.java b/client/src/test/java/io/pravega/client/stream/mock/MockClientFactory.java
index b704c5b..fbbb7ea 100644
--- a/client/src/test/java/io/pravega/client/stream/mock/MockClientFactory.java
+++ b/client/src/test/java/io/pravega/client/stream/mock/MockClientFactory.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.client.stream.mock;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.batch.BatchClient;
 import io.pravega.client.batch.impl.BatchClientImpl;
@@ -35,13 +36,13 @@ public class MockClientFactory implements ClientFactory, AutoCloseable {
     private final ClientFactoryImpl impl;
 
     public MockClientFactory(String scope, MockSegmentStreamFactory ioFactory) {
-        this.connectionFactory = new ConnectionFactoryImpl(false);
+        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         this.controller = new MockController("localhost", 0, connectionFactory);
         this.impl = new ClientFactoryImpl(scope, controller, connectionFactory, ioFactory, ioFactory, ioFactory);
     }
 
     public MockClientFactory(String scope, Controller controller) {
-        this.connectionFactory = new ConnectionFactoryImpl(false);
+        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         this.controller = controller;
         this.impl = new ClientFactoryImpl(scope, controller, connectionFactory);
     }
diff --git a/client/src/test/java/io/pravega/client/stream/mock/MockController.java b/client/src/test/java/io/pravega/client/stream/mock/MockController.java
index 7cd837f..3a04199 100644
--- a/client/src/test/java/io/pravega/client/stream/mock/MockController.java
+++ b/client/src/test/java/io/pravega/client/stream/mock/MockController.java
@@ -16,16 +16,18 @@ import io.pravega.client.segment.impl.Segment;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.Stream;
 import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.StreamCut;
 import io.pravega.client.stream.Transaction;
 import io.pravega.client.stream.TxnFailedException;
 import io.pravega.client.stream.impl.CancellableRequest;
 import io.pravega.client.stream.impl.ConnectionClosedException;
 import io.pravega.client.stream.impl.Controller;
-import io.pravega.client.stream.StreamCut;
 import io.pravega.client.stream.impl.StreamImpl;
+import io.pravega.client.stream.impl.StreamSegmentSuccessors;
 import io.pravega.client.stream.impl.StreamSegments;
 import io.pravega.client.stream.impl.StreamSegmentsWithPredecessors;
 import io.pravega.client.stream.impl.TxnSegments;
+import io.pravega.common.auth.AuthenticationException;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.shared.protocol.netty.FailingReplyProcessor;
 import io.pravega.shared.protocol.netty.PravegaNodeUri;
@@ -207,8 +209,13 @@ public class MockController implements Controller {
             public void processingFailure(Exception error) {
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(new AuthenticationException(authTokenCheckFailed.toString()));
+            }
         };
-        CreateSegment command = new WireCommands.CreateSegment(idGenerator.get(), name, WireCommands.CreateSegment.NO_SCALE, 0);
+        CreateSegment command = new WireCommands.CreateSegment(idGenerator.get(), name, WireCommands.CreateSegment.NO_SCALE, 0, "");
         sendRequestOverNewConnection(command, replyProcessor, result);
         return getAndHandleExceptions(result, RuntimeException::new);
     }
@@ -241,8 +248,13 @@ public class MockController implements Controller {
             public void processingFailure(Exception error) {
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(new AuthenticationException(authTokenCheckFailed.toString()));
+            }
         };
-        DeleteSegment command = new WireCommands.DeleteSegment(idGenerator.get(), name);
+        DeleteSegment command = new WireCommands.DeleteSegment(idGenerator.get(), name, "");
         sendRequestOverNewConnection(command, replyProcessor, result);
         return getAndHandleExceptions(result, RuntimeException::new);
     }
@@ -259,7 +271,7 @@ public class MockController implements Controller {
         for (int i = 0; i < segmentsInStream.size(); i++) {
             segments.put((i + 1) * increment, new Segment(stream.getScope(), stream.getStreamName(), i));
         }
-        return new StreamSegments(segments);
+        return new StreamSegments(segments, "");
     }
 
     @Override
@@ -299,8 +311,13 @@ public class MockController implements Controller {
             public void processingFailure(Exception error) {
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(new AuthenticationException(authTokenCheckFailed.toString()));
+            }
         };
-        sendRequestOverNewConnection(new CommitTransaction(idGenerator.get(), segment.getScopedName(), txId), replyProcessor, result);
+        sendRequestOverNewConnection(new CommitTransaction(idGenerator.get(), segment.getScopedName(), txId, ""), replyProcessor, result);
         return result;
     }
 
@@ -341,8 +358,13 @@ public class MockController implements Controller {
             public void processingFailure(Exception error) {
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(new AuthenticationException(authTokenCheckFailed.toString()));
+            }
         };
-        sendRequestOverNewConnection(new AbortTransaction(idGenerator.get(), segment.getScopedName(), txId), replyProcessor, result);
+        sendRequestOverNewConnection(new AbortTransaction(idGenerator.get(), segment.getScopedName(), txId, ""), replyProcessor, result);
         return result;
     }
 
@@ -385,8 +407,13 @@ public class MockController implements Controller {
             public void processingFailure(Exception error) {
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(new AuthenticationException(authTokenCheckFailed.toString()));
+            }
         };
-        sendRequestOverNewConnection(new CreateTransaction(idGenerator.get(), segment.getScopedName(), txId), replyProcessor, result);
+        sendRequestOverNewConnection(new CreateTransaction(idGenerator.get(), segment.getScopedName(), txId, ""), replyProcessor, result);
         return result;
     }
 
@@ -402,16 +429,16 @@ public class MockController implements Controller {
     
     @Override
     public CompletableFuture<StreamSegmentsWithPredecessors> getSuccessors(Segment segment) {
-        return CompletableFuture.completedFuture(new StreamSegmentsWithPredecessors(Collections.emptyMap()));
+        return CompletableFuture.completedFuture(new StreamSegmentsWithPredecessors(Collections.emptyMap(), ""));
     }
 
     @Override
-    public CompletableFuture<Set<Segment>> getSuccessors(StreamCut from) {
+    public CompletableFuture<StreamSegmentSuccessors> getSuccessors(StreamCut from) {
         StreamConfiguration configuration = createdStreams.get(from.asImpl().getStream());
         if (configuration.getScalingPolicy().getScaleType() != ScalingPolicy.ScaleType.FIXED_NUM_SEGMENTS) {
             throw new IllegalArgumentException("getSuccessors not supported with dynamic scaling on mock controller");
         }
-        return CompletableFuture.completedFuture(Collections.emptySet());
+        return CompletableFuture.completedFuture(new StreamSegmentSuccessors(Collections.emptySet(), ""));
     }
 
     @Override
@@ -440,5 +467,10 @@ public class MockController implements Controller {
     @Override
     public void close() {
     }
+
+    @Override
+    public CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName) {
+        return CompletableFuture.completedFuture("");
+    }
 }
 
diff --git a/client/src/test/java/io/pravega/client/stream/mock/MockSegmentIoStreams.java b/client/src/test/java/io/pravega/client/stream/mock/MockSegmentIoStreams.java
index b762bc1..6a4f958 100644
--- a/client/src/test/java/io/pravega/client/stream/mock/MockSegmentIoStreams.java
+++ b/client/src/test/java/io/pravega/client/stream/mock/MockSegmentIoStreams.java
@@ -38,7 +38,7 @@ public class MockSegmentIoStreams implements SegmentOutputStream, SegmentInputSt
     @GuardedBy("$lock")
     private int readIndex; 
     @GuardedBy("$lock")
-    private long readOffset = 0; 
+    private long readOffset = 0;
     @GuardedBy("$lock")
     private int eventsWritten = 0;
     @GuardedBy("$lock")
@@ -71,7 +71,7 @@ public class MockSegmentIoStreams implements SegmentOutputStream, SegmentInputSt
 
     @Override
     @Synchronized
-    public long fetchCurrentSegmentLength() {
+    public long fetchCurrentSegmentLength(String delegationToken) {
         return writeOffset;
     }
 
@@ -152,7 +152,7 @@ public class MockSegmentIoStreams implements SegmentOutputStream, SegmentInputSt
     }
 
     @Override
-    public boolean compareAndSetAttribute(SegmentAttribute attribute, long expectedValue, long newValue) {
+    public boolean compareAndSetAttribute(SegmentAttribute attribute, long expectedValue, long newValue, String delegationToken) {
         attributes.putIfAbsent(attribute, SegmentAttribute.NULL_VALUE);
         return attributes.replace(attribute, expectedValue, newValue);
     }
@@ -163,17 +163,16 @@ public class MockSegmentIoStreams implements SegmentOutputStream, SegmentInputSt
 
     @Override
     @Synchronized
-    public SegmentInfo getSegmentInfo() {
+    public SegmentInfo getSegmentInfo(String delegationToken) {
         return new SegmentInfo(segment, startingOffset, writeOffset, false, System.currentTimeMillis());
     }
 
     @Override
     @Synchronized
-    public void truncateSegment(Segment segment, long offset) {
+    public void truncateSegment(Segment segment, long offset, String delegationToken) {
         Preconditions.checkArgument(offset <= writeOffset);
         if (offset >= startingOffset) {
             startingOffset = offset;
         }
     }
-
 }
diff --git a/client/src/test/java/io/pravega/client/stream/mock/MockSegmentStreamFactory.java b/client/src/test/java/io/pravega/client/stream/mock/MockSegmentStreamFactory.java
index c5d3b44..c476585 100644
--- a/client/src/test/java/io/pravega/client/stream/mock/MockSegmentStreamFactory.java
+++ b/client/src/test/java/io/pravega/client/stream/mock/MockSegmentStreamFactory.java
@@ -29,7 +29,7 @@ public class MockSegmentStreamFactory implements SegmentInputStreamFactory, Segm
     @Override
     public SegmentOutputStream createOutputStreamForTransaction(Segment segment, UUID txId,
                                                                 Consumer<Segment> segmentSealedCallback,
-                                                                EventWriterConfig config) {
+                                                                EventWriterConfig config, String delegationToken) {
         throw new UnsupportedOperationException();
     }
 
@@ -40,7 +40,7 @@ public class MockSegmentStreamFactory implements SegmentInputStreamFactory, Segm
     }
     
     @Override
-    public SegmentOutputStream createOutputStreamForSegment(Segment segment, Consumer<Segment> segmentSealedCallback, EventWriterConfig config) {
+    public SegmentOutputStream createOutputStreamForSegment(Segment segment, Consumer<Segment> segmentSealedCallback, EventWriterConfig config, String delegationToken) {
         return getMockStream(segment);
     }
 
diff --git a/client/src/test/java/io/pravega/client/stream/mock/MockStreamManager.java b/client/src/test/java/io/pravega/client/stream/mock/MockStreamManager.java
index 3703f03..28f1abc 100644
--- a/client/src/test/java/io/pravega/client/stream/mock/MockStreamManager.java
+++ b/client/src/test/java/io/pravega/client/stream/mock/MockStreamManager.java
@@ -10,12 +10,10 @@
 package io.pravega.client.stream.mock;
 
 import com.google.common.base.Preconditions;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
-import io.pravega.client.stream.StreamCut;
-import io.pravega.common.concurrent.Futures;
-import io.pravega.shared.NameUtils;
 import io.pravega.client.state.SynchronizerConfig;
 import io.pravega.client.stream.Position;
 import io.pravega.client.stream.ReaderGroup;
@@ -23,13 +21,16 @@ import io.pravega.client.stream.ReaderGroupConfig;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.Stream;
 import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.StreamCut;
 import io.pravega.client.stream.impl.JavaSerializer;
 import io.pravega.client.stream.impl.PositionImpl;
 import io.pravega.client.stream.impl.ReaderGroupImpl;
 import io.pravega.client.stream.impl.StreamImpl;
+import io.pravega.common.concurrent.Futures;
+import io.pravega.shared.NameUtils;
+import java.net.URI;
 import java.util.Set;
 import java.util.stream.Collectors;
-
 import lombok.Getter;
 import org.apache.commons.lang3.NotImplementedException;
 
@@ -43,7 +44,7 @@ public class MockStreamManager implements StreamManager, ReaderGroupManager {
 
     public MockStreamManager(String scope, String endpoint, int port) {
         this.scope = scope;
-        this.connectionFactory = new ConnectionFactoryImpl(false);
+        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().controllerURI(URI.create("tcp://localhost")).build());
         this.controller = new MockController(endpoint, port, connectionFactory);
         this.clientFactory = new MockClientFactory(scope, controller);
     }
diff --git a/common/src/main/java/io/pravega/common/auth/AuthenticationException.java b/common/src/main/java/io/pravega/common/auth/AuthenticationException.java
new file mode 100644
index 0000000..f645ba7
--- /dev/null
+++ b/common/src/main/java/io/pravega/common/auth/AuthenticationException.java
@@ -0,0 +1,23 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.common.auth;
+
+/**
+ * Exception thrown when there is any error during authentication/authorization.
+ */
+public class AuthenticationException extends Exception {
+    public AuthenticationException(String message) {
+        super(message);
+    }
+
+    public AuthenticationException(Exception e) {
+        super(e);
+    }
+}
diff --git a/common/src/main/java/io/pravega/common/util/ByteArraySegment.java b/common/src/main/java/io/pravega/common/util/ByteArraySegment.java
index 43f6fe0..2b5b496 100644
--- a/common/src/main/java/io/pravega/common/util/ByteArraySegment.java
+++ b/common/src/main/java/io/pravega/common/util/ByteArraySegment.java
@@ -9,10 +9,10 @@
  */
 package io.pravega.common.util;
 
+import com.google.common.base.Preconditions;
 import io.pravega.common.Exceptions;
 import io.pravega.common.io.FixedByteArrayOutputStream;
 import io.pravega.common.io.StreamHelpers;
-import com.google.common.base.Preconditions;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
diff --git a/config/cert.pem b/config/cert.pem
new file mode 100644
index 0000000..ac21b62
--- /dev/null
+++ b/config/cert.pem
@@ -0,0 +1,21 @@
+-----BEGIN CERTIFICATE-----
+MIIDhTCCAm2gAwIBAgIJAMb12qSEnpvBMA0GCSqGSIb3DQEBCwUAMFkxCzAJBgNV
+BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX
+aWRnaXRzIFB0eSBMdGQxEjAQBgNVBAMMCWxvY2FsaG9zdDAeFw0xNzExMTYyMDA1
+MTlaFw0yNzExMTQyMDA1MTlaMFkxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21l
+LVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxEjAQBgNV
+BAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALyd
+gIOR5IhkB2uLiMxrdQ/9iZVDDgVNlshjO2I127KgmfW+Zp7IkJygOugCbnoeCAF7
+0vBQtjMGmkiZF2zdzFRSN8fbebVpfo6SGcsosGXAd3dQcwZH93mGCRfKKswHvxM/
+QCo2v3m+AZ4ZzYo1w6xylKbIpZPrc3P6axNO5xWnZ8Tyy7e0x/k7mJD2EQ09QlIg
++vTVcuRjTiR033SWaVvzs1XZXGvQZ2rIVrx7BJH3d5SQci4U/ePujF5R4yNPsuQT
+0lHpdve1fPnWqR9UmguqBG2BEKDNSQr6IHZ465iZ0X90HNZ1NlUqEXxeKYz5Nphp
+tSydYjEVt1RfAqXoHYUCAwEAAaNQME4wHQYDVR0OBBYEFHEAjDPFWyKQvqZnc57V
+e9GRKt/nMB8GA1UdIwQYMBaAFHEAjDPFWyKQvqZnc57Ve9GRKt/nMAwGA1UdEwQF
+MAMBAf8wDQYJKoZIhvcNAQELBQADggEBAKYpnmV/NUWuc1E/nryPqVYsd8CJU/D0
+JW0PfflmZCLjy2x6lyBim+0HDDQ0RSmAjv6DRiUWpkFEqiosFgNOMC3tVHxNzHBB
+wVRKhIwNBDnlKINJYsZQHYE/sPtthfE1RSs1Fs16O9S2ElqQdnawZvTOG/tefwnc
+a5R8F0V2Dh2XGSFXQ+kYzmQVocDv5SjstO5qtdX47CNspZgv204Gye7D3BxGMaIk
+ahPonQ/xc/lCubbi5bcKjQUy85wIBFCMVbDMtYbBOksg1BWzAuuNq6SoMnk6OsOW
+9JRdB9NytzBVVi9oVzzFCQuqggXALofgWVAq0f0grjHlaX4uz8iwXVQ=
+-----END CERTIFICATE-----
diff --git a/config/key.pem b/config/key.pem
new file mode 100644
index 0000000..6cbe8b7
--- /dev/null
+++ b/config/key.pem
@@ -0,0 +1,28 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC8nYCDkeSIZAdr
+i4jMa3UP/YmVQw4FTZbIYztiNduyoJn1vmaeyJCcoDroAm56HggBe9LwULYzBppI
+mRds3cxUUjfH23m1aX6OkhnLKLBlwHd3UHMGR/d5hgkXyirMB78TP0AqNr95vgGe
+Gc2KNcOscpSmyKWT63Nz+msTTucVp2fE8su3tMf5O5iQ9hENPUJSIPr01XLkY04k
+dN90lmlb87NV2Vxr0GdqyFa8ewSR93eUkHIuFP3j7oxeUeMjT7LkE9JR6Xb3tXz5
+1qkfVJoLqgRtgRCgzUkK+iB2eOuYmdF/dBzWdTZVKhF8XimM+TaYabUsnWIxFbdU
+XwKl6B2FAgMBAAECggEAF6YDy/tJ1RP9ni1TjJXYipW2X2GV63JL+nn+oxSvpBjg
+1N/3i+cHwquQVzCe227SgCUfUIQ+I+2rAHk5Z6vzh4r7dXJ+MxG0DXoiA8fpPgjA
+sdQDaAEz9SeqEjKF5Sj/exFOITzWCxSYrVL841xUWVXQb4zuvboisqLuM/CLpros
+dQ2b492skWrSY7WUt7WuRnLGdcZfat3FPTDJrVzSELQLfpqeY1chNAiT71AvuKC1
+Pf5oaF77koHxpjcWJ83KXuOanyQM3bflH0sj+VvWtinftt6SpgCPIJamQb082N7z
+kSbR8and+vDPGVc3TvY/4lXuJNtOKjxjfZsaDvQPwQKBgQDjZQvb4OPZvadVBGKn
+RRD/XtCQ2Od/CTd8tYB2dbufiCm91KKkPSUfb2mV5SQ0CQ23J4/KgsSve6Px+6XM
+M8rXLx2zLp3OJljAWZg8xbQs39Nsf//KpXgaYhDiMAs417qvR8Z6CrwJ8EQzzqz8
+IQlNDJxNZnxja9MuSwfMoza6sQKBgQDUV5ziJbbHMVkjSYgHQtFCKuSXFGUtLHrK
+5GB1o8X2rI+5avcx3+yojp14GQqD3kudAw452uAGlHvylH9G+txt5VCMZ/ihoNSQ
+SWAv1Ombb6zpd9rj02q0zu1UUhighj6MLBOaXnAQXFY9kZSeiiPaMxwuZKmL6qjj
+QuWBh0DdFQKBgQDe+zIyzgeAeBpDIwa+cdqmIEqzDw+KofYYQz8SaoaufG46KO3H
+0fG6Lp1CEK18nTgm1xOIiMzoK3zriFHfuRX6Bsi/8UFramzzSaggR9pTerSvG6Ew
+DSyF6o4VzvjiJ6F3yhFVkXss379xcgRtRNQDCw+mUo49S/mM1qRyRcYgMQKBgQCS
+weblCinUbA/uapDAa/bS43BP1sHCwf4wIj1ksQdOYJ+JCBvG9bvMF51P9wakc0wR
+PZ5kcBjrk05DL0z0UsdskNPl5qoZk122R3BaPq4iRsHcLoEzethCFM5Eu+TXdVDf
+cksuIt0TAa59KRPtqw3ybeapTds8n7eQMpkKt98lrQKBgAI0laCe7/8ybeikjOqA
+eAwJssn3cdx/7ERTb+3dztZvWzF/z+PLG7fxOAI25Lh1fnsCEKCv4SI5NlV77XCp
+jxPg0+J6hUxrJFieUQfO0cfquFrOxwqgImqXA4MD3wzJaZLjAYx0SqZCefvlmrw5
+x/0Q4PXQOfrWDkzZ3hW6PmN+
+-----END PRIVATE KEY-----
diff --git a/config/passwd b/config/passwd
new file mode 100644
index 0000000..6c9e83f
--- /dev/null
+++ b/config/passwd
@@ -0,0 +1 @@
+admin:353030303a633132666135376233353937356534613430383430373939343839333733616463363433616532363238653930346230333035393666643961316264616661393a3639376330623663396634343864643262663335326463653062613965336439613864306264323839633037626166663563613166333733653631383732353134643961303435613237653130353633633031653364366565316434626534656565636335663666306465663064376165313765646263656638373764396361:*,READ_UPDATE;
diff --git a/controller/src/conf/application.conf b/controller/src/conf/application.conf
index 61e5f16..674e4a8 100644
--- a/controller/src/conf/application.conf
+++ b/controller/src/conf/application.conf
@@ -27,6 +27,21 @@ config {
     #Unique name for this cluster.
     cluster = ${CLUSTER_NAME}
 
+    #Flag to enable authorization
+    authorizationEnabled = ${AUTHORIZATION_ENABLED}
+
+    #Users and passwords settings for default Pravega authorization
+    userPasswordFile = ${USER_PASSWORD_FILE}
+
+    #TLS settings
+    tlsEnabled = ${TLS_ENABLED}
+    tlsCertFile = ${TLS_CERT_FILE}
+    tlsTrustStore = ${TLS_TRUST_STORE}
+    tlsKeyFile = ${TLS_KEY_FILE}
+
+    #Segmentstore key
+    tokenSigningKey = ${TOKEN_SIGNING_KEY}
+
     #Enable the Zookeeper based segment container monitor.
     hostMonitorEnabled = ${HOST_MONITOR_ENABLE}
 
diff --git a/controller/src/main/java/io/pravega/controller/server/ControllerService.java b/controller/src/main/java/io/pravega/controller/server/ControllerService.java
index 3ad91e6..2b27ea6 100644
--- a/controller/src/main/java/io/pravega/controller/server/ControllerService.java
+++ b/controller/src/main/java/io/pravega/controller/server/ControllerService.java
@@ -9,14 +9,16 @@
  */
 package io.pravega.controller.server;
 
+import com.google.common.base.Preconditions;
+import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.impl.ModelHelper;
 import io.pravega.common.Exceptions;
 import io.pravega.common.cluster.Cluster;
 import io.pravega.common.cluster.ClusterException;
 import io.pravega.common.concurrent.Futures;
+import io.pravega.controller.store.host.HostControllerStore;
 import io.pravega.controller.store.stream.OperationContext;
 import io.pravega.controller.store.stream.ScaleMetadata;
-import io.pravega.shared.NameUtils;
-import io.pravega.controller.store.host.HostControllerStore;
 import io.pravega.controller.store.stream.Segment;
 import io.pravega.controller.store.stream.StreamMetadataStore;
 import io.pravega.controller.store.stream.VersionedTransactionData;
@@ -36,9 +38,7 @@ import io.pravega.controller.stream.api.grpc.v1.Controller.TxnStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.UpdateStreamStatus;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.task.Stream.StreamTransactionMetadataTasks;
-import io.pravega.client.stream.StreamConfiguration;
-import io.pravega.client.stream.impl.ModelHelper;
-import com.google.common.base.Preconditions;
+import io.pravega.shared.NameUtils;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.List;
@@ -47,7 +47,6 @@ import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.stream.Collectors;
-
 import lombok.AllArgsConstructor;
 import lombok.Getter;
 import lombok.Lombok;
diff --git a/controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java b/controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java
index 6c8f38a..0982d33 100644
--- a/controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java
+++ b/controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java
@@ -11,6 +11,7 @@ package io.pravega.controller.server;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.util.concurrent.AbstractIdleService;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.common.LoggerHelpers;
@@ -25,8 +26,8 @@ import io.pravega.controller.fault.SegmentContainerMonitor;
 import io.pravega.controller.fault.UniformContainerBalancer;
 import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;
 import io.pravega.controller.server.eventProcessor.LocalController;
-import io.pravega.controller.server.retention.StreamCutService;
 import io.pravega.controller.server.rest.RESTServer;
+import io.pravega.controller.server.retention.StreamCutService;
 import io.pravega.controller.server.rpc.grpc.GRPCServer;
 import io.pravega.controller.store.checkpoint.CheckpointStore;
 import io.pravega.controller.store.checkpoint.CheckpointStoreFactory;
@@ -37,11 +38,13 @@ import io.pravega.controller.store.stream.StreamMetadataStore;
 import io.pravega.controller.store.stream.StreamStoreFactory;
 import io.pravega.controller.store.task.TaskMetadataStore;
 import io.pravega.controller.store.task.TaskStoreFactory;
-import io.pravega.controller.task.TaskSweeper;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.task.Stream.StreamTransactionMetadataTasks;
 import io.pravega.controller.task.Stream.TxnSweeper;
+import io.pravega.controller.task.TaskSweeper;
+import io.pravega.controller.util.Config;
 import java.net.InetAddress;
+import java.net.URI;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.List;
@@ -49,8 +52,6 @@ import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
-
-import io.pravega.controller.util.Config;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.curator.framework.CuratorFramework;
@@ -145,13 +146,24 @@ public class ControllerServiceStarter extends AbstractIdleService {
                 monitor.startAsync();
             }
 
-            connectionFactory = new ConnectionFactoryImpl(false);
+            ClientConfig clientConfig = ClientConfig.builder()
+                                                    .controllerURI(URI.create((serviceConfig.getGRPCServerConfig().get().isTlsEnabled() ?
+                                                                          "tls://" : "tcp://") + "localhost"))
+                                                    .trustStore(serviceConfig.getGRPCServerConfig().get().getTlsTrustStore())
+                                                    .validateHostName(false)
+                                                    .build();
+
+            connectionFactory = new ConnectionFactoryImpl(clientConfig);
             SegmentHelper segmentHelper = new SegmentHelper();
 
             streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore, taskMetadataStore,
-                    segmentHelper, controllerExecutor, host.getHostId(), connectionFactory);
+                    segmentHelper, controllerExecutor, host.getHostId(), connectionFactory,
+                    serviceConfig.getGRPCServerConfig().get().isAuthorizationEnabled(),
+                    serviceConfig.getGRPCServerConfig().get().getTokenSigningKey());
             streamTransactionMetadataTasks = new StreamTransactionMetadataTasks(streamStore,
-                    hostStore, segmentHelper, controllerExecutor, host.getHostId(), serviceConfig.getTimeoutServiceConfig(), connectionFactory);
+                    hostStore, segmentHelper, controllerExecutor, host.getHostId(), serviceConfig.getTimeoutServiceConfig(), connectionFactory,
+                    serviceConfig.getGRPCServerConfig().get().isAuthorizationEnabled(),
+                    serviceConfig.getGRPCServerConfig().get().getTokenSigningKey());
 
             streamCutService = new StreamCutService(Config.BUCKET_COUNT, host.getHostId(), streamStore, streamMetadataTasks, retentionExecutor);
             log.info("starting auto retention service asynchronously");
@@ -178,7 +190,8 @@ public class ControllerServiceStarter extends AbstractIdleService {
                     streamTransactionMetadataTasks, new SegmentHelper(), controllerExecutor, cluster);
 
             // Setup event processors.
-            setController(new LocalController(controllerService));
+            setController(new LocalController(controllerService, serviceConfig.getGRPCServerConfig().get().isAuthorizationEnabled(),
+                    serviceConfig.getGRPCServerConfig().get().getTokenSigningKey()));
 
             if (serviceConfig.getEventProcessorConfig().isPresent()) {
                 // Create ControllerEventProcessor object.
@@ -218,7 +231,11 @@ public class ControllerServiceStarter extends AbstractIdleService {
 
             // Start REST server.
             if (serviceConfig.getRestServerConfig().isPresent()) {
-                restServer = new RESTServer(controllerService, serviceConfig.getRestServerConfig().get());
+                restServer = new RESTServer(this.localController,
+                        controllerService,
+                        grpcServer.getPravegaAuthManager(),
+                        serviceConfig.getRestServerConfig().get(),
+                        connectionFactory);
                 restServer.startAsync();
                 log.info("Awaiting start of REST server");
                 restServer.awaitRunning();
diff --git a/controller/src/main/java/io/pravega/controller/server/SegmentHelper.java b/controller/src/main/java/io/pravega/controller/server/SegmentHelper.java
index b30fa48..5488ff3 100644
--- a/controller/src/main/java/io/pravega/controller/server/SegmentHelper.java
+++ b/controller/src/main/java/io/pravega/controller/server/SegmentHelper.java
@@ -15,6 +15,7 @@ import io.pravega.client.segment.impl.Segment;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.impl.ModelHelper;
 import io.pravega.common.Exceptions;
+import io.pravega.common.auth.AuthenticationException;
 import io.pravega.common.cluster.Host;
 import io.pravega.controller.store.host.HostControllerStore;
 import io.pravega.controller.stream.api.grpc.v1.Controller;
@@ -30,14 +31,13 @@ import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Supplier;
-
 import lombok.extern.slf4j.Slf4j;
 import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.apache.commons.lang3.tuple.Pair;
 
 @Slf4j
 public class SegmentHelper {
-    
+
     private final Supplier<Long> idGenerator = new AtomicLong(0)::incrementAndGet;
 
     public Controller.NodeUri getSegmentUri(final String scope,
@@ -53,7 +53,7 @@ public class SegmentHelper {
                                                     final int segmentNumber,
                                                     final ScalingPolicy policy,
                                                     final HostControllerStore hostControllerStore,
-                                                    final ConnectionFactory clientCF) {
+                                                    final ConnectionFactory clientCF, String controllerToken) {
         final CompletableFuture<Boolean> result = new CompletableFuture<>();
         final Controller.NodeUri uri = getSegmentUri(scope, stream, segmentNumber, hostControllerStore);
 
@@ -91,22 +91,29 @@ public class SegmentHelper {
                 log.error("CreateSegment {}/{}/{} threw exception", scope, stream, segmentNumber, error);
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(
+                        new WireCommandFailedException(new AuthenticationException(authTokenCheckFailed.toString()),
+                                type, WireCommandFailedException.Reason.AuthFailed));
+            }
         };
 
         Pair<Byte, Integer> extracted = extractFromPolicy(policy);
 
-        WireCommands.CreateSegment request = new WireCommands.CreateSegment(idGenerator.get(), 
-                Segment.getScopedName(scope, stream, segmentNumber), extracted.getLeft(), extracted.getRight());
+        WireCommands.CreateSegment request = new WireCommands.CreateSegment(idGenerator.get(),
+                Segment.getScopedName(scope, stream, segmentNumber), extracted.getLeft(), extracted.getRight(), controllerToken);
         sendRequestAsync(request, replyProcessor, result, clientCF, ModelHelper.encode(uri));
         return result;
     }
 
     public CompletableFuture<Boolean> truncateSegment(final String scope,
-                                                    final String stream,
-                                                    final int segmentNumber,
-                                                    final long offset,
-                                                    final HostControllerStore hostControllerStore,
-                                                    final ConnectionFactory clientCF) {
+                                                      final String stream,
+                                                      final int segmentNumber,
+                                                      final long offset,
+                                                      final HostControllerStore hostControllerStore,
+                                                      final ConnectionFactory clientCF, String delegationToken) {
         final CompletableFuture<Boolean> result = new CompletableFuture<>();
         final Controller.NodeUri uri = getSegmentUri(scope, stream, segmentNumber, hostControllerStore);
 
@@ -144,10 +151,17 @@ public class SegmentHelper {
                 log.error("truncateSegment {}/{}/{} error", scope, stream, segmentNumber, error);
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(
+                        new WireCommandFailedException(new AuthenticationException(authTokenCheckFailed.toString()),
+                                type, WireCommandFailedException.Reason.AuthFailed));
+            }
         };
 
         WireCommands.TruncateSegment request = new WireCommands.TruncateSegment(idGenerator.get(),
-                Segment.getScopedName(scope, stream, segmentNumber), offset);
+                Segment.getScopedName(scope, stream, segmentNumber), offset, delegationToken);
         sendRequestAsync(request, replyProcessor, result, clientCF, ModelHelper.encode(uri));
         return result;
     }
@@ -156,7 +170,7 @@ public class SegmentHelper {
                                                     final String stream,
                                                     final int segmentNumber,
                                                     final HostControllerStore hostControllerStore,
-                                                    final ConnectionFactory clientCF) {
+                                                    final ConnectionFactory clientCF, String delegationToken) {
         final CompletableFuture<Boolean> result = new CompletableFuture<>();
         final Controller.NodeUri uri = getSegmentUri(scope, stream, segmentNumber, hostControllerStore);
 
@@ -194,10 +208,17 @@ public class SegmentHelper {
                 log.error("deleteSegment {}/{}/{} failed", scope, stream, segmentNumber, error);
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(
+                        new WireCommandFailedException(new AuthenticationException(authTokenCheckFailed.toString()),
+                                type, WireCommandFailedException.Reason.AuthFailed));
+            }
         };
 
         WireCommands.DeleteSegment request = new WireCommands.DeleteSegment(idGenerator.get(),
-                Segment.getScopedName(scope, stream, segmentNumber));
+                Segment.getScopedName(scope, stream, segmentNumber), delegationToken);
         sendRequestAsync(request, replyProcessor, result, clientCF, ModelHelper.encode(uri));
         return result;
     }
@@ -211,13 +232,14 @@ public class SegmentHelper {
      * @param segmentNumber       number of segment to be sealed
      * @param hostControllerStore host controller store
      * @param clientCF            connection factory
+     * @param delegationToken     the token to be presented to segmentstore.
      * @return void
      */
     public CompletableFuture<Boolean> sealSegment(final String scope,
                                                   final String stream,
                                                   final int segmentNumber,
                                                   final HostControllerStore hostControllerStore,
-                                                  final ConnectionFactory clientCF) {
+                                                  final ConnectionFactory clientCF, String delegationToken) {
         final Controller.NodeUri uri = getSegmentUri(scope, stream, segmentNumber, hostControllerStore);
         final CompletableFuture<Boolean> result = new CompletableFuture<>();
         final WireCommandType type = WireCommandType.SEAL_SEGMENT;
@@ -254,10 +276,17 @@ public class SegmentHelper {
                 log.error("sealSegment {}/{}/{} failed", scope, stream, segmentNumber, error);
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(
+                        new WireCommandFailedException(new AuthenticationException(authTokenCheckFailed.toString()),
+                                type, WireCommandFailedException.Reason.AuthFailed));
+            }
         };
 
-        WireCommands.SealSegment request = new WireCommands.SealSegment(idGenerator.get(), 
-                Segment.getScopedName(scope, stream, segmentNumber));
+        WireCommands.SealSegment request = new WireCommands.SealSegment(idGenerator.get(),
+                Segment.getScopedName(scope, stream, segmentNumber), delegationToken);
         sendRequestAsync(request, replyProcessor, result, clientCF, ModelHelper.encode(uri));
         return result;
     }
@@ -267,7 +296,7 @@ public class SegmentHelper {
                                                      final int segmentNumber,
                                                      final UUID txId,
                                                      final HostControllerStore hostControllerStore,
-                                                     final ConnectionFactory clientCF) {
+                                                     final ConnectionFactory clientCF, String delegationToken) {
         final Controller.NodeUri uri = getSegmentUri(scope, stream, segmentNumber, hostControllerStore);
 
         final CompletableFuture<UUID> result = new CompletableFuture<>();
@@ -304,10 +333,17 @@ public class SegmentHelper {
                 log.error("createTransaction {}/{}/{} failed", scope, stream, segmentNumber, error);
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(
+                        new WireCommandFailedException(new AuthenticationException(authTokenCheckFailed.toString()),
+                                type, WireCommandFailedException.Reason.AuthFailed));
+            }
         };
 
-        WireCommands.CreateTransaction request = new WireCommands.CreateTransaction(idGenerator.get(), 
-                Segment.getScopedName(scope, stream, segmentNumber), txId);
+        WireCommands.CreateTransaction request = new WireCommands.CreateTransaction(idGenerator.get(),
+                Segment.getScopedName(scope, stream, segmentNumber), txId, delegationToken);
         sendRequestAsync(request, replyProcessor, result, clientCF, ModelHelper.encode(uri));
         return result;
     }
@@ -317,7 +353,7 @@ public class SegmentHelper {
                                                           final int segmentNumber,
                                                           final UUID txId,
                                                           final HostControllerStore hostControllerStore,
-                                                          final ConnectionFactory clientCF) {
+                                                          final ConnectionFactory clientCF, String delegationToken) {
         final Controller.NodeUri uri = getSegmentUri(scope, stream, segmentNumber, hostControllerStore);
 
         final CompletableFuture<TxnStatus> result = new CompletableFuture<>();
@@ -362,10 +398,18 @@ public class SegmentHelper {
                 log.error("commitTransaction {}/{}/{} failed", scope, stream, segmentNumber, error);
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(
+                        new WireCommandFailedException(new AuthenticationException(authTokenCheckFailed.toString()),
+                                type, WireCommandFailedException.Reason.AuthFailed)
+                );
+            }
         };
 
-        WireCommands.CommitTransaction request = new WireCommands.CommitTransaction(idGenerator.get(), 
-                Segment.getScopedName(scope, stream, segmentNumber), txId);
+        WireCommands.CommitTransaction request = new WireCommands.CommitTransaction(idGenerator.get(),
+                Segment.getScopedName(scope, stream, segmentNumber), txId, delegationToken);
         sendRequestAsync(request, replyProcessor, result, clientCF, ModelHelper.encode(uri));
         return result;
     }
@@ -375,7 +419,7 @@ public class SegmentHelper {
                                                          final int segmentNumber,
                                                          final UUID txId,
                                                          final HostControllerStore hostControllerStore,
-                                                         final ConnectionFactory clientCF) {
+                                                         final ConnectionFactory clientCF, String delegationToken) {
         final Controller.NodeUri uri = getSegmentUri(scope, stream, segmentNumber, hostControllerStore);
         final CompletableFuture<TxnStatus> result = new CompletableFuture<>();
         final WireCommandType type = WireCommandType.ABORT_TRANSACTION;
@@ -416,17 +460,24 @@ public class SegmentHelper {
                 log.info("abortTransaction {}/{}/{} failed", scope, stream, segmentNumber, error);
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(
+                        new WireCommandFailedException(new AuthenticationException(authTokenCheckFailed.toString()),
+                                type, WireCommandFailedException.Reason.AuthFailed));
+            }
         };
 
-        WireCommands.AbortTransaction request = new WireCommands.AbortTransaction(idGenerator.get(), 
-                Segment.getScopedName(scope, stream, segmentNumber), txId);
+        WireCommands.AbortTransaction request = new WireCommands.AbortTransaction(idGenerator.get(),
+                Segment.getScopedName(scope, stream, segmentNumber), txId, delegationToken);
         sendRequestAsync(request, replyProcessor, result, clientCF, ModelHelper.encode(uri));
         return result;
     }
 
     public CompletableFuture<Void> updatePolicy(String scope, String stream, ScalingPolicy policy,
                                                 int segmentNumber, HostControllerStore hostControllerStore,
-                                                ConnectionFactory clientCF) {
+                                                ConnectionFactory clientCF, String delegationToken) {
         final CompletableFuture<Void> result = new CompletableFuture<>();
         final Controller.NodeUri uri = getSegmentUri(scope, stream, segmentNumber, hostControllerStore);
 
@@ -456,18 +507,25 @@ public class SegmentHelper {
                 log.info("updatePolicy {}/{}/{} failed", scope, stream, segmentNumber, error);
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(
+                        new WireCommandFailedException(new AuthenticationException(authTokenCheckFailed.toString()),
+                                type, WireCommandFailedException.Reason.AuthFailed));
+            }
         };
 
         Pair<Byte, Integer> extracted = extractFromPolicy(policy);
 
-        WireCommands.UpdateSegmentPolicy request = new WireCommands.UpdateSegmentPolicy(idGenerator.get(), 
-                Segment.getScopedName(scope, stream, segmentNumber), extracted.getLeft(), extracted.getRight());
+        WireCommands.UpdateSegmentPolicy request = new WireCommands.UpdateSegmentPolicy(idGenerator.get(),
+                Segment.getScopedName(scope, stream, segmentNumber), extracted.getLeft(), extracted.getRight(), delegationToken);
         sendRequestAsync(request, replyProcessor, result, clientCF, ModelHelper.encode(uri));
         return result;
     }
 
     public CompletableFuture<WireCommands.StreamSegmentInfo> getSegmentInfo(String scope, String stream, int segmentNumber,
-                                                                            HostControllerStore hostControllerStore, ConnectionFactory clientCF) {
+                                                                            HostControllerStore hostControllerStore, ConnectionFactory clientCF, String delegationToken) {
         final CompletableFuture<WireCommands.StreamSegmentInfo> result = new CompletableFuture<>();
         final Controller.NodeUri uri = getSegmentUri(scope, stream, segmentNumber, hostControllerStore);
 
@@ -497,10 +555,17 @@ public class SegmentHelper {
                 log.error("getSegmentInfo {}/{}/{} failed", scope, stream, segmentNumber, error);
                 result.completeExceptionally(error);
             }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                result.completeExceptionally(
+                        new WireCommandFailedException(new AuthenticationException(authTokenCheckFailed.toString()),
+                                type, WireCommandFailedException.Reason.AuthFailed));
+            }
         };
 
         WireCommands.GetStreamSegmentInfo request = new WireCommands.GetStreamSegmentInfo(idGenerator.get(),
-                Segment.getScopedName(scope, stream, segmentNumber));
+                Segment.getScopedName(scope, stream, segmentNumber), delegationToken);
         sendRequestAsync(request, replyProcessor, result, clientCF, ModelHelper.encode(uri));
         return result;
     }
diff --git a/controller/src/main/java/io/pravega/controller/server/WireCommandFailedException.java b/controller/src/main/java/io/pravega/controller/server/WireCommandFailedException.java
index b9d81a6..838b1cf 100644
--- a/controller/src/main/java/io/pravega/controller/server/WireCommandFailedException.java
+++ b/controller/src/main/java/io/pravega/controller/server/WireCommandFailedException.java
@@ -22,6 +22,7 @@ public class WireCommandFailedException extends RuntimeException implements Retr
         ConnectionFailed,
         UnknownHost,
         PreconditionFailed,
+        AuthFailed,
     }
 
     private final WireCommandType type;
diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/CommitEventProcessor.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/CommitEventProcessor.java
index 282bddb..b418389 100644
--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/CommitEventProcessor.java
+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/CommitEventProcessor.java
@@ -24,14 +24,13 @@ import io.pravega.controller.stream.api.grpc.v1.Controller;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.task.Stream.WriteFailedException;
 import io.pravega.shared.controller.event.CommitEvent;
-import lombok.extern.slf4j.Slf4j;
-
 import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.stream.Collectors;
+import lombok.extern.slf4j.Slf4j;
 
 /**
  * This actor processes commit txn events.
@@ -99,7 +98,7 @@ public class CommitEventProcessor extends EventProcessor<CommitEvent> {
                 return CompletableFuture.completedFuture(null);
             } else if (epoch == pair.getKey()) {
                 // If the transaction's epoch is same as the stream's current epoch, commit it.
-                return completeCommit(scope, stream, epoch, txnId, context);
+                return completeCommit(scope, stream, epoch, txnId, context, this.streamMetadataTasks.retrieveDelegationToken());
             } else {
                 // Otherwise, postpone commit operation until the stream transitions to next epoch.
                 return postponeCommitEvent(event);
@@ -120,12 +119,12 @@ public class CommitEventProcessor extends EventProcessor<CommitEvent> {
                                                    final String stream,
                                                    final int epoch,
                                                    final UUID txnId,
-                                                   final OperationContext context) {
+                                                   final OperationContext context, String delegationToken) {
         return streamMetadataStore.getActiveSegmentIds(scope, stream, epoch, context, executor)
-                .thenComposeAsync(segments -> notifyCommitToHost(scope, stream, segments, txnId).thenComposeAsync(x ->
+                .thenComposeAsync(segments -> notifyCommitToHost(scope, stream, segments, txnId, delegationToken).thenComposeAsync(x ->
                         streamMetadataStore.commitTransaction(scope, stream, epoch, txnId, context, executor), executor)
-                        .thenApply(x -> null))
-                .thenCompose(x -> Futures.toVoid(streamMetadataTasks.tryCompleteScale(scope, stream, epoch, context)));
+                                                                                                                 .thenApply(x -> null))
+                .thenCompose(x -> Futures.toVoid(streamMetadataTasks.tryCompleteScale(scope, stream, epoch, context, delegationToken)));
     }
 
     private CompletableFuture<Void> postponeCommitEvent(CommitEvent event) {
@@ -150,18 +149,18 @@ public class CommitEventProcessor extends EventProcessor<CommitEvent> {
     }
 
     private CompletableFuture<Void> notifyCommitToHost(final String scope, final String stream,
-                                                       final List<Integer> segments, final UUID txnId) {
+                                                       final List<Integer> segments, final UUID txnId, String delegationToken) {
         return Futures.allOf(segments.stream()
                                      .parallel()
-                                     .map(segment -> notifyCommitToHost(scope, stream, segment, txnId))
+                                     .map(segment -> notifyCommitToHost(scope, stream, segment, txnId, delegationToken))
                                      .collect(Collectors.toList()));
     }
 
     private CompletableFuture<Controller.TxnStatus> notifyCommitToHost(final String scope, final String stream,
-                                                                       final int segment, final UUID txId) {
+                                                                       final int segment, final UUID txId, String delegationToken) {
         String failureMessage = String.format("Transaction = %s, error sending commit notification for segment %d",
                 txId, segment);
         return Retry.indefinitelyWithExpBackoff(failureMessage).runAsync(() -> segmentHelper.commitTransaction(scope,
-                stream, segment, txId, this.hostControllerStore, this.connectionFactory), executor);
+                stream, segment, txId, this.hostControllerStore, this.connectionFactory, delegationToken), executor);
     }
 }
diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/LocalController.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/LocalController.java
index 4b5eecd..ef3b596 100644
--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/LocalController.java
+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/LocalController.java
@@ -21,33 +21,39 @@ import io.pravega.client.stream.impl.Controller;
 import io.pravega.client.stream.impl.ControllerFailureException;
 import io.pravega.client.stream.impl.ModelHelper;
 import io.pravega.client.stream.impl.SegmentWithRange;
+import io.pravega.client.stream.impl.StreamSegmentSuccessors;
 import io.pravega.client.stream.impl.StreamSegments;
 import io.pravega.client.stream.impl.StreamSegmentsWithPredecessors;
 import io.pravega.client.stream.impl.TxnSegments;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.controller.server.ControllerService;
+import io.pravega.controller.server.rpc.auth.PravegaInterceptor;
 import io.pravega.controller.stream.api.grpc.v1.Controller.PingTxnStatus;
-import io.pravega.controller.stream.api.grpc.v1.Controller.SegmentRange;
 import io.pravega.controller.stream.api.grpc.v1.Controller.ScaleResponse;
+import io.pravega.controller.stream.api.grpc.v1.Controller.SegmentRange;
 import io.pravega.shared.protocol.netty.PravegaNodeUri;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.NavigableMap;
-import java.util.Set;
 import java.util.TreeMap;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.stream.Collectors;
 import org.apache.commons.lang3.NotImplementedException;
+import org.apache.commons.lang3.StringUtils;
 
 public class LocalController implements Controller {
 
     private ControllerService controller;
+    private final String tokenSigningKey;
+    private final boolean authorizationEnabled;
 
-    public LocalController(ControllerService controller) {
+    public LocalController(ControllerService controller, boolean authorizationEnabled, String tokenSigningKey) {
         this.controller = controller;
+        this.tokenSigningKey = tokenSigningKey;
+        this.authorizationEnabled = authorizationEnabled;
     }
 
     @Override
@@ -277,7 +283,7 @@ public class LocalController implements Controller {
         for (SegmentRange r : ranges) {
             rangeMap.put(r.getMaxKey(), ModelHelper.encode(r.getSegmentId()));
         }
-        return new StreamSegments(rangeMap);
+        return new StreamSegments(rangeMap, retrieveDelegationToken());
     }
 
     @Override
@@ -331,12 +337,12 @@ public class LocalController implements Controller {
                 .thenApply(x -> {
                     Map<SegmentWithRange, List<Integer>> map = new HashMap<>();
                     x.forEach((segmentId, list) -> map.put(ModelHelper.encode(segmentId), list));
-                    return new StreamSegmentsWithPredecessors(map);
+                    return new StreamSegmentsWithPredecessors(map, retrieveDelegationToken());
                 });
     }
 
     @Override
-    public CompletableFuture<Set<Segment>> getSuccessors(StreamCut from) {
+    public CompletableFuture<StreamSegmentSuccessors> getSuccessors(StreamCut from) {
         throw new NotImplementedException("getSuccessors");
     }
 
@@ -355,4 +361,21 @@ public class LocalController implements Controller {
     @Override
     public void close() {
     }
+
+    public String retrieveDelegationToken() {
+        if (authorizationEnabled) {
+            return PravegaInterceptor.retrieveDelegationToken(tokenSigningKey);
+        } else {
+            return StringUtils.EMPTY;
+        }
+    }
+
+    @Override
+    public CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName) {
+        String retVal = "";
+        if (authorizationEnabled) {
+            retVal = PravegaInterceptor.retrieveDelegationToken(tokenSigningKey);
+        }
+        return CompletableFuture.completedFuture(retVal);
+    }
 }
diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbortRequestHandler.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbortRequestHandler.java
index 96ab005..edddf0e 100755
--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbortRequestHandler.java
+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbortRequestHandler.java
@@ -10,6 +10,7 @@
 package io.pravega.controller.server.eventProcessor.requesthandlers;
 
 import com.google.common.annotations.VisibleForTesting;
+import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.common.util.Retry;
 import io.pravega.controller.eventProcessor.impl.SerializedRequestHandler;
@@ -19,16 +20,14 @@ import io.pravega.controller.store.host.HostControllerStore;
 import io.pravega.controller.store.stream.OperationContext;
 import io.pravega.controller.store.stream.StreamMetadataStore;
 import io.pravega.controller.stream.api.grpc.v1.Controller;
-import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.shared.controller.event.AbortEvent;
-import lombok.extern.slf4j.Slf4j;
-
 import java.util.UUID;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.stream.Collectors;
+import lombok.extern.slf4j.Slf4j;
 
 /**
  * This actor processes commit txn events.
@@ -97,7 +96,8 @@ public class AbortRequestHandler extends SerializedRequestHandler<AbortEvent> {
                                         .map(segment -> notifyAbortToHost(scope, stream, segment, txId))
                                         .collect(Collectors.toList())))
                 .thenCompose(x -> streamMetadataStore.abortTransaction(scope, stream, epoch, txId, context, executor))
-                .thenCompose(x -> Futures.toVoid(streamMetadataTasks.tryCompleteScale(scope, stream, epoch, context)))
+                .thenCompose(x -> Futures.toVoid(streamMetadataTasks.tryCompleteScale(scope, stream, epoch, context,
+                        this.streamMetadataTasks.retrieveDelegationToken())))
                 .whenComplete((result, error) -> {
                     if (error != null) {
                         log.error("Failed aborting transaction {} on stream {}/{}", event.getTxid(),
@@ -126,6 +126,8 @@ public class AbortRequestHandler extends SerializedRequestHandler<AbortEvent> {
                         segmentNumber,
                         txId,
                         this.hostControllerStore,
-                        this.connectionFactory), executor);
+                        this.connectionFactory,
+                        this.streamMetadataTasks.retrieveDelegationToken()),
+                        executor);
     }
 }
diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java
index 581ef34..4bb010b 100644
--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java
+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java
@@ -16,11 +16,10 @@ import io.pravega.controller.store.stream.StoreException;
 import io.pravega.controller.store.stream.StreamMetadataStore;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.shared.controller.event.DeleteStreamEvent;
-import lombok.extern.slf4j.Slf4j;
-
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.ScheduledExecutorService;
+import lombok.extern.slf4j.Slf4j;
 
 /**
  * Request handler for performing scale operations received from requeststream.
@@ -72,7 +71,7 @@ public class DeleteStreamTask implements StreamTask<DeleteStreamEvent> {
         log.info("{}/{} deleting segments", scope, stream);
         return streamMetadataStore.getSegmentCount(scope, stream, context, executor)
                 .thenComposeAsync(count ->
-                        streamMetadataTasks.notifyDeleteSegments(scope, stream, count)
+                        streamMetadataTasks.notifyDeleteSegments(scope, stream, count, streamMetadataTasks.retrieveDelegationToken())
                             .thenComposeAsync(x -> streamMetadataStore.removeStreamFromAutoStreamCut(scope, stream, context,
                                 executor), executor)
                             .thenComposeAsync(x -> streamMetadataStore.deleteStream(scope, stream, context,
diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java
index a1939cc..6dc9a4b 100644
--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java
+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java
@@ -16,10 +16,9 @@ import io.pravega.controller.store.stream.OperationContext;
 import io.pravega.controller.store.stream.StreamMetadataStore;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.shared.controller.event.ScaleOpEvent;
-import lombok.extern.slf4j.Slf4j;
-
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
+import lombok.extern.slf4j.Slf4j;
 
 /**
  * Request handler for performing scale operations received from requeststream.
@@ -50,7 +49,8 @@ public class ScaleOperationTask implements StreamTask<ScaleOpEvent> {
         log.info("starting scale request for {}/{} segments {} to new ranges {}", request.getScope(), request.getStream(),
                 request.getSegmentsToSeal(), request.getNewRanges());
 
-        streamMetadataTasks.startScale(request, request.isRunOnlyIfStarted(), context)
+        streamMetadataTasks.startScale(request, request.isRunOnlyIfStarted(), context,
+                this.streamMetadataTasks.retrieveDelegationToken())
                 .whenCompleteAsync((res, e) -> {
                     if (e != null) {
                         Throwable cause = Exceptions.unwrap(e);
diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/SealStreamTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/SealStreamTask.java
index f0363f9..c3fb6e5 100644
--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/SealStreamTask.java
+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/SealStreamTask.java
@@ -17,13 +17,12 @@ import io.pravega.controller.store.stream.StreamMetadataStore;
 import io.pravega.controller.store.stream.tables.State;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.shared.controller.event.SealStreamEvent;
-import lombok.extern.slf4j.Slf4j;
-
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.stream.Collectors;
+import lombok.extern.slf4j.Slf4j;
 
 /**
  * Request handler for performing scale operations received from requeststream.
@@ -76,8 +75,9 @@ public class SealStreamTask implements StreamTask<SealStreamEvent> {
     private CompletionStage<Void> notifySealed(String scope, String stream, OperationContext context, List<Segment> activeSegments) {
         List<Integer> segmentsToBeSealed = activeSegments.stream().map(Segment::getNumber).
                 collect(Collectors.toList());
-        log.info("Sending notification to segment store to seal segments for stream {}/{}", scope, stream);
-        return streamMetadataTasks.notifySealedSegments(scope, stream, segmentsToBeSealed)
+        log.debug("Sending notification to segment store to seal segments for stream {}/{}", scope, stream);
+        return streamMetadataTasks.notifySealedSegments(scope, stream, segmentsToBeSealed,
+                this.streamMetadataTasks.retrieveDelegationToken())
                 .thenCompose(v -> setSealed(scope, stream, context));
     }
 
diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/TruncateStreamTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/TruncateStreamTask.java
index 7e4248c..484c5c0 100644
--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/TruncateStreamTask.java
+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/TruncateStreamTask.java
@@ -58,34 +58,35 @@ public class TruncateStreamTask implements StreamTask<TruncateStreamEvent> {
                     if (!property.isUpdating()) {
                         throw new TaskExceptions.StartException("Truncate Stream not started yet.");
                     } else {
-                        return processTruncate(scope, stream, property.getProperty(), context);
+                        return processTruncate(scope, stream, property.getProperty(), context,
+                                this.streamMetadataTasks.retrieveDelegationToken());
                     }
                 });
     }
 
     private CompletableFuture<Void> processTruncate(String scope, String stream, StreamTruncationRecord truncationRecord,
-                                                    OperationContext context) {
+                                                    OperationContext context, String delegationToken) {
         log.info("Truncating stream {}/{} at stream cut: {}", scope, stream, truncationRecord.getStreamCut());
         return Futures.toVoid(streamMetadataStore.setState(scope, stream, State.TRUNCATING, context, executor)
-                 .thenCompose(x -> notifyTruncateSegments(scope, stream, truncationRecord.getStreamCut()))
-                 .thenCompose(x -> notifyDeleteSegments(scope, stream, truncationRecord.getToDelete()))
+                 .thenCompose(x -> notifyTruncateSegments(scope, stream, truncationRecord.getStreamCut(), delegationToken))
+                 .thenCompose(x -> notifyDeleteSegments(scope, stream, truncationRecord.getToDelete(), delegationToken))
                  .thenCompose(deleted -> streamMetadataStore.completeTruncation(scope, stream, context, executor))
                  .thenCompose(x -> streamMetadataStore.setState(scope, stream, State.ACTIVE, context, executor)));
     }
 
-    private CompletableFuture<Void> notifyDeleteSegments(String scope, String stream, Set<Integer> segmentsToDelete) {
-        log.info("{}/{} deleting segments {}", scope, stream, segmentsToDelete);
+    private CompletableFuture<Void> notifyDeleteSegments(String scope, String stream, Set<Integer> segmentsToDelete, String delegationToken) {
+        log.debug("{}/{} deleting segments {}", scope, stream, segmentsToDelete);
         return Futures.allOf(segmentsToDelete.stream()
                 .parallel()
-                .map(segment -> streamMetadataTasks.notifyDeleteSegment(scope, stream, segment))
+                .map(segment -> streamMetadataTasks.notifyDeleteSegment(scope, stream, segment, delegationToken))
                 .collect(Collectors.toList()));
     }
 
-    private CompletableFuture<Void> notifyTruncateSegments(String scope, String stream, Map<Integer, Long> streamCut) {
-        log.info("{}/{} truncating segments", scope, stream);
+    private CompletableFuture<Void> notifyTruncateSegments(String scope, String stream, Map<Integer, Long> streamCut, String delegationToken) {
+        log.debug("{}/{} truncating segments", scope, stream);
         return Futures.allOf(streamCut.entrySet().stream()
                 .parallel()
-                .map(segmentCut -> streamMetadataTasks.notifyTruncateSegment(scope, stream, segmentCut))
+                .map(segmentCut -> streamMetadataTasks.notifyTruncateSegment(scope, stream, segmentCut, delegationToken))
                 .collect(Collectors.toList()));
     }
 
diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/UpdateStreamTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/UpdateStreamTask.java
index f1acf1e..6c1acc6 100644
--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/UpdateStreamTask.java
+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/UpdateStreamTask.java
@@ -18,11 +18,10 @@ import io.pravega.controller.store.stream.StreamProperty;
 import io.pravega.controller.store.stream.tables.State;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.shared.controller.event.UpdateStreamEvent;
-import lombok.extern.slf4j.Slf4j;
-
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.ScheduledExecutorService;
+import lombok.extern.slf4j.Slf4j;
 
 /**
  * Request handler for performing scale operations received from requeststream.
@@ -80,7 +79,8 @@ public class UpdateStreamTask implements StreamTask<UpdateStreamEvent> {
 
     private CompletableFuture<Boolean> notifyPolicyUpdate(OperationContext context, String scope, String stream, StreamConfiguration newConfig) {
         return streamMetadataStore.getActiveSegments(scope, stream, context, executor)
-                .thenCompose(activeSegments -> streamMetadataTasks.notifyPolicyUpdates(scope, stream, activeSegments, newConfig.getScalingPolicy()))
+                .thenCompose(activeSegments -> streamMetadataTasks.notifyPolicyUpdates(scope, stream, activeSegments, newConfig.getScalingPolicy(),
+                        this.streamMetadataTasks.retrieveDelegationToken()))
                 .handle((res, ex) -> {
                     if (ex == null) {
                         return true;
diff --git a/controller/src/main/java/io/pravega/controller/server/rest/RESTServer.java b/controller/src/main/java/io/pravega/controller/server/rest/RESTServer.java
index 5943e4d..dd7df0d 100644
--- a/controller/src/main/java/io/pravega/controller/server/rest/RESTServer.java
+++ b/controller/src/main/java/io/pravega/controller/server/rest/RESTServer.java
@@ -9,27 +9,26 @@
  */
 package io.pravega.controller.server.rest;
 
+import com.google.common.util.concurrent.AbstractIdleService;
+import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.common.LoggerHelpers;
+import io.pravega.controller.server.ControllerService;
+import io.pravega.controller.server.eventProcessor.LocalController;
 import io.pravega.controller.server.rest.resources.PingImpl;
 import io.pravega.controller.server.rest.resources.StreamMetadataResourceImpl;
-import io.pravega.controller.server.ControllerService;
-
+import io.pravega.controller.server.rpc.auth.PravegaAuthManager;
 import java.net.URI;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-
 import javax.ws.rs.core.UriBuilder;
-
-import com.google.common.util.concurrent.AbstractIdleService;
+import lombok.extern.slf4j.Slf4j;
 import org.glassfish.grizzly.GrizzlyFuture;
 import org.glassfish.grizzly.http.server.HttpServer;
 import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.server.ServerProperties;
 
-import lombok.extern.slf4j.Slf4j;
-
 /**
  * Netty REST server implementation.
  */
@@ -42,7 +41,7 @@ public class RESTServer extends AbstractIdleService {
     private final ResourceConfig resourceConfig;
     private HttpServer httpServer;
 
-    public RESTServer(ControllerService controllerService, RESTServerConfig restServerConfig) {
+    public RESTServer(LocalController localController, ControllerService controllerService, PravegaAuthManager pravegaAuthManager, RESTServerConfig restServerConfig, ConnectionFactory connectionFactory) {
         this.objectId = "RESTServer";
         this.restServerConfig = restServerConfig;
         final String serverURI = "http://" + restServerConfig.getHost() + "/";
@@ -50,7 +49,7 @@ public class RESTServer extends AbstractIdleService {
 
         final Set<Object> resourceObjs = new HashSet<>();
         resourceObjs.add(new PingImpl());
-        resourceObjs.add(new StreamMetadataResourceImpl(controllerService));
+        resourceObjs.add(new StreamMetadataResourceImpl(localController, controllerService, pravegaAuthManager, connectionFactory));
 
         final ControllerApplication controllerApplication = new ControllerApplication(resourceObjs);
         this.resourceConfig = ResourceConfig.forApplication(controllerApplication);
diff --git a/controller/src/main/java/io/pravega/controller/server/rest/resources/StreamMetadataResourceImpl.java b/controller/src/main/java/io/pravega/controller/server/rest/resources/StreamMetadataResourceImpl.java
index 10c037e..547bd10 100644
--- a/controller/src/main/java/io/pravega/controller/server/rest/resources/StreamMetadataResourceImpl.java
+++ b/controller/src/main/java/io/pravega/controller/server/rest/resources/StreamMetadataResourceImpl.java
@@ -9,14 +9,19 @@
  */
 package io.pravega.controller.server.rest.resources;
 
+import io.pravega.auth.AuthHandler;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
-import io.pravega.client.netty.impl.ConnectionFactoryImpl;
+import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.stream.InvalidStreamException;
 import io.pravega.client.stream.ReaderGroup;
+import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.client.stream.impl.ClientFactoryImpl;
 import io.pravega.common.LoggerHelpers;
+import io.pravega.common.auth.AuthenticationException;
+import io.pravega.controller.server.ControllerService;
 import io.pravega.controller.server.eventProcessor.LocalController;
+import io.pravega.controller.server.rest.ModelHelper;
 import io.pravega.controller.server.rest.generated.model.CreateScopeRequest;
 import io.pravega.controller.server.rest.generated.model.CreateStreamRequest;
 import io.pravega.controller.server.rest.generated.model.ReaderGroupProperty;
@@ -27,30 +32,33 @@ import io.pravega.controller.server.rest.generated.model.ScopesList;
 import io.pravega.controller.server.rest.generated.model.StreamState;
 import io.pravega.controller.server.rest.generated.model.StreamsList;
 import io.pravega.controller.server.rest.generated.model.UpdateStreamRequest;
-import io.pravega.controller.store.stream.ScaleMetadata;
-import io.pravega.shared.NameUtils;
-import io.pravega.controller.server.rest.ModelHelper;
 import io.pravega.controller.server.rest.v1.ApiV1;
-import io.pravega.controller.server.ControllerService;
+import io.pravega.controller.server.rpc.auth.PravegaAuthManager;
+import io.pravega.controller.store.stream.ScaleMetadata;
+import io.pravega.controller.store.stream.StoreException;
 import io.pravega.controller.stream.api.grpc.v1.Controller.CreateScopeStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.CreateStreamStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.DeleteScopeStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.DeleteStreamStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.UpdateStreamStatus;
-import io.pravega.controller.store.stream.StoreException;
-import io.pravega.client.stream.StreamConfiguration;
-import lombok.extern.slf4j.Slf4j;
-
-import javax.ws.rs.container.AsyncResponse;
-import javax.ws.rs.core.Response;
-import javax.ws.rs.core.Response.Status;
-import javax.ws.rs.core.SecurityContext;
-
+import io.pravega.shared.NameUtils;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.CompletableFuture;
+import java.util.stream.Collectors;
+import javax.ws.rs.container.AsyncResponse;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Response.Status;
+import javax.ws.rs.core.SecurityContext;
+import lombok.extern.slf4j.Slf4j;
 
+import static io.pravega.auth.AuthHandler.Permissions.READ;
+import static io.pravega.auth.AuthHandler.Permissions.READ_UPDATE;
 import static io.pravega.shared.NameUtils.INTERNAL_NAME_PREFIX;
 import static io.pravega.shared.NameUtils.READER_GROUP_STREAM_PREFIX;
 
@@ -60,10 +68,19 @@ import static io.pravega.shared.NameUtils.READER_GROUP_STREAM_PREFIX;
 @Slf4j
 public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
 
+    @Context
+    HttpHeaders headers;
+
     private final ControllerService controllerService;
+    private final PravegaAuthManager pravegaAuthManager;
+    private final LocalController localController;
+    private final ConnectionFactory connectionFactory;
 
-    public StreamMetadataResourceImpl(ControllerService controllerService) {
+    public StreamMetadataResourceImpl(LocalController localController, ControllerService controllerService, PravegaAuthManager pravegaAuthManager, ConnectionFactory connectionFactory) {
+        this.localController = localController;
         this.controllerService = controllerService;
+        this.pravegaAuthManager = pravegaAuthManager;
+        this.connectionFactory = connectionFactory;
     }
 
     /**
@@ -86,6 +103,15 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
             return;
         }
 
+        try {
+            authenticate(createScopeRequest.getScopeName(), READ_UPDATE);
+        } catch (AuthenticationException e) {
+            log.warn("Create scope for {} failed due to authentication failure {}.", createScopeRequest.getScopeName(), e);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "createScope", traceId);
+            return;
+        }
+
         controllerService.createScope(createScopeRequest.getScopeName()).thenApply(scopeStatus -> {
             if (scopeStatus.getStatus() == CreateScopeStatus.Status.SUCCESS) {
                 log.info("Successfully created new scope: {}", createScopeRequest.getScopeName());
@@ -105,6 +131,25 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
         .thenAccept(x -> LoggerHelpers.traceLeave(log, "createScope", traceId));
     }
 
+    private void authenticate(String resourceName, AuthHandler.Permissions level) throws AuthenticationException {
+        if (pravegaAuthManager != null ) {
+            Map<String, String> map = null;
+            List<String> authParams = headers.getRequestHeader(HttpHeaders.AUTHORIZATION);
+
+            if (authParams == null || authParams.isEmpty()) {
+                throw new AuthenticationException("Auth failed for " + resourceName);
+            }
+
+            String authHeader = authParams.get(0);
+            map = Arrays.stream(authHeader.split(",")).map(str -> str.split(":"))
+                                            .collect(Collectors.toMap(e -> e[0], e -> e[1]));
+
+            if (!pravegaAuthManager.authenticate(resourceName, map, level)) {
+                throw new AuthenticationException("Auth failed for " + resourceName);
+            }
+        }
+    }
+
     /**
      * Implementation of createStream REST API.
      *
@@ -126,6 +171,16 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
             LoggerHelpers.traceLeave(log, "createStream", traceId);
             return;
         }
+
+        try {
+            authenticate(scopeName + "/" + createStreamRequest.getStreamName(), READ_UPDATE);
+        } catch (AuthenticationException e) {
+            log.warn("Create stream for {} failed due to authentication failure.", createStreamRequest.getStreamName());
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "createStream", traceId);
+            return;
+        }
+
         StreamConfiguration streamConfiguration = ModelHelper.getCreateStreamConfig(createStreamRequest, scopeName);
         controllerService.createStream(streamConfiguration, System.currentTimeMillis())
                 .thenApply(streamStatus -> {
@@ -168,6 +223,15 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
             final AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "deleteScope");
 
+        try {
+            authenticate(scopeName, READ_UPDATE);
+        } catch (AuthenticationException e) {
+            log.warn("Delete scope for {} failed due to authentication failure.", scopeName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "createStream", traceId);
+            return;
+        }
+
         controllerService.deleteScope(scopeName).thenApply(scopeStatus -> {
             if (scopeStatus.getStatus() == DeleteScopeStatus.Status.SUCCESS) {
                 log.info("Successfully deleted scope: {}", scopeName);
@@ -202,6 +266,15 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
             final AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "deleteStream");
 
+        try {
+            authenticate(scopeName + "/" + streamName, READ_UPDATE);
+        } catch (AuthenticationException e) {
+            log.warn("Delete stream for {} failed due to authentication failure.", streamName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "deleteStream", traceId);
+            return;
+        }
+
         controllerService.deleteStream(scopeName, streamName).thenApply(deleteStreamStatus -> {
           if (deleteStreamStatus.getStatus() == DeleteStreamStatus.Status.SUCCESS) {
               log.info("Successfully deleted stream: {}", streamName);
@@ -228,9 +301,17 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
                                final SecurityContext securityContext, final AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "getReaderGroup");
 
-        LocalController controller = new LocalController(controllerService);
-        ReaderGroupManager readerGroupManager = new ReaderGroupManagerImpl(scopeName, controller,
-                new ClientFactoryImpl(scopeName, controller), new ConnectionFactoryImpl(false));
+        try {
+            authenticate(scopeName + "/" + readerGroupName, READ);
+        } catch (AuthenticationException e) {
+            log.warn("Get reader group for {} failed due to authentication failure.", scopeName + "/" + readerGroupName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "getReaderGroup", traceId);
+            return;
+        }
+
+        ReaderGroupManager readerGroupManager = new ReaderGroupManagerImpl(scopeName, this.localController,
+                new ClientFactoryImpl(scopeName, this.localController), this.connectionFactory);
         ReaderGroupProperty readerGroupProperty = new ReaderGroupProperty();
         readerGroupProperty.setScopeName(scopeName);
         readerGroupProperty.setReaderGroupName(readerGroupName);
@@ -267,6 +348,15 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
                          final AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "getScope");
 
+        try {
+            authenticate(scopeName, READ);
+        } catch (AuthenticationException e) {
+            log.warn("Get scope for {} failed due to authentication failure.", scopeName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "getScope", traceId);
+            return;
+        }
+
         controllerService.getScope(scopeName)
                 .thenApply(scope -> {
                         return Response.status(Status.OK).entity(new ScopeProperty().scopeName(scope)).build();
@@ -296,6 +386,15 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
             final AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "getStream");
 
+        try {
+            authenticate(scopeName + "/" + streamName, READ);
+        } catch (AuthenticationException e) {
+            log.warn("Get stream for {} failed due to authentication failure.", scopeName + "/" + streamName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "getStream", traceId);
+            return;
+        }
+
         controllerService.getStream(scopeName, streamName)
                 .thenApply(streamConfig -> Response.status(Status.OK)
                         .entity(ModelHelper.encodeStreamResponse(streamConfig))
@@ -318,6 +417,15 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
                                  final AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "listReaderGroups");
 
+        try {
+            authenticate(scopeName, READ);
+        } catch (AuthenticationException e) {
+            log.warn("Get reader groups for {} failed due to authentication failure.", scopeName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "listReaderGroups", traceId);
+            return;
+        }
+
         // Each reader group is represented by a stream within the mentioned scope.
         controllerService.listStreamsInScope(scopeName)
                 .thenApply(streamsList -> {
@@ -379,6 +487,14 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
                             final SecurityContext securityContext, final AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "listStreams");
 
+        try {
+            authenticate(scopeName, READ);
+        } catch (AuthenticationException e) {
+            log.warn("List streams for {} failed due to authentication failure.", scopeName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "listStreams", traceId);
+            return;
+        }
         boolean showOnlyInternalStreams = showInternalStreams != null && showInternalStreams.equals("true");
         controllerService.listStreamsInScope(scopeName)
                 .thenApply(streamsList -> {
@@ -420,6 +536,15 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
             final AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "updateStream");
 
+        try {
+            authenticate(scopeName + "/" + streamName, READ_UPDATE);
+        } catch (AuthenticationException e) {
+            log.warn("Update stream for {} failed due to authentication failure.", scopeName + "/" + streamName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "Update stream", traceId);
+            return;
+        }
+
         StreamConfiguration streamConfiguration = ModelHelper.getUpdateStreamConfig(
                 updateStreamRequest, scopeName, streamName);
         controllerService.updateStream(streamConfiguration).thenApply(streamStatus -> {
@@ -456,6 +581,15 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
             final StreamState updateStreamStateRequest, SecurityContext securityContext, AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "updateStreamState");
 
+        try {
+            authenticate(scopeName + "/" + streamName, READ_UPDATE);
+        } catch (AuthenticationException e) {
+            log.warn("Update stream for {} failed due to authentication failure.", scopeName + "/" + streamName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "Update stream", traceId);
+            return;
+        }
+
         // We only support sealed state now.
         if (updateStreamStateRequest.getStreamState() != StreamState.StreamStateEnum.SEALED) {
             log.warn("Received invalid stream state: {} from client for stream {}/{}",
@@ -498,6 +632,15 @@ public class StreamMetadataResourceImpl implements ApiV1.ScopesApi {
                                  final SecurityContext securityContext, final AsyncResponse asyncResponse) {
         long traceId = LoggerHelpers.traceEnter(log, "getScalingEvents");
 
+        try {
+            authenticate(scopeName + "/" + streamName, READ);
+        } catch (AuthenticationException e) {
+            log.warn("Get scaling events for {} failed due to authentication failure.", scopeName + "/" + streamName);
+            asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build());
+            LoggerHelpers.traceLeave(log, "Get scaling events", traceId);
+            return;
+        }
+
         if (from < 0 || to < 0 || from > to) {
             log.warn("Received invalid request from client for scopeName/streamName: {}/{} ", scopeName, streamName);
             asyncResponse.resume(Response.status(Status.BAD_REQUEST).build());
diff --git a/controller/src/main/java/io/pravega/controller/server/retention/StreamCutBucketService.java b/controller/src/main/java/io/pravega/controller/server/retention/StreamCutBucketService.java
index 575c5be..fac982c 100644
--- a/controller/src/main/java/io/pravega/controller/server/retention/StreamCutBucketService.java
+++ b/controller/src/main/java/io/pravega/controller/server/retention/StreamCutBucketService.java
@@ -20,8 +20,6 @@ import io.pravega.controller.store.stream.StreamMetadataStore;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.util.Config;
 import io.pravega.controller.util.RetryHelper;
-import lombok.extern.slf4j.Slf4j;
-
 import java.time.Duration;
 import java.util.Collections;
 import java.util.Map;
@@ -34,6 +32,7 @@ import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
+import lombok.extern.slf4j.Slf4j;
 
 @Slf4j
 public class StreamCutBucketService extends AbstractService implements BucketChangeListener {
@@ -130,7 +129,8 @@ public class StreamCutBucketService extends AbstractService implements BucketCha
         OperationContext context = streamMetadataStore.createContext(stream.getScope(), stream.getStreamName());
         return RetryHelper.withRetriesAsync(() -> streamMetadataStore.getConfiguration(stream.getScope(), stream.getStreamName(), context, executor)
                 .thenCompose(config -> streamMetadataTasks.retention(stream.getScope(), stream.getStreamName(),
-                        config.getRetentionPolicy(), System.currentTimeMillis(), context))
+                        config.getRetentionPolicy(), System.currentTimeMillis(), context,
+                        this.streamMetadataTasks.retrieveDelegationToken()))
                 .exceptionally(e -> {
                     log.warn("Exception thrown while performing auto retention for stream {} ", stream, e);
                     throw new CompletionException(e);
diff --git a/controller/src/main/java/io/pravega/controller/server/rpc/auth/PasswordAuthHandler.java b/controller/src/main/java/io/pravega/controller/server/rpc/auth/PasswordAuthHandler.java
new file mode 100644
index 0000000..7fa7525
--- /dev/null
+++ b/controller/src/main/java/io/pravega/controller/server/rpc/auth/PasswordAuthHandler.java
@@ -0,0 +1,151 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server.rpc.auth;
+
+import com.google.common.base.Preconditions;
+import com.google.common.base.Strings;
+import io.pravega.auth.AuthHandler;
+import io.pravega.auth.ServerConfig;
+import io.pravega.common.auth.AuthenticationException;
+import io.pravega.controller.server.rpc.grpc.GRPCServerConfig;
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.security.NoSuchAlgorithmException;
+import java.security.spec.InvalidKeySpecException;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.stream.Collectors;
+import lombok.Data;
+import lombok.extern.slf4j.Slf4j;
+
+@Slf4j
+public class PasswordAuthHandler implements AuthHandler {
+    private static final String DEFAULT_NAME = "Pravega-Default";
+    private final ConcurrentHashMap<String, PravegaACls> userMap;
+    private final StrongPasswordProcessor encryptor;
+
+    public PasswordAuthHandler() {
+        userMap = new ConcurrentHashMap<>();
+        encryptor = StrongPasswordProcessor.builder().build();
+    }
+
+    private void loadPasswordFile(String userPasswordFile) {
+        try (FileReader reader = new FileReader(userPasswordFile);
+             BufferedReader lineReader = new BufferedReader(reader)) {
+            String line;
+            while ( !Strings.isNullOrEmpty(line = lineReader.readLine())) {
+                if (line.startsWith("#")) {
+                    continue;
+                }
+                String[] userFields = line.split(":");
+                if (userFields.length >= 2) {
+                    String acls;
+                    if (userFields.length == 2) {
+                        acls = "";
+                    } else {
+                        acls = userFields[2];
+                    }
+                    userMap.put(userFields[0], new PravegaACls(userFields[1], getAcls(acls)));
+                }
+            }
+        } catch (IOException e) {
+            throw new CompletionException(e);
+        }
+    }
+
+    @Override
+    public String getHandlerName() {
+        return DEFAULT_NAME;
+    }
+
+    @Override
+    public boolean authenticate(Map<String, String> headers) {
+        String userName = headers.get("username");
+        String password = headers.get("password");
+        Preconditions.checkArgument(userName != null, "Username not found in header");
+        Preconditions.checkArgument(password != null, "Password not found in header");
+
+        try {
+            return userMap.containsKey(userName) && encryptor.checkPassword(password, userMap.get(userName).encryptedPassword);
+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
+            log.warn("Excpetion during password authentication", e);
+            return false;
+        }
+    }
+
+    @Override
+    public Permissions authorize(String resource, Map<String, String> headers) {
+        String userName = headers.get("username");
+        if (Strings.isNullOrEmpty(userName) || !userMap.containsKey(userName)) {
+            throw new CompletionException(new AuthenticationException(userName));
+        }
+        return authorizeForUser(userMap.get(userName), resource);
+
+    }
+
+    @Override
+    public void initialize(ServerConfig serverConfig) {
+        loadPasswordFile(((GRPCServerConfig) serverConfig).getUserPasswordFile());
+    }
+
+    private Permissions authorizeForUser(PravegaACls pravegaACls, String resource) {
+        Permissions retVal = Permissions.NONE;
+
+        /**
+         *  `*` Means a wildcard.
+         *  If It is a direct match, return the ACLs.
+         *  If it is a partial match, the target has to end with a `/`
+         */
+        for (PravegaAcl acl : pravegaACls.acls) {
+            if (acl.resource.equals(resource) ||
+                    (acl.resource.endsWith("/") && resource.startsWith(acl.resource))
+                    || (resource.startsWith(acl.resource + "/"))
+                    || ((acl.resource.equals("*")) && (acl.acl.ordinal() > retVal.ordinal()))) {
+                retVal = acl.acl;
+            }
+        }
+        return retVal;
+    }
+
+    private List<PravegaAcl> getAcls(String aclString) {
+        return  Arrays.stream(aclString.split(";")).map(acl -> {
+            String[] splits = acl.split(",");
+            if (splits.length == 0) {
+                return null;
+            }
+            String resource = splits[0];
+            String aclVal = "READ";
+            if (splits.length >= 2) {
+                aclVal = splits[1];
+
+            }
+            return new PravegaAcl(resource,
+                    Permissions.valueOf(aclVal));
+        }).collect(Collectors.toList());
+    }
+
+    @Data
+    private class PravegaACls {
+        private final String encryptedPassword;
+        private final List<PravegaAcl> acls;
+    }
+
+    @Data
+    private class PravegaAcl {
+        private final String resource;
+        private final Permissions acl;
+
+
+    }
+}
diff --git a/controller/src/main/java/io/pravega/controller/server/rpc/auth/PravegaAuthManager.java b/controller/src/main/java/io/pravega/controller/server/rpc/auth/PravegaAuthManager.java
new file mode 100644
index 0000000..ccfec2d
--- /dev/null
+++ b/controller/src/main/java/io/pravega/controller/server/rpc/auth/PravegaAuthManager.java
@@ -0,0 +1,115 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server.rpc.auth;
+
+import io.grpc.ServerBuilder;
+import io.pravega.auth.AuthHandler;
+import io.pravega.common.auth.AuthenticationException;
+import io.pravega.controller.server.rpc.grpc.GRPCServerConfig;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.stream.Collectors;
+import javax.annotation.concurrent.GuardedBy;
+import javax.ws.rs.core.MultivaluedMap;
+import lombok.extern.slf4j.Slf4j;
+
+/**
+ * Auth manager class for Pravega controller. This manages the handlers for grpc and REST together.
+ * In case of grpc, the routing of the authenticate function to specific registered interceptor is taken care by grpc
+ * interceptor mechanism.
+ * In case of REST calls, this class routes the call to specific AuthHandler.
+ */
+@Slf4j
+public class PravegaAuthManager {
+    private final GRPCServerConfig serverConfig;
+    @GuardedBy("this")
+    private final Map<String, AuthHandler> handlerMap;
+
+    public PravegaAuthManager(GRPCServerConfig serverConfig) {
+        this.serverConfig = serverConfig;
+        this.handlerMap = new HashMap<>();
+    }
+
+    private AuthHandler getHandler(String handlerName) throws AuthenticationException {
+        AuthHandler retVal;
+        synchronized (this) {
+                retVal = handlerMap.get(handlerName);
+            }
+            if (retVal == null) {
+            throw new AuthenticationException("Handler does not exist for method " + handlerName);
+        }
+        return retVal;
+    }
+
+    /**
+     * API to authenticate and authroize access to a given resource.
+     * @param resource The resource identifier for which the access needs to be controlled.
+     * @param headers  Custom headers used for authentication.
+     * @param level    Expected level of access.
+     * @return         Returns true if the entity represented by the custom auth headers had given level of access to the resource.
+     * @throws AuthenticationException Exception faced during authentication/authorization.
+     */
+    public boolean authenticate(String resource, MultivaluedMap<String, String> headers, AuthHandler.Permissions level) throws AuthenticationException {
+        Map<String, String> paramMap = headers.entrySet().stream().collect(Collectors.toMap(k -> k.getKey(), k -> k.getValue().get(0)));
+        return authenticate(resource, paramMap, level);
+    }
+
+    /**
+     * API to authenticate and authroize access to a given resource.
+     * @param resource The resource identifier for which the access needs to be controlled.
+     * @param paramMap  Custom headers used for authentication.
+     * @param level    Expected level of access.
+     * @return         Returns true if the entity represented by the custom auth headers had given level of access to the resource.
+     * @throws AuthenticationException Exception faced during authentication/authorization.
+     */
+    public boolean authenticate(String resource, Map<String, String> paramMap, AuthHandler.Permissions level) throws AuthenticationException {
+        boolean retVal = false;
+        try {
+            String method = paramMap.get("method");
+            AuthHandler handler = getHandler(method);
+            retVal = handler.authenticate(paramMap) &&
+                    handler.authorize(resource, paramMap).ordinal() >= level.ordinal();
+        } catch (RuntimeException e) {
+            throw new AuthenticationException(e);
+        }
+        return retVal;
+    }
+
+    /**
+     * Loads the custom implementations of the AuthHandler interface dynamically. Registers the interceptors with grpc.
+     * Stores the implementation in a local map for routing the REST auth request.
+     * @param builder The grpc service builder to register the interceptors.
+     */
+    public void registerInterceptors(ServerBuilder<?> builder) {
+        try {
+            if (serverConfig.isAuthorizationEnabled()) {
+                ServiceLoader<AuthHandler> loader = ServiceLoader.load(AuthHandler.class);
+                for (AuthHandler handler : loader) {
+                    try {
+                        handler.initialize(serverConfig);
+                        synchronized (this) {
+                            if (handlerMap.putIfAbsent(handler.getHandlerName(), handler) != null) {
+                                log.warn("Handler with name {} already exists. Not replacing it with the latest handler");
+                                continue;
+                            }
+                        }
+                        builder.intercept(new PravegaInterceptor(handler));
+                    } catch (Exception e) {
+                        log.warn("Exception while initializing auth handler {}", handler, e);
+                    }
+
+                }
+            }
+        } catch (Throwable e) {
+            log.warn("Exception while loading the auth handlers", e);
+        }
+    }
+}
diff --git a/controller/src/main/java/io/pravega/controller/server/rpc/auth/PravegaInterceptor.java b/controller/src/main/java/io/pravega/controller/server/rpc/auth/PravegaInterceptor.java
new file mode 100644
index 0000000..37b4a88
--- /dev/null
+++ b/controller/src/main/java/io/pravega/controller/server/rpc/auth/PravegaInterceptor.java
@@ -0,0 +1,112 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server.rpc.auth;
+
+import com.google.common.base.Preconditions;
+import com.google.common.base.Strings;
+import io.grpc.Context;
+import io.grpc.Contexts;
+import io.grpc.Metadata;
+import io.grpc.ServerCall;
+import io.grpc.ServerCallHandler;
+import io.grpc.ServerInterceptor;
+import io.grpc.Status;
+import io.jsonwebtoken.Jwts;
+import io.jsonwebtoken.SignatureAlgorithm;
+import io.pravega.auth.AuthHandler;
+import java.util.HashMap;
+import java.util.Map;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+
+import static io.pravega.auth.AuthHandler.Permissions.READ_UPDATE;
+
+@Slf4j
+public class PravegaInterceptor implements ServerInterceptor {
+    private static final boolean AUTH_ENABLED = true;
+    private static final String AUTH_CONTEXT = "PravegaContext";
+    private static final String INTERCEPTOR_CONTEXT = "InterceptorContext";
+    private static final Context.Key<Map<String, String>> AUTH_CONTEXT_PARAMS = Context.key(AUTH_CONTEXT);
+    public static final Context.Key<PravegaInterceptor> INTERCEPTOR_OBJECT = Context.key(INTERCEPTOR_CONTEXT);
+
+    private final AuthHandler handler;
+    @Getter
+    private String delegationToken;
+
+    PravegaInterceptor(AuthHandler handler) {
+        Preconditions.checkNotNull(handler, "handler can not be null");
+        this.handler = handler;
+    }
+
+    @Override
+    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {
+
+        Map<String, String> paramMap = new HashMap<>();
+        headers.keys().stream().forEach(key -> {
+            try {
+                paramMap.put(key,
+                        headers.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER)));
+            } catch (IllegalArgumentException e) {
+                log.warn("Error while marshalling some of the headers", e);
+            }
+        });
+        String method = paramMap.get("method");
+        Context context = Context.current();
+        if (!Strings.isNullOrEmpty(method)) {
+            if (method.equals(handler.getHandlerName())) {
+
+                if (!handler.authenticate(paramMap)) {
+                    call.close(Status.fromCode(Status.Code.UNAUTHENTICATED), headers);
+                    return null;
+                }
+                context = context.withValue(AUTH_CONTEXT_PARAMS, paramMap);
+                context = context.withValue(INTERCEPTOR_OBJECT, this);
+            }
+        }
+        return Contexts.interceptCall(context, call, headers, next);
+    }
+
+    public AuthHandler.Permissions authorize(String resource) {
+        return this.handler.authorize(resource, AUTH_CONTEXT_PARAMS.get());
+    }
+
+    public static String retrieveDelegationToken(String tokenSigningKey) {
+        PravegaInterceptor interceptor = INTERCEPTOR_OBJECT.get();
+        if (interceptor != null) {
+            return interceptor.getDelegationToken();
+        } else {
+            Map<String, Object> claims = new HashMap();
+
+            claims.put("*", String.valueOf(READ_UPDATE));
+
+            return Jwts.builder()
+                       .setSubject("segmentstoreresource")
+                       .setAudience("segmentstore")
+                       .setClaims(claims)
+                       .signWith(SignatureAlgorithm.HS512, tokenSigningKey.getBytes())
+                       .compact();
+            }
+    }
+
+    public void setDelegationToken(String resource, AuthHandler.Permissions expectedLevel, String tokenSigningKey) {
+        if (AUTH_ENABLED) {
+            Map<String, Object> claims = new HashMap();
+
+            claims.put(resource, String.valueOf(expectedLevel));
+
+            delegationToken = Jwts.builder()
+                                  .setSubject("segmentstoreresource")
+                                  .setAudience("segmentstore")
+                                  .setClaims(claims)
+                                  .signWith(SignatureAlgorithm.HS512, tokenSigningKey.getBytes())
+                                  .compact();
+        }
+    }
+}
diff --git a/controller/src/main/java/io/pravega/controller/server/rpc/auth/StrongPasswordProcessor.java b/controller/src/main/java/io/pravega/controller/server/rpc/auth/StrongPasswordProcessor.java
new file mode 100644
index 0000000..b28682d
--- /dev/null
+++ b/controller/src/main/java/io/pravega/controller/server/rpc/auth/StrongPasswordProcessor.java
@@ -0,0 +1,116 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server.rpc.auth;
+
+import java.math.BigInteger;
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+import java.security.spec.InvalidKeySpecException;
+import javax.crypto.SecretKeyFactory;
+import javax.crypto.spec.PBEKeySpec;
+import lombok.Builder;
+
+/**
+ * This class implements a a `PBKDF2WithHmacSHA1` based password digest creator and validator.
+ *
+ * Following steps are taken during the creation of the digest:
+ *  1. A salt is generated.
+ *  2. The password is encoded with this salt.
+ *  3. Number of iterations, salt and this password is string encoded and concatenated with ":" as separator.
+ *  4. This whole string is again string encoded with base 16.
+ *
+ *  For validation these steps are reversed to get the password digest from the stored password. The incoming password
+ *  is digested with the retrieved iterations and salt. The generated digest is then cross checked against the created digest.
+ */
+@Builder
+public class StrongPasswordProcessor {
+
+    @Builder.Default
+    private String keyAlgorythm = "PBKDF2WithHmacSHA256";
+    @Builder.Default
+    private int keyLength = 64 * 8;
+    @Builder.Default
+    private int saltLength = 32;
+    @Builder.Default
+    private int iterations = 5000;
+
+    /*
+     * @param password              The incoming password.
+     * @param encryptedPassword     The stored password digest.
+     * @return                      true if the password matches, false otherwise.
+     * @throws NoSuchAlgorithmException encryption exceptions.
+     * @throws InvalidKeySpecException encryption exceptions.
+     */
+    public boolean checkPassword(String password, String encryptedPassword)
+            throws NoSuchAlgorithmException, InvalidKeySpecException {
+        String storedPassword = new String(fromHex(encryptedPassword));
+        String[] parts = storedPassword.split(":");
+        int iterations = Integer.parseInt(parts[0]);
+        byte[] salt = fromHex(parts[1]);
+        byte[] hash = fromHex(parts[2]);
+
+        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterations, keyLength);
+        SecretKeyFactory skf = SecretKeyFactory.getInstance(keyAlgorythm);
+        byte[] testHash = skf.generateSecret(spec).getEncoded();
+
+        //This is time independent version of array comparison.
+        // This is done to ensure that time based attacks do not happen.
+        //Read more here for time based attacks in this context.
+        // https://security.stackexchange.com/questions/74547/timing-attack-against-hmac-in-authenticated-encryption
+        int diff = hash.length ^ testHash.length;
+        for (int i = 0; i < hash.length && i < testHash.length; i++) {
+            diff |= hash[i] ^ testHash[i];
+        }
+        return diff == 0;
+    }
+
+
+    /*
+     * @param userPassword The password to be encrypted.
+     * @return The encrypted string digest.
+     * @throws NoSuchAlgorithmException encryption exceptions.
+     * @throws InvalidKeySpecException encryption exceptions.
+     */
+    public String encryptPassword(String userPassword) throws NoSuchAlgorithmException, InvalidKeySpecException {
+        char[] chars = userPassword.toCharArray();
+        byte[] salt = getSalt();
+
+        PBEKeySpec spec = new PBEKeySpec(chars, salt, iterations, keyLength);
+        SecretKeyFactory skf = SecretKeyFactory.getInstance(keyAlgorythm);
+        byte[] hash = skf.generateSecret(spec).getEncoded();
+        return toHex((iterations + ":" + toHex(salt) + ":" + toHex(hash)).getBytes());
+    }
+
+    private byte[] getSalt() throws NoSuchAlgorithmException {
+        SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
+        byte[] salt = new byte[saltLength];
+        sr.nextBytes(salt);
+        return salt;
+    }
+
+    private String toHex(byte[] array) throws NoSuchAlgorithmException {
+        BigInteger bi = new BigInteger(1, array);
+        String hex = bi.toString(16);
+        int paddingLength = (array.length * 2) - hex.length();
+        if (paddingLength > 0) {
+            return String.format("%0"  +paddingLength + "d", 0) + hex;
+        } else {
+            return hex;
+        }
+    }
+
+    private byte[] fromHex(String hex) {
+        byte[] bytes = new byte[hex.length() / 2];
+        for (int i = 0; i < bytes.length; i++) {
+            bytes[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16);
+        }
+        return bytes;
+    }
+}
diff --git a/controller/src/main/java/io/pravega/controller/server/rpc/auth/TestAuthHandler.java b/controller/src/main/java/io/pravega/controller/server/rpc/auth/TestAuthHandler.java
new file mode 100644
index 0000000..8583174
--- /dev/null
+++ b/controller/src/main/java/io/pravega/controller/server/rpc/auth/TestAuthHandler.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server.rpc.auth;
+
+import io.pravega.auth.AuthHandler;
+import io.pravega.auth.ServerConfig;
+import java.util.Map;
+
+public class TestAuthHandler implements AuthHandler {
+
+    @Override
+    public String getHandlerName() {
+        return "testHandler";
+    }
+
+    @Override
+    public boolean authenticate(Map<String, String> headers) {
+        return true;
+    }
+
+    @Override
+    public Permissions authorize(String resource, Map<String, String> headers) {
+        return Permissions.READ_UPDATE;
+    }
+
+    @Override
+    public void initialize(ServerConfig serverConfig) {
+
+    }
+}
diff --git a/controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServer.java b/controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServer.java
index e1a78eb..9f1439c 100644
--- a/controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServer.java
+++ b/controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServer.java
@@ -9,12 +9,16 @@
  */
 package io.pravega.controller.server.rpc.grpc;
 
+import com.google.common.base.Strings;
 import io.pravega.common.LoggerHelpers;
 import io.pravega.controller.server.ControllerService;
+import io.pravega.controller.server.rpc.auth.PravegaAuthManager;
 import io.pravega.controller.server.rpc.grpc.v1.ControllerServiceImpl;
 import com.google.common.util.concurrent.AbstractIdleService;
 import io.grpc.Server;
 import io.grpc.ServerBuilder;
+import java.io.File;
+import lombok.Getter;
 import lombok.extern.slf4j.Slf4j;
 
 /**
@@ -26,6 +30,8 @@ public class GRPCServer extends AbstractIdleService {
     private final String objectId;
     private final Server server;
     private final GRPCServerConfig config;
+    @Getter
+    private final PravegaAuthManager pravegaAuthManager;
 
     /**
      * Create gRPC server on the specified port.
@@ -36,10 +42,21 @@ public class GRPCServer extends AbstractIdleService {
     public GRPCServer(ControllerService controllerService, GRPCServerConfig serverConfig) {
         this.objectId = "gRPCServer";
         this.config = serverConfig;
-        this.server = ServerBuilder
+        ServerBuilder<?> builder = ServerBuilder
                 .forPort(serverConfig.getPort())
-                .addService(new ControllerServiceImpl(controllerService))
-                .build();
+                .addService(new ControllerServiceImpl(controllerService, serverConfig.getTokenSigningKey(), serverConfig.isAuthorizationEnabled()));
+        if (serverConfig.isAuthorizationEnabled()) {
+            this.pravegaAuthManager = new PravegaAuthManager(serverConfig);
+            this.pravegaAuthManager.registerInterceptors(builder);
+        } else {
+            this.pravegaAuthManager = null;
+        }
+
+        if (serverConfig.isTlsEnabled() && !Strings.isNullOrEmpty(serverConfig.getTlsCertFile())) {
+            builder = builder.useTransportSecurity(new File(serverConfig.getTlsCertFile()),
+                    new File(serverConfig.getTlsKeyFile()));
+        }
+        this.server = builder.build();
     }
 
     /**
diff --git a/controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java b/controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java
index 2875bda..a87176f 100644
--- a/controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java
+++ b/controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java
@@ -9,12 +9,13 @@
  */
 package io.pravega.controller.server.rpc.grpc;
 
+import io.pravega.auth.ServerConfig;
 import java.util.Optional;
 
 /**
  * Configuration of controller gRPC server.
  */
-public interface GRPCServerConfig {
+public interface GRPCServerConfig extends ServerConfig {
     /**
      * Fetches the port on which controller gRPC server listens.
      *
@@ -35,4 +36,55 @@ public interface GRPCServerConfig {
      * @return The RPC port which has to be registered with the cluster used for external access.
      */
     Optional<Integer> getPublishedRPCPort();
+
+    /**
+     * Fetches the settings which indicates whether authorization is enabled.
+     *
+     * @return Whether this deployment has auth enabled.
+     */
+    boolean isAuthorizationEnabled();
+
+    /**
+     * Fetches the location of password file for the users.
+     * This uses UNIX password file syntax. It is used for default implementation of authorization
+     * and authentication.
+     *
+     * @return Location of password file.
+     */
+    String getUserPasswordFile();
+
+    /**
+     * A configuration to switch TLS on client to controller interactions.
+      * @return A flag representing TLS status.
+     */
+    boolean isTlsEnabled();
+
+    /**
+     * The truststore to be used while talking to segmentstore over TLS.
+     *
+     * @return A path pointing to a trust store.
+     */
+    String getTlsTrustStore();
+
+    /**
+     * X.509 certificate file to be used for TLS.
+     *
+     * @return A file which contains the TLS certificate.
+     */
+    String getTlsCertFile();
+
+
+    /**
+     * File containing the private key for the X.509 certificate used for TLS.
+     * @return A file which contains the private key for the TLS certificate.
+     */
+    String getTlsKeyFile();
+
+    /**
+     * Returns the key that is shared between segmentstore and controller and is used for
+     * signing the delegation token.
+     * @return The string to be used for signing the token.
+     */
+    String getTokenSigningKey();
+
 }
diff --git a/controller/src/main/java/io/pravega/controller/server/rpc/grpc/impl/GRPCServerConfigImpl.java b/controller/src/main/java/io/pravega/controller/server/rpc/grpc/impl/GRPCServerConfigImpl.java
index 9636c20..c3eba39 100644
--- a/controller/src/main/java/io/pravega/controller/server/rpc/grpc/impl/GRPCServerConfigImpl.java
+++ b/controller/src/main/java/io/pravega/controller/server/rpc/grpc/impl/GRPCServerConfigImpl.java
@@ -9,14 +9,13 @@
  */
 package io.pravega.controller.server.rpc.grpc.impl;
 
+import com.google.common.base.Preconditions;
 import io.pravega.common.Exceptions;
 import io.pravega.controller.server.rpc.grpc.GRPCServerConfig;
-import com.google.common.base.Preconditions;
+import java.util.Optional;
 import lombok.Builder;
 import lombok.Data;
 
-import java.util.Optional;
-
 /**
  * gRPC server config.
  */
@@ -25,9 +24,19 @@ public class GRPCServerConfigImpl implements GRPCServerConfig {
     private final int port;
     private final Optional<String> publishedRPCHost;
     private final Optional<Integer> publishedRPCPort;
+    private final boolean authorizationEnabled;
+    private final String userPasswordFile;
+    private final boolean tlsEnabled;
+    private final String tlsCertFile;
+    private final String tlsKeyFile;
+    private final String tokenSigningKey;
+    private final String tlsTrustStore;
 
     @Builder
-    public GRPCServerConfigImpl(final int port, final String publishedRPCHost, final Integer publishedRPCPort) {
+    public GRPCServerConfigImpl(final int port, final String publishedRPCHost, final Integer publishedRPCPort,
+                                boolean authorizationEnabled, String userPasswordFile, boolean tlsEnabled,
+                                String tlsCertFile, String tlsKeyFile, String tokenSigningKey, String tlsTrustStore) {
+
         Preconditions.checkArgument(port > 0, "Invalid port.");
         if (publishedRPCHost != null) {
             Exceptions.checkNotNullOrEmpty(publishedRPCHost, "publishedRPCHost");
@@ -39,5 +48,12 @@ public class GRPCServerConfigImpl implements GRPCServerConfig {
         this.port = port;
         this.publishedRPCHost = Optional.ofNullable(publishedRPCHost);
         this.publishedRPCPort = Optional.ofNullable(publishedRPCPort);
+        this.authorizationEnabled = authorizationEnabled;
+        this.userPasswordFile = userPasswordFile;
+        this.tlsEnabled = tlsEnabled;
+        this.tlsCertFile = tlsCertFile;
+        this.tlsKeyFile = tlsKeyFile;
+        this.tlsTrustStore = tlsTrustStore;
+        this.tokenSigningKey = tokenSigningKey;
     }
 }
diff --git a/controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java b/controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java
index 9d4447b..ff4abd8 100644
--- a/controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java
+++ b/controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java
@@ -9,8 +9,13 @@
  */
 package io.pravega.controller.server.rpc.grpc.v1;
 
+import io.grpc.Status;
+import io.grpc.stub.StreamObserver;
+import io.pravega.auth.AuthHandler;
+import io.pravega.client.stream.impl.ModelHelper;
 import io.pravega.common.Exceptions;
 import io.pravega.controller.server.ControllerService;
+import io.pravega.controller.server.rpc.auth.PravegaInterceptor;
 import io.pravega.controller.stream.api.grpc.v1.Controller;
 import io.pravega.controller.stream.api.grpc.v1.Controller.CreateScopeStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.CreateStreamStatus;
@@ -22,8 +27,8 @@ import io.pravega.controller.stream.api.grpc.v1.Controller.NodeUri;
 import io.pravega.controller.stream.api.grpc.v1.Controller.PingTxnRequest;
 import io.pravega.controller.stream.api.grpc.v1.Controller.PingTxnStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.ScaleRequest;
-import io.pravega.controller.stream.api.grpc.v1.Controller.ScaleStatusRequest;
 import io.pravega.controller.stream.api.grpc.v1.Controller.ScaleResponse;
+import io.pravega.controller.stream.api.grpc.v1.Controller.ScaleStatusRequest;
 import io.pravega.controller.stream.api.grpc.v1.Controller.ScaleStatusResponse;
 import io.pravega.controller.stream.api.grpc.v1.Controller.ScopeInfo;
 import io.pravega.controller.stream.api.grpc.v1.Controller.SegmentId;
@@ -41,13 +46,11 @@ import io.pravega.controller.stream.api.grpc.v1.Controller.TxnState;
 import io.pravega.controller.stream.api.grpc.v1.Controller.TxnStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.UpdateStreamStatus;
 import io.pravega.controller.stream.api.grpc.v1.ControllerServiceGrpc;
-import io.pravega.client.stream.impl.ModelHelper;
-import io.grpc.Status;
-import io.grpc.stub.StreamObserver;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
 import java.util.stream.Collectors;
-
 import lombok.AllArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
 
@@ -60,12 +63,15 @@ public class ControllerServiceImpl extends ControllerServiceGrpc.ControllerServi
 
     // The underlying Controller Service implementation to delegate all API calls to.
     private final ControllerService controllerService;
+    private final String tokenSigningKey;
+    private final boolean isAuthEnabled;
 
     @Override
     public void getControllerServerList(ServerRequest request, StreamObserver<ServerResponse> responseObserver) {
         log.info("getControllerServerList called.");
-        processResult(controllerService.getControllerServerList()
-                        .thenApply(servers -> ServerResponse.newBuilder().addAllNodeURI(servers).build()),
+        authenticateExecuteAndProcessResults(aVoid -> true,
+                () -> controllerService.getControllerServerList()
+                                     .thenApply(servers -> ServerResponse.newBuilder().addAllNodeURI(servers).build()),
                 responseObserver);
     }
 
@@ -73,56 +79,72 @@ public class ControllerServiceImpl extends ControllerServiceGrpc.ControllerServi
     public void createStream(StreamConfig request, StreamObserver<CreateStreamStatus> responseObserver) {
         log.info("createStream called for stream {}/{}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream());
-        processResult(controllerService.createStream(ModelHelper.encode(request), System.currentTimeMillis()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorizationWithToken(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.createStream(ModelHelper.encode(request), System.currentTimeMillis()),
+                responseObserver);
     }
 
     @Override
     public void updateStream(StreamConfig request, StreamObserver<UpdateStreamStatus> responseObserver) {
         log.info("updateStream called for stream {}/{}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream());
-        processResult(controllerService.updateStream(ModelHelper.encode(request)), responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.updateStream(ModelHelper.encode(request)), responseObserver);
     }
 
     @Override
     public void truncateStream(Controller.StreamCut request, StreamObserver<UpdateStreamStatus> responseObserver) {
         log.info("updateStream called for stream {}/{}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream());
-        processResult(controllerService.truncateStream(request.getStreamInfo().getScope(),
-                request.getStreamInfo().getStream(), ModelHelper.encode(request)), responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.truncateStream(request.getStreamInfo().getScope(),
+                        request.getStreamInfo().getStream(), ModelHelper.encode(request)), responseObserver);
     }
 
     @Override
     public void sealStream(StreamInfo request, StreamObserver<UpdateStreamStatus> responseObserver) {
         log.info("sealStream called for stream {}/{}.", request.getScope(), request.getStream());
-        processResult(controllerService.sealStream(request.getScope(), request.getStream()), responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getScope() + "/" +
+                        request.getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.sealStream(request.getScope(), request.getStream()), responseObserver);
     }
 
     @Override
     public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus> responseObserver) {
         log.info("deleteStream called for stream {}/{}.", request.getScope(), request.getStream());
-        processResult(controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getScope() + "/" +
+                        request.getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver);
     }
 
     @Override
     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {
         log.info("getCurrentSegments called for stream {}/{}.", request.getScope(), request.getStream());
-        processResult(controllerService.getCurrentSegments(request.getScope(), request.getStream())
-                              .thenApply(segmentRanges -> SegmentRanges.newBuilder()
-                                      .addAllSegmentRanges(segmentRanges)
-                                      .build()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorizationWithToken(request.getScope() + "/" +
+                        request.getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.getCurrentSegments(request.getScope(), request.getStream())
+                                       .thenApply(segmentRanges -> SegmentRanges.newBuilder()
+                                                                                .addAllSegmentRanges(segmentRanges)
+                                                                                .setDelegationToken(getCurrentDelegationToken())
+                                                                                .build()),
+                responseObserver);
     }
 
     @Override
     public void getSegments(GetSegmentsRequest request, StreamObserver<SegmentsAtTime> responseObserver) {
         log.debug("getSegments called for stream " + request.getStreamInfo().getScope() + "/" +
-                          request.getStreamInfo().getStream());
-        processResult(controllerService.getSegmentsAtTime(request.getStreamInfo().getScope(),
-                                                          request.getStreamInfo().getStream(),
-                                                          request.getTimestamp())
+                request.getStreamInfo().getStream());
+        authenticateExecuteAndProcessResults(v -> checkAuthorizationWithToken(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.getSegmentsAtTime(request.getStreamInfo().getScope(),
+                        request.getStreamInfo().getStream(),
+                        request.getTimestamp())
                                        .thenApply(segments -> {
-                                           SegmentsAtTime.Builder builder = SegmentsAtTime.newBuilder();
+                                           SegmentsAtTime.Builder builder = SegmentsAtTime.newBuilder()
+                                                                                          .setDelegationToken(getCurrentDelegationToken());
                                            for (Entry<SegmentId, Long> entry : segments.entrySet()) {
                                                builder.addSegments(SegmentLocation.newBuilder()
                                                                                   .setSegmentId(entry.getKey())
@@ -131,147 +153,239 @@ public class ControllerServiceImpl extends ControllerServiceGrpc.ControllerServi
                                            }
                                            return builder.build();
                                        }),
-                      responseObserver);
+                responseObserver);
     }
 
     @Override
     public void getSegmentsImmediatlyFollowing(SegmentId segmentId,
-            StreamObserver<SuccessorResponse> responseObserver) {
+                                               StreamObserver<SuccessorResponse> responseObserver) {
         log.info("getSegmentsImmediatelyFollowing called for segment {} ", segmentId);
-        processResult(controllerService.getSegmentsImmediatelyFollowing(segmentId)
-                              .thenApply(ModelHelper::createSuccessorResponse),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(segmentId.getStreamInfo().getScope() + "/" +
+                        segmentId.getStreamInfo().getStream(), AuthHandler.Permissions.READ),
+                () -> controllerService.getSegmentsImmediatelyFollowing(segmentId)
+                                       .thenApply(ModelHelper::createSuccessorResponse)
+                                       .thenApply(response -> {
+                                           response.setDelegationToken(getCurrentDelegationToken());
+                                           return response.build();
+                                       }),
+                responseObserver);
     }
 
     @Override
     public void scale(ScaleRequest request, StreamObserver<ScaleResponse> responseObserver) {
         log.info("scale called for stream {}/{}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream());
-        processResult(controllerService.scale(request.getStreamInfo().getScope(),
-                                              request.getStreamInfo().getStream(),
-                                              request.getSealedSegmentsList(),
-                                              request.getNewKeyRangesList().stream().collect(Collectors.toMap(
-                                                      entry -> entry.getStart(), entry -> entry.getEnd())),
-                                              request.getScaleTimestamp()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.scale(request.getStreamInfo().getScope(),
+                        request.getStreamInfo().getStream(),
+                        request.getSealedSegmentsList(),
+                        request.getNewKeyRangesList().stream().collect(Collectors.toMap(
+                                entry -> entry.getStart(), entry -> entry.getEnd())),
+                        request.getScaleTimestamp()),
+                responseObserver);
     }
 
     @Override
     public void checkScale(ScaleStatusRequest request, StreamObserver<ScaleStatusResponse> responseObserver) {
         log.debug("check scale status called for stream {}/{}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream());
-        processResult(controllerService.checkScale(request.getStreamInfo().getScope(), request.getStreamInfo().getStream(),
-                request.getEpoch()), responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.checkScale(request.getStreamInfo().getScope(), request.getStreamInfo().getStream(),
+                        request.getEpoch()), responseObserver);
     }
 
     @Override
     public void getURI(SegmentId request, StreamObserver<NodeUri> responseObserver) {
         log.info("getURI called for segment {}/{}/{}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream(), request.getSegmentNumber());
-        processResult(controllerService.getURI(request), responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.getURI(request),
+                responseObserver);
     }
 
     @Override
     public void isSegmentValid(SegmentId request,
-            StreamObserver<SegmentValidityResponse> responseObserver) {
+                               StreamObserver<SegmentValidityResponse> responseObserver) {
         log.info("isSegmentValid called for segment {}/{}/{}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream(), request.getSegmentNumber());
-        processResult(controllerService.isSegmentValid(request.getStreamInfo().getScope(),
-                                                       request.getStreamInfo().getStream(),
-                                                       request.getSegmentNumber())
-                .thenApply(bRes -> SegmentValidityResponse.newBuilder().setResponse(bRes).build()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.isSegmentValid(request.getStreamInfo().getScope(),
+                        request.getStreamInfo().getStream(),
+                        request.getSegmentNumber())
+                                       .thenApply(bRes -> SegmentValidityResponse.newBuilder().setResponse(bRes).build()),
+                responseObserver);
     }
 
     @Override
     public void createTransaction(CreateTxnRequest request, StreamObserver<Controller.CreateTxnResponse> responseObserver) {
         log.info("createTransaction called for stream {}/{}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream());
-        processResult(controllerService.createTransaction(request.getStreamInfo().getScope(),
-                                                          request.getStreamInfo().getStream(),
-                                                          request.getLease(),
-                                                          request.getScaleGracePeriod())
-                .thenApply(pair -> Controller.CreateTxnResponse.newBuilder()
-                        .setTxnId(ModelHelper.decode(pair.getKey()))
-                        .addAllActiveSegments(pair.getValue())
-                        .build()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorizationWithToken(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.createTransaction(request.getStreamInfo().getScope(),
+                        request.getStreamInfo().getStream(),
+                        request.getLease(),
+                        request.getScaleGracePeriod())
+                                       .thenApply(pair -> Controller.CreateTxnResponse.newBuilder()
+                                                                                      .setDelegationToken(getCurrentDelegationToken())
+                                                                                      .setTxnId(ModelHelper.decode(pair.getKey()))
+                                                                                      .addAllActiveSegments(pair.getValue())
+                                                                                      .build()),
+                responseObserver);
     }
 
     @Override
     public void commitTransaction(TxnRequest request, StreamObserver<TxnStatus> responseObserver) {
         log.info("commitTransaction called for stream {}/{}, txnId={}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream(), request.getTxnId());
-        processResult(controllerService.commitTransaction(request.getStreamInfo().getScope(),
-                                                          request.getStreamInfo().getStream(),
-                                                          request.getTxnId()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.commitTransaction(request.getStreamInfo().getScope(),
+                        request.getStreamInfo().getStream(),
+                        request.getTxnId()),
+                responseObserver);
     }
 
     @Override
     public void abortTransaction(TxnRequest request, StreamObserver<TxnStatus> responseObserver) {
         log.info("abortTransaction called for stream {}/{}, txnId={}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream(), request.getTxnId());
-        processResult(controllerService.abortTransaction(request.getStreamInfo().getScope(),
-                                                        request.getStreamInfo().getStream(),
-                                                        request.getTxnId()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.abortTransaction(request.getStreamInfo().getScope(),
+                        request.getStreamInfo().getStream(),
+                        request.getTxnId()),
+                responseObserver);
     }
 
     @Override
     public void pingTransaction(PingTxnRequest request, StreamObserver<PingTxnStatus> responseObserver) {
         log.info("pingTransaction called for stream {}/{}, txnId={}", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream(), request.getTxnId());
-        processResult(controllerService.pingTransaction(request.getStreamInfo().getScope(),
-                                                        request.getStreamInfo().getStream(),
-                                                        request.getTxnId(),
-                                                        request.getLease()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ),
+                () -> controllerService.pingTransaction(request.getStreamInfo().getScope(),
+                        request.getStreamInfo().getStream(),
+                        request.getTxnId(),
+                        request.getLease()),
+                responseObserver);
     }
 
     @Override
     public void checkTransactionState(TxnRequest request, StreamObserver<TxnState> responseObserver) {
         log.info("checkTransactionState called for stream {}/{}, txnId={}.", request.getStreamInfo().getScope(),
                 request.getStreamInfo().getStream(), request.getTxnId());
-        processResult(controllerService.checkTransactionStatus(request.getStreamInfo().getScope(),
-                                                               request.getStreamInfo().getStream(),
-                                                               request.getTxnId()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getStreamInfo().getScope() + "/" +
+                        request.getStreamInfo().getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.checkTransactionStatus(request.getStreamInfo().getScope(),
+                        request.getStreamInfo().getStream(),
+                        request.getTxnId()),
+                responseObserver);
     }
 
     @Override
     public void createScope(ScopeInfo request,
-            StreamObserver<CreateScopeStatus> responseObserver) {
+                            StreamObserver<CreateScopeStatus> responseObserver) {
         log.info("createScope called for scope {}.", request.getScope());
-        processResult(controllerService.createScope(request.getScope()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getScope(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.createScope(request.getScope()),
+                responseObserver);
     }
 
     @Override
     public void deleteScope(ScopeInfo request,
-            StreamObserver<DeleteScopeStatus> responseObserver) {
+                            StreamObserver<DeleteScopeStatus> responseObserver) {
         log.info("deleteScope called for scope {}.", request.getScope());
-        processResult(controllerService.deleteScope(request.getScope()),
-                      responseObserver);
+        authenticateExecuteAndProcessResults(v -> checkAuthorization(request.getScope(), AuthHandler.Permissions.READ_UPDATE),
+                () -> controllerService.deleteScope(request.getScope()),
+                responseObserver);
+    }
+
+    @Override
+    public void getDelegationToken(io.pravega.controller.stream.api.grpc.v1.Controller.StreamInfo request,
+                                   io.grpc.stub.StreamObserver<io.pravega.controller.stream.api.grpc.v1.Controller.DelegationToken> responseObserver)  {
+        log.info("createStream called for stream {}/{}.", request.getScope(),
+                request.getStream());
+        authenticateExecuteAndProcessResults(v -> checkAuthorizationWithToken(request.getScope() + "/" +
+                        request.getStream(), AuthHandler.Permissions.READ_UPDATE),
+                () -> CompletableFuture.completedFuture(Controller.DelegationToken
+                        .newBuilder()
+                        .setDelegationToken(getCurrentDelegationToken())
+                        .build()),
+                responseObserver);
     }
 
     // Convert responses from CompletableFuture to gRPC's Observer pattern.
-    private static <T> void processResult(final CompletableFuture<T> result, final StreamObserver<T> streamObserver) {
-        result.whenComplete(
-                (value, ex) -> {
-                    log.debug("result = " + (value == null ? "null" : value.toString()));
+    private static <T> void authenticateExecuteAndProcessResults(Predicate<Void> authenticator,
+                                                                 Supplier<CompletableFuture<T>> call, final StreamObserver<T> streamObserver) {
+        if (authenticator.test(null)) {
+            CompletableFuture<T> result = call.get();
+            result.whenComplete(
+                    (value, ex) -> {
+                        log.debug("result =  {}", value);
+
+                        if (ex != null) {
+                            Throwable cause = Exceptions.unwrap(ex);
+                            log.error("Controller api failed with error: ", ex);
+                            streamObserver.onError(Status.INTERNAL
+                                    .withCause(cause)
+                                    .withDescription(cause.getMessage())
+                                    .asRuntimeException());
+                        } else if (value != null) {
+                            streamObserver.onNext(value);
+                            streamObserver.onCompleted();
+                        }
+                    });
+        } else {
+            log.error("Controller api failed with authenticator error");
+            streamObserver.onError(Status.UNAUTHENTICATED
+                    .withDescription("Authentication failed")
+                    .asRuntimeException());
+        }
+    }
+
+    public boolean checkAuthorization(String resource, AuthHandler.Permissions expectedLevel) {
+        if (isAuthEnabled) {
+            PravegaInterceptor currentInterceptor = PravegaInterceptor.INTERCEPTOR_OBJECT.get();
+
+            AuthHandler.Permissions allowedLevel;
+            if (currentInterceptor == null) {
+                //No interceptor, means no authorization enabled
+                allowedLevel = AuthHandler.Permissions.READ_UPDATE;
+            } else {
+                allowedLevel = currentInterceptor.authorize(resource);
+            }
+            if (allowedLevel.ordinal() < expectedLevel.ordinal()) {
+                return false;
+            }
+            return true;
+        } else {
+            return true;
+        }
+    }
+
+    public boolean checkAuthorizationWithToken(String resource, AuthHandler.Permissions expectedLevel) {
+        if (isAuthEnabled) {
+            boolean retVal = checkAuthorization(resource, expectedLevel);
+            if (retVal) {
+                PravegaInterceptor interceptor = PravegaInterceptor.INTERCEPTOR_OBJECT.get();
+                interceptor.setDelegationToken(resource, expectedLevel, tokenSigningKey);
+            }
+            return retVal;
+        } else {
+            return true;
+        }
+    }
 
-                    if (ex != null) {
-                        Throwable cause = Exceptions.unwrap(ex);
-                        log.error("Controller api failed with error: ", ex);
-                        streamObserver.onError(Status.INTERNAL
-                                .withCause(cause)
-                                .withDescription(cause.getMessage())
-                                .asRuntimeException());
-                    } else if (value != null) {
-                        streamObserver.onNext(value);
-                        streamObserver.onCompleted();
-                    }
-                });
+    private String getCurrentDelegationToken() {
+        if (isAuthEnabled) {
+            return PravegaInterceptor.retrieveDelegationToken(tokenSigningKey);
+        } else {
+            return "";
+        }
     }
 }
diff --git a/controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java b/controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java
index 99e0836..55fcd96 100644
--- a/controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java
+++ b/controller/src/main/java/io/pravega/controller/task/Stream/StreamMetadataTasks.java
@@ -25,6 +25,7 @@ import io.pravega.common.concurrent.Futures;
 import io.pravega.controller.server.SegmentHelper;
 import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;
 import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;
+import io.pravega.controller.server.rpc.auth.PravegaInterceptor;
 import io.pravega.controller.store.host.HostControllerStore;
 import io.pravega.controller.store.stream.CreateStreamResponse;
 import io.pravega.controller.store.stream.OperationContext;
@@ -52,9 +53,6 @@ import io.pravega.shared.controller.event.SealStreamEvent;
 import io.pravega.shared.controller.event.TruncateStreamEvent;
 import io.pravega.shared.controller.event.UpdateStreamEvent;
 import io.pravega.shared.protocol.netty.WireCommands;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.NotImplementedException;
-
 import java.io.Serializable;
 import java.time.Duration;
 import java.util.AbstractMap;
@@ -71,6 +69,8 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.NotImplementedException;
 
 import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;
 
@@ -89,28 +89,32 @@ public class StreamMetadataTasks extends TaskBase {
     private final HostControllerStore hostControllerStore;
     private final ConnectionFactory connectionFactory;
     private final SegmentHelper segmentHelper;
+    private final String tokenSigningKey;
     private ClientFactory clientFactory;
     private String requestStreamName;
 
     private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();
+    private final boolean authEnabled;
 
     public StreamMetadataTasks(final StreamMetadataStore streamMetadataStore,
                                final HostControllerStore hostControllerStore, final TaskMetadataStore taskMetadataStore,
                                final SegmentHelper segmentHelper, final ScheduledExecutorService executor, final String hostId,
-                               final ConnectionFactory connectionFactory) {
+                               final ConnectionFactory connectionFactory, boolean authEnabled, String tokenSigningKey) {
         this(streamMetadataStore, hostControllerStore, taskMetadataStore, segmentHelper, executor, new Context(hostId),
-                connectionFactory);
+                connectionFactory, authEnabled, tokenSigningKey);
     }
 
     private StreamMetadataTasks(final StreamMetadataStore streamMetadataStore,
                                 final HostControllerStore hostControllerStore, final TaskMetadataStore taskMetadataStore,
                                 final SegmentHelper segmentHelper, final ScheduledExecutorService executor, final Context context,
-                                ConnectionFactory connectionFactory) {
+                                ConnectionFactory connectionFactory, boolean authEnabled, String tokenSigningKey) {
         super(taskMetadataStore, executor, context);
         this.streamMetadataStore = streamMetadataStore;
         this.hostControllerStore = hostControllerStore;
         this.segmentHelper = segmentHelper;
         this.connectionFactory = connectionFactory;
+        this.authEnabled = authEnabled;
+        this.tokenSigningKey = tokenSigningKey;
         this.setReady();
     }
 
@@ -194,10 +198,11 @@ public class StreamMetadataTasks extends TaskBase {
      * @param policy retention policy
      * @param recordingTime time of recording
      * @param contextOpt operation context
+     * @param delegationToken token to be sent to segmentstore to authorize this operation.
      * @return future.
      */
     public CompletableFuture<Void> retention(final String scope, final String stream, final RetentionPolicy policy,
-                                             final long recordingTime, final OperationContext contextOpt) {
+                                    final long recordingTime, final OperationContext contextOpt, final String delegationToken) {
         Preconditions.checkNotNull(policy);
         final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;
 
@@ -205,16 +210,16 @@ public class StreamMetadataTasks extends TaskBase {
                 .thenCompose(retentionSet -> {
                     StreamCutRecord latestCut = retentionSet.stream()
                             .max(Comparator.comparingLong(StreamCutRecord::getRecordingTime)).orElse(null);
-                    return checkGenerateStreamCut(scope, stream, context, latestCut, recordingTime)
+                    return checkGenerateStreamCut(scope, stream, context, latestCut, recordingTime, delegationToken)
                             .thenCompose(newRecord -> truncate(scope, stream, policy, context, retentionSet, newRecord, recordingTime));
                 });
 
     }
 
     private CompletableFuture<StreamCutRecord> checkGenerateStreamCut(String scope, String stream, OperationContext context,
-                                                           StreamCutRecord latestCut, long recordingTime) {
+                                                                      StreamCutRecord latestCut, long recordingTime, String delegationToken) {
         if (latestCut == null || recordingTime - latestCut.getRecordingTime() > RETENTION_FREQUENCY_IN_MINUTES) {
-            return generateStreamCut(scope, stream, context)
+            return generateStreamCut(scope, stream, context, delegationToken)
                     .thenCompose(newRecord -> streamMetadataStore.addStreamCutToRetentionSet(scope, stream, newRecord, context, executor)
                         .thenApply(x -> {
                             log.debug("New streamCut generated for stream {}/{}", scope, stream);
@@ -273,17 +278,18 @@ public class StreamMetadataTasks extends TaskBase {
      * @param scope      scope.
      * @param stream     stream name.
      * @param contextOpt optional context
+     * @param delegationToken token to be sent to segmentstore.
      * @return streamCut.
      */
     public CompletableFuture<StreamCutRecord> generateStreamCut(final String scope, final String stream,
-                                                                final OperationContext contextOpt) {
+                                                                final OperationContext contextOpt, String delegationToken) {
         final OperationContext context = contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;
 
         return streamMetadataStore.getActiveSegments(scope, stream, context, executor)
                 .thenCompose(activeSegments -> Futures.allOfWithResults(activeSegments
                         .stream()
                         .parallel()
-                        .collect(Collectors.toMap(Segment::getNumber, x -> getSegmentOffset(scope, stream, x.getNumber())))))
+                        .collect(Collectors.toMap(Segment::getNumber, x -> getSegmentOffset(scope, stream, x.getNumber(), delegationToken)))))
                 .thenCompose(map -> {
                     final long generationTime = System.currentTimeMillis();
                     return streamMetadataStore.getSizeTillStreamCut(scope, stream, map, context, executor)
@@ -575,9 +581,10 @@ public class StreamMetadataTasks extends TaskBase {
      * @param runOnlyIfStarted run only if the scale operation was already running. It will ignore requests if the operation isnt started
      *                         by the caller.
      * @param context operation context
+     * @param delegationToken token to be sent to segmentstore.
      * @return returns list of new segments created as part of this scale operation.
      */
-    public CompletableFuture<List<Segment>> startScale(ScaleOpEvent scaleInput, boolean runOnlyIfStarted, OperationContext context) { // called upon event read from requeststream
+    public CompletableFuture<List<Segment>> startScale(ScaleOpEvent scaleInput, boolean runOnlyIfStarted, OperationContext context, String delegationToken) { // called upon event read from requeststream
         return withRetries(() -> streamMetadataStore.startScale(scaleInput.getScope(),
                 scaleInput.getStream(),
                 scaleInput.getSegmentsToSeal(),
@@ -588,7 +595,7 @@ public class StreamMetadataTasks extends TaskBase {
                 executor), executor)
                 .thenCompose(response -> streamMetadataStore.setState(scaleInput.getScope(), scaleInput.getStream(), State.SCALING, context, executor)
                         .thenApply(updated -> response))
-                .thenCompose(response -> notifyNewSegments(scaleInput.getScope(), scaleInput.getStream(), response.getSegmentsCreated(), context)
+                .thenCompose(response -> notifyNewSegments(scaleInput.getScope(), scaleInput.getStream(), response.getSegmentsCreated(), context, delegationToken)
                         .thenCompose(x -> {
                             assert !response.getSegmentsCreated().isEmpty();
 
@@ -598,7 +605,7 @@ public class StreamMetadataTasks extends TaskBase {
                                     scaleInput.getSegmentsToSeal(), response.getSegmentsCreated(), response.getActiveEpoch(),
                                     scaleTs, context, executor), executor);
                         })
-                        .thenCompose(x -> tryCompleteScale(scaleInput.getScope(), scaleInput.getStream(), response.getActiveEpoch(), context))
+                        .thenCompose(x -> tryCompleteScale(scaleInput.getScope(), scaleInput.getStream(), response.getActiveEpoch(), context, delegationToken))
                         .thenApply(y -> response.getSegmentsCreated()));
     }
 
@@ -609,9 +616,10 @@ public class StreamMetadataTasks extends TaskBase {
      * @param stream stream
      * @param epoch epoch
      * @param context operation context
+     * @param delegationToken token to be sent to segmentstore.
      * @return returns true if it was able to complete scale. false otherwise
      */
-    public CompletableFuture<Boolean> tryCompleteScale(String scope, String stream, int epoch, OperationContext context) {
+    public CompletableFuture<Boolean> tryCompleteScale(String scope, String stream, int epoch, OperationContext context, String delegationToken) {
         // Note: if we cant delete old epoch -- txns against old segments are ongoing..
         // if we can delete old epoch, then only do we proceed to subsequent steps
         return withRetries(() -> streamMetadataStore.tryDeleteEpochIfScaling(scope, stream, epoch, context, executor), executor)
@@ -622,8 +630,8 @@ public class StreamMetadataTasks extends TaskBase {
                     assert !response.getSegmentsCreated().isEmpty() && !response.getSegmentsSealed().isEmpty();
 
                     long scaleTs = response.getSegmentsCreated().get(0).getStart();
-                    return notifySealedSegments(scope, stream, response.getSegmentsSealed())
-                            .thenCompose(x -> getSealedSegmentsSize(scope, stream, response.getSegmentsSealed()))
+                    return notifySealedSegments(scope, stream, response.getSegmentsSealed(), delegationToken)
+                            .thenCompose(x -> getSealedSegmentsSize(scope, stream, response.getSegmentsSealed(), delegationToken))
                             .thenCompose(map ->
                                     withRetries(() -> streamMetadataStore.scaleSegmentsSealed(scope, stream, map,
                                             response.getSegmentsCreated(), epoch, scaleTs, context, executor), executor)
@@ -647,7 +655,7 @@ public class StreamMetadataTasks extends TaskBase {
                             response.getStatus().equals(CreateStreamResponse.CreateStatus.EXISTS_CREATING)) {
                         List<Integer> newSegments = IntStream.range(0, response.getConfiguration().getScalingPolicy()
                                 .getMinNumSegments()).boxed().collect(Collectors.toList());
-                        return notifyNewSegments(scope, stream, response.getConfiguration(), newSegments)
+                        return notifyNewSegments(scope, stream, response.getConfiguration(), newSegments, this.retrieveDelegationToken())
                                 .thenCompose(y -> {
                                     final OperationContext context = streamMetadataStore.createContext(scope, stream);
 
@@ -702,90 +710,90 @@ public class StreamMetadataTasks extends TaskBase {
         return retVal;
     }
 
-    private CompletableFuture<Void> notifyNewSegments(String scope, String stream, List<Segment> segmentNumbers, OperationContext context) {
+    private CompletableFuture<Void> notifyNewSegments(String scope, String stream, List<Segment> segmentNumbers, OperationContext context, String controllerToken) {
         return withRetries(() -> streamMetadataStore.getConfiguration(scope, stream, context, executor), executor)
                 .thenCompose(configuration -> notifyNewSegments(scope, stream, configuration,
-                        segmentNumbers.stream().map(Segment::getNumber).collect(Collectors.toList())));
+                        segmentNumbers.stream().map(Segment::getNumber).collect(Collectors.toList()), controllerToken));
     }
 
-    private CompletableFuture<Void> notifyNewSegments(String scope, String stream, StreamConfiguration configuration, List<Integer> segmentNumbers) {
+    private CompletableFuture<Void> notifyNewSegments(String scope, String stream, StreamConfiguration configuration, List<Integer> segmentNumbers, String controllerToken) {
         return Futures.toVoid(Futures.allOfWithResults(segmentNumbers
                 .stream()
                 .parallel()
-                .map(segment -> notifyNewSegment(scope, stream, segment, configuration.getScalingPolicy()))
+                .map(segment -> notifyNewSegment(scope, stream, segment, configuration.getScalingPolicy(), controllerToken))
                 .collect(Collectors.toList())));
     }
 
-    private CompletableFuture<Void> notifyNewSegment(String scope, String stream, int segmentNumber, ScalingPolicy policy) {
+    private CompletableFuture<Void> notifyNewSegment(String scope, String stream, int segmentNumber, ScalingPolicy policy, String controllerToken) {
         return Futures.toVoid(withRetries(() -> segmentHelper.createSegment(scope,
-                stream, segmentNumber, policy, hostControllerStore, this.connectionFactory), executor));
+                stream, segmentNumber, policy, hostControllerStore, this.connectionFactory, controllerToken), executor));
     }
 
-    public CompletableFuture<Void> notifyDeleteSegments(String scope, String stream, int count) {
+    public CompletableFuture<Void> notifyDeleteSegments(String scope, String stream, int count, String delegationToken) {
         return Futures.allOf(IntStream.range(0, count)
                                       .parallel()
-                                      .mapToObj(segment -> notifyDeleteSegment(scope, stream, segment))
+                                      .mapToObj(segment -> notifyDeleteSegment(scope, stream, segment, delegationToken))
                                       .collect(Collectors.toList()));
     }
 
-    public CompletableFuture<Void> notifyDeleteSegment(String scope, String stream, int segmentNumber) {
+    public CompletableFuture<Void> notifyDeleteSegment(String scope, String stream, int segmentNumber, String delegationToken) {
         return Futures.toVoid(withRetries(() -> segmentHelper.deleteSegment(scope,
-                stream, segmentNumber, hostControllerStore, this.connectionFactory), executor));
+                stream, segmentNumber, hostControllerStore, this.connectionFactory, delegationToken), executor));
     }
 
-    public CompletableFuture<Void> notifyTruncateSegment(String scope, String stream, Map.Entry<Integer, Long> segmentCut) {
+    public CompletableFuture<Void> notifyTruncateSegment(String scope, String stream, Map.Entry<Integer, Long> segmentCut, String delegationToken) {
         return Futures.toVoid(withRetries(() -> segmentHelper.truncateSegment(scope,
-                stream, segmentCut.getKey(), segmentCut.getValue(), hostControllerStore, this.connectionFactory), executor));
+                stream, segmentCut.getKey(), segmentCut.getValue(), hostControllerStore, this.connectionFactory, delegationToken), executor));
     }
 
-    public CompletableFuture<Map<Integer, Long>> getSealedSegmentsSize(String scope, String stream, List<Integer> sealedSegments) {
+    public CompletableFuture<Map<Integer, Long>> getSealedSegmentsSize(String scope, String stream, List<Integer> sealedSegments, String delegationToken) {
         return Futures.allOfWithResults(
                 sealedSegments
                         .stream()
                         .parallel()
-                        .collect(Collectors.toMap(x -> x, x -> getSegmentOffset(scope, stream, x))));
+                        .collect(Collectors.toMap(x -> x, x -> getSegmentOffset(scope, stream, x, delegationToken))));
     }
 
-    public CompletableFuture<Void> notifySealedSegments(String scope, String stream, List<Integer> sealedSegments) {
+    public CompletableFuture<Void> notifySealedSegments(String scope, String stream, List<Integer> sealedSegments, String delegationToken) {
         return Futures.allOf(
                 sealedSegments
                         .stream()
                         .parallel()
-                        .map(number -> notifySealedSegment(scope, stream, number))
+                        .map(number -> notifySealedSegment(scope, stream, number, delegationToken))
                         .collect(Collectors.toList()));
     }
 
-    private CompletableFuture<Void> notifySealedSegment(final String scope, final String stream, final int sealedSegment) {
+    private CompletableFuture<Void> notifySealedSegment(final String scope, final String stream, final int sealedSegment, String delegationToken) {
 
         return Futures.toVoid(withRetries(() -> segmentHelper.sealSegment(
                 scope,
                 stream,
                 sealedSegment,
                 hostControllerStore,
-                this.connectionFactory), executor));
+                this.connectionFactory, delegationToken), executor));
     }
 
     public CompletableFuture<Void> notifyPolicyUpdates(String scope, String stream, List<Segment> activeSegments,
-                                                        ScalingPolicy policy) {
+                                                       ScalingPolicy policy, String delegationToken) {
         return Futures.toVoid(Futures.allOfWithResults(activeSegments
                 .stream()
                 .parallel()
-                .map(segment -> notifyPolicyUpdate(scope, stream, policy, segment.getNumber()))
+                .map(segment -> notifyPolicyUpdate(scope, stream, policy, segment.getNumber(), delegationToken))
                 .collect(Collectors.toList())));
     }
 
-    private CompletableFuture<Long> getSegmentOffset(String scope, String stream, int segmentNumber) {
+    private CompletableFuture<Long> getSegmentOffset(String scope, String stream, int segmentNumber, String delegationToken) {
 
         return withRetries(() -> segmentHelper.getSegmentInfo(
                 scope,
                 stream,
                 segmentNumber,
                 hostControllerStore,
-                this.connectionFactory), executor)
+                this.connectionFactory, delegationToken), executor)
                 .thenApply(WireCommands.StreamSegmentInfo::getWriteOffset);
     }
 
-    private CompletableFuture<Void> notifyPolicyUpdate(String scope, String stream, ScalingPolicy policy, int segmentNumber) {
+    private CompletableFuture<Void> notifyPolicyUpdate(String scope, String stream, ScalingPolicy policy, int segmentNumber, String delegationToken) {
 
         return withRetries(() -> segmentHelper.updatePolicy(
                 scope,
@@ -793,7 +801,7 @@ public class StreamMetadataTasks extends TaskBase {
                 policy,
                 segmentNumber,
                 hostControllerStore,
-                this.connectionFactory), executor);
+                this.connectionFactory, delegationToken), executor);
     }
 
     private SegmentRange convert(String scope, String stream, Segment segment) {
@@ -830,10 +838,20 @@ public class StreamMetadataTasks extends TaskBase {
                 segmentHelper,
                 executor,
                 context,
-                connectionFactory);
+                connectionFactory,
+                authEnabled,
+                tokenSigningKey);
     }
 
     @Override
     public void close() throws Exception {
     }
+
+    public String retrieveDelegationToken() {
+        if (authEnabled) {
+            return PravegaInterceptor.retrieveDelegationToken(tokenSigningKey);
+        } else {
+            return "";
+        }
+    }
 }
diff --git a/controller/src/main/java/io/pravega/controller/task/Stream/StreamTransactionMetadataTasks.java b/controller/src/main/java/io/pravega/controller/task/Stream/StreamTransactionMetadataTasks.java
index 7e02d07..0cabea3 100644
--- a/controller/src/main/java/io/pravega/controller/task/Stream/StreamTransactionMetadataTasks.java
+++ b/controller/src/main/java/io/pravega/controller/task/Stream/StreamTransactionMetadataTasks.java
@@ -13,6 +13,7 @@ import io.pravega.client.ClientFactory;
 import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.controller.server.SegmentHelper;
+import io.pravega.controller.server.rpc.auth.PravegaInterceptor;
 import io.pravega.controller.util.Config;
 import io.pravega.shared.controller.event.AbortEvent;
 import io.pravega.shared.controller.event.CommitEvent;
@@ -33,12 +34,12 @@ import io.pravega.controller.stream.api.grpc.v1.Controller.PingTxnStatus.Status;
 import io.pravega.controller.timeout.TimeoutService;
 import io.pravega.controller.timeout.TimeoutServiceConfig;
 import io.pravega.controller.timeout.TimerWheelTimeoutService;
+import java.time.Duration;
 import lombok.Getter;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.apache.commons.lang3.tuple.Pair;
 
-import java.time.Duration;
 import java.util.AbstractMap;
 import java.util.List;
 import java.util.Optional;
@@ -83,6 +84,8 @@ public class StreamTransactionMetadataTasks implements AutoCloseable {
     private final HostControllerStore hostControllerStore;
     private final SegmentHelper segmentHelper;
     private final ConnectionFactory connectionFactory;
+    private final boolean authorizationEnabled;
+    private final String tokenSigningKey;
     @Getter
     @VisibleForTesting
     private final TimeoutService timeoutService;
@@ -98,13 +101,17 @@ public class StreamTransactionMetadataTasks implements AutoCloseable {
                                           final String hostId,
                                           final TimeoutServiceConfig timeoutServiceConfig,
                                           final BlockingQueue<Optional<Throwable>> taskCompletionQueue,
-                                          final ConnectionFactory connectionFactory) {
+                                          final ConnectionFactory connectionFactory,
+                                          boolean authorizationEnabled,
+                                          String tokenSigningKey) {
         this.hostId = hostId;
         this.executor = executor;
         this.streamMetadataStore = streamMetadataStore;
         this.hostControllerStore = hostControllerStore;
         this.segmentHelper = segmentHelper;
         this.connectionFactory = connectionFactory;
+        this.authorizationEnabled = authorizationEnabled;
+        this.tokenSigningKey = tokenSigningKey;
         this.timeoutService = new TimerWheelTimeoutService(this, timeoutServiceConfig, taskCompletionQueue);
         readyLatch = new CountDownLatch(1);
     }
@@ -115,7 +122,7 @@ public class StreamTransactionMetadataTasks implements AutoCloseable {
                                           final ScheduledExecutorService executor,
                                           final String hostId,
                                           final TimeoutServiceConfig timeoutServiceConfig,
-                                          final ConnectionFactory connectionFactory) {
+                                          final ConnectionFactory connectionFactory, boolean authorizationEnabled, String tokenSigningKey) {
         this.hostId = hostId;
         this.executor = executor;
         this.streamMetadataStore = streamMetadataStore;
@@ -123,6 +130,8 @@ public class StreamTransactionMetadataTasks implements AutoCloseable {
         this.segmentHelper = segmentHelper;
         this.connectionFactory = connectionFactory;
         this.timeoutService = new TimerWheelTimeoutService(this, timeoutServiceConfig);
+        this.authorizationEnabled = authorizationEnabled;
+        this.tokenSigningKey = tokenSigningKey;
         readyLatch = new CountDownLatch(1);
     }
 
@@ -131,9 +140,11 @@ public class StreamTransactionMetadataTasks implements AutoCloseable {
                                           final SegmentHelper segmentHelper,
                                           final ScheduledExecutorService executor,
                                           final String hostId,
-                                          final ConnectionFactory connectionFactory) {
+                                          final ConnectionFactory connectionFactory,
+                                          boolean authorizationEnabled,
+                                          String tokenSigningKey) {
         this(streamMetadataStore, hostControllerStore, segmentHelper, executor, hostId,
-                TimeoutServiceConfig.defaultConfig(), connectionFactory);
+                TimeoutServiceConfig.defaultConfig(), connectionFactory, authorizationEnabled, tokenSigningKey);
     }
 
     protected void setReady() {
@@ -626,7 +637,7 @@ public class StreamTransactionMetadataTasks implements AutoCloseable {
                 segmentNumber,
                 txnId,
                 this.hostControllerStore,
-                this.connectionFactory), executor);
+                this.connectionFactory, this.retrieveDelegationToken()), executor);
     }
 
     private CompletableFuture<Void> checkReady() {
@@ -643,6 +654,14 @@ public class StreamTransactionMetadataTasks implements AutoCloseable {
         return contextOpt == null ? streamMetadataStore.createContext(scope, stream) : contextOpt;
     }
 
+    public String retrieveDelegationToken() {
+        if (authorizationEnabled) {
+            return PravegaInterceptor.retrieveDelegationToken(tokenSigningKey);
+        } else {
+            return "";
+        }
+    }
+
     @Override
     public void close() throws Exception {
         timeoutService.stopAsync();
diff --git a/controller/src/main/java/io/pravega/controller/util/Config.java b/controller/src/main/java/io/pravega/controller/util/Config.java
index 9789be6..5610417 100644
--- a/controller/src/main/java/io/pravega/controller/util/Config.java
+++ b/controller/src/main/java/io/pravega/controller/util/Config.java
@@ -9,18 +9,16 @@
  */
 package io.pravega.controller.util;
 
-import io.pravega.shared.metrics.MetricsConfig;
-import io.pravega.common.util.Property;
-import io.pravega.controller.server.rpc.grpc.GRPCServerConfig;
-import io.pravega.controller.server.rpc.grpc.impl.GRPCServerConfigImpl;
 import com.typesafe.config.ConfigException;
 import com.typesafe.config.ConfigFactory;
 import com.typesafe.config.ConfigResolveOptions;
 import com.typesafe.config.ConfigValue;
-
+import io.pravega.common.util.Property;
+import io.pravega.controller.server.rpc.grpc.GRPCServerConfig;
+import io.pravega.controller.server.rpc.grpc.impl.GRPCServerConfigImpl;
+import io.pravega.shared.metrics.MetricsConfig;
 import java.util.Map;
 import java.util.Set;
-
 import lombok.extern.slf4j.Slf4j;
 import lombok.val;
 
@@ -54,6 +52,13 @@ public final class Config {
     public static final boolean HOST_MONITOR_ENABLED = CONFIG.getBoolean("config.controller.server.hostMonitorEnabled");
     public static final String CLUSTER_NAME = CONFIG.getString("config.controller.server.cluster");
     public static final int CLUSTER_MIN_REBALANCE_INTERVAL = CONFIG.getInt("config.controller.server.minRebalanceInterval");
+    private static final boolean AUTHORIZATION_ENABLED = CONFIG.getBoolean("config.controller.server.authorizationEnabled");
+    private static final String USER_PASSWORD_FILE = CONFIG.getString("config.controller.server.userPasswordFile");
+    private static final boolean TLS_ENABLED = CONFIG.getBoolean("config.controller.server.tlsEnabled");
+    private static final String TLS_KEY_FILE = CONFIG.getString("config.controller.server.tlsKeyFile");
+    private static final String TLS_CERT_FILE = CONFIG.getString("config.controller.server.tlsCertFile");
+    private static final String TLS_TRUST_STORE = CONFIG.getString("config.controller.server.tlsTrustStore");
+    private static final String TOKEN_SIGNING_KEY = CONFIG.getString("config.controller.server.tokenSigningKey");
 
     //Zookeeper configuration.
     public static final String ZK_URL = CONFIG.getString("config.controller.server.zk.url");
@@ -102,6 +107,13 @@ public final class Config {
                 .port(Config.RPC_SERVER_PORT)
                 .publishedRPCHost(publishHost)
                 .publishedRPCPort(Config.RPC_PUBLISHED_SERVER_PORT)
+                .authorizationEnabled(Config.AUTHORIZATION_ENABLED)
+                .userPasswordFile(Config.USER_PASSWORD_FILE)
+                .tlsEnabled(Config.TLS_ENABLED)
+                .tlsCertFile(Config.TLS_CERT_FILE)
+                .tlsTrustStore(Config.TLS_TRUST_STORE)
+                .tlsKeyFile(Config.TLS_KEY_FILE)
+                                   .tokenSigningKey(Config.TOKEN_SIGNING_KEY)
                 .build();
     }
 
diff --git a/controller/src/main/resources/META-INF/services/io.pravega.auth.AuthHandler b/controller/src/main/resources/META-INF/services/io.pravega.auth.AuthHandler
new file mode 100644
index 0000000..1ea900e
--- /dev/null
+++ b/controller/src/main/resources/META-INF/services/io.pravega.auth.AuthHandler
@@ -0,0 +1,10 @@
+#
+# Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+io.pravega.controller.server.rpc.auth.PasswordAuthHandler
\ No newline at end of file
diff --git a/controller/src/main/resources/reference.conf b/controller/src/main/resources/reference.conf
index 37063a7..301dde9 100644
--- a/controller/src/main/resources/reference.conf
+++ b/controller/src/main/resources/reference.conf
@@ -19,6 +19,20 @@ CONTROLLER_RPC_PUBLISHED_PORT = ${CONTROLLER_SERVER_PORT}
 
 CLUSTER_NAME = pravega-cluster
 
+AUTHORIZATION_ENABLED = false
+
+USER_PASSWORD_FILE = ""
+
+TLS_ENABLED = false
+
+TLS_CERT_FILE = ""
+
+TLS_KEY_FILE = ""
+
+TLS_TRUST_STORE= ""
+
+TOKEN_SIGNING_KEY = ""
+
 HOST_MONITOR_ENABLE = true
 
 CLUSTER_MIN_REBALANCE_INTERVAL = 10
diff --git a/controller/src/test/java/io/pravega/controller/auth/PasswordEncryptorTool.java b/controller/src/test/java/io/pravega/controller/auth/PasswordEncryptorTool.java
new file mode 100644
index 0000000..c877fd4
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/auth/PasswordEncryptorTool.java
@@ -0,0 +1,25 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.auth;
+
+import io.pravega.controller.server.rpc.auth.StrongPasswordProcessor;
+import java.security.NoSuchAlgorithmException;
+import java.security.spec.InvalidKeySpecException;
+
+public class PasswordEncryptorTool {
+
+    public static void main(String[] args) throws InvalidKeySpecException, NoSuchAlgorithmException {
+        String userName = args[0];
+        String userPassword = args[1];
+        StrongPasswordProcessor passwordEncryptor = StrongPasswordProcessor.builder().build();
+        String encryptedPassword = passwordEncryptor.encryptPassword(userPassword);
+        System.out.println(encryptedPassword);
+    }
+}
diff --git a/controller/src/test/java/io/pravega/controller/auth/PasswordFileCreatorTool.java b/controller/src/test/java/io/pravega/controller/auth/PasswordFileCreatorTool.java
new file mode 100644
index 0000000..7165131
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/auth/PasswordFileCreatorTool.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.auth;
+
+import com.google.common.base.Strings;
+import io.pravega.controller.server.rpc.auth.StrongPasswordProcessor;
+import java.io.BufferedReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.security.NoSuchAlgorithmException;
+import java.security.spec.InvalidKeySpecException;
+
+public class PasswordFileCreatorTool {
+    public static void main(String[] args) throws IOException, InvalidKeySpecException, NoSuchAlgorithmException {
+        String fileName = args[0];
+
+        StrongPasswordProcessor passwordEncryptor = StrongPasswordProcessor.builder().build();
+        try (FileWriter writer = new FileWriter(fileName);
+             BufferedReader bufferRead = new BufferedReader(new InputStreamReader(System.in))) {
+            while (true) {
+                String s = bufferRead.readLine();
+                if (Strings.isNullOrEmpty(s)) {
+                    break;
+                }
+                String[] lists = s.split(":");
+                String toWrite = lists[0] + ":" + passwordEncryptor.encryptPassword(lists[1])
+                        + ":" + lists[2];
+                writer.write(toWrite + "\n");
+                writer.flush();
+            }
+        }
+    }
+}
diff --git a/controller/src/test/java/io/pravega/controller/auth/PasswordValidatorTool.java b/controller/src/test/java/io/pravega/controller/auth/PasswordValidatorTool.java
new file mode 100644
index 0000000..145aefc
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/auth/PasswordValidatorTool.java
@@ -0,0 +1,25 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.auth;
+
+import io.pravega.controller.server.rpc.auth.StrongPasswordProcessor;
+import java.security.NoSuchAlgorithmException;
+import java.security.spec.InvalidKeySpecException;
+
+public class PasswordValidatorTool {
+
+    public static void main(String[] args) throws InvalidKeySpecException, NoSuchAlgorithmException {
+        String userName = args[0];
+        String userPassword = args[1];
+        String encryptedPassword = args[2];
+        StrongPasswordProcessor passwordEncryptor = StrongPasswordProcessor.builder().build();
+        System.out.println( passwordEncryptor.checkPassword(userPassword, encryptedPassword));
+    }
+}
diff --git a/controller/src/test/java/io/pravega/controller/fault/ControllerClusterListenerTest.java b/controller/src/test/java/io/pravega/controller/fault/ControllerClusterListenerTest.java
index d847ed6..7b947de 100644
--- a/controller/src/test/java/io/pravega/controller/fault/ControllerClusterListenerTest.java
+++ b/controller/src/test/java/io/pravega/controller/fault/ControllerClusterListenerTest.java
@@ -131,7 +131,7 @@ public class ControllerClusterListenerTest {
         SegmentHelper segmentHelper = SegmentHelperMock.getSegmentHelperMock();
         ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
         StreamTransactionMetadataTasks txnTasks = new StreamTransactionMetadataTasks(streamStore, hostStore,
-                segmentHelper, executor, host.getHostId(), connectionFactory);
+                segmentHelper, executor, host.getHostId(), connectionFactory, false, "");
         txnTasks.initializeStreamWriters("commitStream", new EventStreamWriterMock<>(), "abortStream",
                 new EventStreamWriterMock<>());
         TxnSweeper txnSweeper = new TxnSweeper(streamStore, txnTasks, 100, executor);
@@ -207,7 +207,7 @@ public class ControllerClusterListenerTest {
         // create streamtransactionmetadatatasks but dont initialize it with writers. this will not be
         // ready until writers are supplied.
         StreamTransactionMetadataTasks txnTasks = new StreamTransactionMetadataTasks(streamStore, hostStore,
-                segmentHelper, executor, host.getHostId(), connectionFactory);
+                segmentHelper, executor, host.getHostId(), connectionFactory, false, "");
 
         TxnSweeper txnSweeper = spy(new TxnSweeper(streamStore, txnTasks, 100, executor));
         // any attempt to sweep txnHost should have been ignored
diff --git a/controller/src/test/java/io/pravega/controller/mocks/EventStreamWriterMock.java b/controller/src/test/java/io/pravega/controller/mocks/EventStreamWriterMock.java
index 2e8336b..700781d 100644
--- a/controller/src/test/java/io/pravega/controller/mocks/EventStreamWriterMock.java
+++ b/controller/src/test/java/io/pravega/controller/mocks/EventStreamWriterMock.java
@@ -13,14 +13,13 @@ import io.pravega.client.stream.EventStreamReader;
 import io.pravega.client.stream.EventStreamWriter;
 import io.pravega.client.stream.EventWriterConfig;
 import io.pravega.client.stream.Transaction;
-import org.apache.commons.lang3.NotImplementedException;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.LinkedBlockingQueue;
+import org.apache.commons.lang3.NotImplementedException;
 
 /**
  * Mock EventStreamWriter.
@@ -52,7 +51,7 @@ public class EventStreamWriterMock<T> implements EventStreamWriter<T> {
 
     @Override
     public EventWriterConfig getConfig() {
-        throw new NotImplementedException("getConfig");
+        throw new NotImplementedException("getClientConfig");
     }
 
     @Override
diff --git a/controller/src/test/java/io/pravega/controller/mocks/MockStreamTransactionMetadataTasks.java b/controller/src/test/java/io/pravega/controller/mocks/MockStreamTransactionMetadataTasks.java
index bd12069..8d0da09 100644
--- a/controller/src/test/java/io/pravega/controller/mocks/MockStreamTransactionMetadataTasks.java
+++ b/controller/src/test/java/io/pravega/controller/mocks/MockStreamTransactionMetadataTasks.java
@@ -44,8 +44,10 @@ public class MockStreamTransactionMetadataTasks extends StreamTransactionMetadat
                                               final SegmentHelper segmentHelper,
                                               final ScheduledExecutorService executor,
                                               final String hostId,
-                                              final ConnectionFactory connectionFactory) {
-        super(streamMetadataStore, hostControllerStore, segmentHelper, executor, hostId, connectionFactory);
+                                              final ConnectionFactory connectionFactory,
+                                              boolean authEnabled,
+                                              String tokenSigningKey) {
+        super(streamMetadataStore, hostControllerStore, segmentHelper, executor, hostId, connectionFactory, authEnabled, tokenSigningKey);
         this.streamMetadataStore = streamMetadataStore;
     }
 
diff --git a/controller/src/test/java/io/pravega/controller/mocks/SegmentHelperMock.java b/controller/src/test/java/io/pravega/controller/mocks/SegmentHelperMock.java
index 98f23de..01613e2 100644
--- a/controller/src/test/java/io/pravega/controller/mocks/SegmentHelperMock.java
+++ b/controller/src/test/java/io/pravega/controller/mocks/SegmentHelperMock.java
@@ -13,7 +13,6 @@ import io.pravega.common.concurrent.Futures;
 import io.pravega.controller.server.SegmentHelper;
 import io.pravega.controller.stream.api.grpc.v1.Controller.NodeUri;
 import io.pravega.shared.protocol.netty.WireCommands;
-
 import java.util.concurrent.CompletableFuture;
 
 import static org.mockito.ArgumentMatchers.any;
@@ -33,31 +32,31 @@ public class SegmentHelperMock {
                 anyString(), anyString(), anyInt(), any());
 
         doReturn(CompletableFuture.completedFuture(true)).when(helper).sealSegment(
-                anyString(), anyString(), anyInt(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any());
 
         doReturn(CompletableFuture.completedFuture(true)).when(helper).createSegment(
-                anyString(), anyString(), anyInt(), any(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any(), any());
 
         doReturn(CompletableFuture.completedFuture(true)).when(helper).deleteSegment(
-                anyString(), anyString(), anyInt(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any());
 
         doReturn(CompletableFuture.completedFuture(true)).when(helper).createTransaction(
-                anyString(), anyString(), anyInt(), any(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any(), any());
 
         doReturn(CompletableFuture.completedFuture(true)).when(helper).abortTransaction(
-                anyString(), anyString(), anyInt(), any(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any(), any());
 
         doReturn(CompletableFuture.completedFuture(true)).when(helper).commitTransaction(
-                anyString(), anyString(), anyInt(), any(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any(), any());
 
         doReturn(CompletableFuture.completedFuture(true)).when(helper).updatePolicy(
-                anyString(), anyString(), any(), anyInt(), any(), any());
+                anyString(), anyString(), any(), anyInt(), any(), any(), any());
 
         doReturn(CompletableFuture.completedFuture(true)).when(helper).truncateSegment(
-                anyString(), anyString(), anyInt(), anyLong(), any(), any());
+                anyString(), anyString(), anyInt(), anyLong(), any(), any(), any());
 
         doReturn(CompletableFuture.completedFuture(new WireCommands.StreamSegmentInfo(0L, "", true, true, false, 0L, 0L, 0L))).when(helper).getSegmentInfo(
-                anyString(), anyString(), anyInt(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), anyString());
 
         return helper;
     }
@@ -69,25 +68,25 @@ public class SegmentHelperMock {
                 anyString(), anyString(), anyInt(), any());
 
         doReturn(Futures.failedFuture(new RuntimeException())).when(helper).sealSegment(
-                anyString(), anyString(), anyInt(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any());
 
         doReturn(Futures.failedFuture(new RuntimeException())).when(helper).createSegment(
-                anyString(), anyString(), anyInt(), any(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any(), any());
 
         doReturn(Futures.failedFuture(new RuntimeException())).when(helper).deleteSegment(
-                anyString(), anyString(), anyInt(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any());
 
         doReturn(Futures.failedFuture(new RuntimeException())).when(helper).createTransaction(
-                anyString(), anyString(), anyInt(), any(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any(), any());
 
         doReturn(Futures.failedFuture(new RuntimeException())).when(helper).abortTransaction(
-                anyString(), anyString(), anyInt(), any(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any(), any());
 
         doReturn(Futures.failedFuture(new RuntimeException())).when(helper).commitTransaction(
-                anyString(), anyString(), anyInt(), any(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any(), any());
 
         doReturn(Futures.failedFuture(new RuntimeException())).when(helper).updatePolicy(
-                anyString(), anyString(), any(), anyInt(), any(), any());
+                anyString(), anyString(), any(), anyInt(), any(), any(), any());
 
         return helper;
     }
diff --git a/controller/src/test/java/io/pravega/controller/rest/v1/FailingSecureStreamMetaDataTests.java b/controller/src/test/java/io/pravega/controller/rest/v1/FailingSecureStreamMetaDataTests.java
new file mode 100644
index 0000000..a3f0be8
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/rest/v1/FailingSecureStreamMetaDataTests.java
@@ -0,0 +1,155 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.rest.v1;
+
+import io.grpc.ServerBuilder;
+import io.pravega.controller.server.rest.generated.model.CreateScopeRequest;
+import io.pravega.controller.server.rest.generated.model.StreamState;
+import io.pravega.controller.server.rpc.auth.PravegaAuthManager;
+import io.pravega.controller.server.rpc.grpc.impl.GRPCServerConfigImpl;
+import io.pravega.test.common.TestUtils;
+import java.util.Date;
+import java.util.concurrent.ExecutionException;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.core.Response;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class FailingSecureStreamMetaDataTests extends  StreamMetaDataTests {
+    @Override
+    @Before
+    public void setup() {
+        this.authManager = new PravegaAuthManager(GRPCServerConfigImpl.builder()
+                                                                      .authorizationEnabled(true)
+                                                                      .tlsCertFile("../config/cert.pem")
+                                                                      .tlsKeyFile("../config/key.pem")
+                                                                      .userPasswordFile("../config/passwd")
+                                                                      .port(1000)
+                                                                      .build());
+        ServerBuilder<?> server = ServerBuilder.forPort(TestUtils.getAvailableListenPort());
+        this.authManager.registerInterceptors(server);
+        super.setup();
+    }
+
+    @Override
+    @Test
+    public void testCreateStream() {
+        String streamResourceURI = getURI() + "v1/scopes/" + scope1 + "/streams";
+        Response response = addAuthHeaders(client.target(streamResourceURI).request()).buildPost(Entity.json(createStreamRequest)).invoke();
+        assertEquals("Create Stream Status", 401, response.getStatus());
+        response.close();
+    }
+
+    @Override
+    @Test
+    public void testUpdateStreamState() throws Exception {
+        final String resourceURI = getURI() + "v1/scopes/scope1/streams/stream1/state";
+        StreamState streamState = new StreamState().streamState(StreamState.StreamStateEnum.SEALED);
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(streamState)).invoke();
+        assertEquals("Update Stream State response code", 401, response.getStatus());
+        response.close();
+    }
+
+    @Override
+    @Test
+    public void testDeleteScope() throws ExecutionException, InterruptedException {
+        final String resourceURI = getURI() + "v1/scopes/scope1";
+
+        // Test to delete a scope.
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
+        assertEquals("Delete Scope response code", 401, response.getStatus());
+        response.close();
+    }
+
+    @Override
+    @Test
+    public void testGetScope() throws ExecutionException, InterruptedException {
+        final String resourceURI = getURI() + "v1/scopes/scope1";
+        final String resourceURI2 = getURI() + "v1/scopes/scope2";
+
+        // Test to get existent scope
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
+        assertEquals("Get existent scope", 401, response.getStatus());
+        response.close();
+    }
+
+    @Override
+    @Test
+    public void testCreateScope() throws ExecutionException, InterruptedException {
+        final CreateScopeRequest createScopeRequest = new CreateScopeRequest().scopeName(scope1);
+        final String resourceURI = getURI() + "v1/scopes/";
+
+        // Test to create a new scope.
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildPost(Entity.json(createScopeRequest)).invoke();
+        assertEquals("Create Scope response code", 401, response.getStatus());
+        response.close();
+    }
+
+    @Override
+    @Test
+    public void testUpdateStream() throws ExecutionException, InterruptedException {
+        String resourceURI = getURI() + "v1/scopes/" + scope1 + "/streams/stream1";
+
+        // Test to update an existing stream
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest)).invoke();
+        assertEquals("Update Stream Status", 401, response.getStatus());
+    }
+
+    @Override
+    @Test
+    public void testListReaderGroups() {
+        final String resourceURI = getURI() + "v1/scopes/scope1/readergroups";
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
+        assertEquals("List Reader Groups response code", 401, response.getStatus());
+    }
+
+    @Override
+    @Test
+    public void testDeleteStream() throws Exception {
+        final String resourceURI = getURI() + "v1/scopes/scope1/streams/stream1";
+
+        // Test to delete a sealed stream
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
+        assertEquals("Delete Stream response code", 401, response.getStatus());
+        response.close();
+    }
+
+    @Override
+    @Test
+    public void testGetScalingEvents() throws Exception {
+        String resourceURI = getURI() + "v1/scopes/scope1/streams/stream1/scaling-events";
+        Response response = addAuthHeaders(client.target(resourceURI).queryParam("from", new Date()).
+                queryParam("to", new Date()).request()).buildGet().invoke();
+        assertEquals("Get Scaling Events response code", 404, response.getStatus());
+
+    }
+
+    @Override
+    @Test
+    public void testGetStream() throws ExecutionException, InterruptedException {
+        String resourceURI = getURI() + "v1/scopes/" + scope1 + "/streams/stream1";
+        String resourceURI2 = getURI() + "v1/scopes/" + scope1 + "/streams/stream2";
+
+        // Test to get an existing stream
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
+        assertEquals("Get Stream Config Status", 401, response.getStatus());
+    }
+
+    @Override
+    @Test
+    public void testListStreams() throws ExecutionException, InterruptedException {
+        final String resourceURI = getURI() + "v1/scopes/scope1/streams";
+
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
+        assertEquals("List Streams response code", 401, response.getStatus());
+    }
+}
diff --git a/controller/src/test/java/io/pravega/controller/rest/v1/PingTest.java b/controller/src/test/java/io/pravega/controller/rest/v1/PingTest.java
index 9f481d7..cf461f3 100644
--- a/controller/src/test/java/io/pravega/controller/rest/v1/PingTest.java
+++ b/controller/src/test/java/io/pravega/controller/rest/v1/PingTest.java
@@ -9,23 +9,23 @@
  */
 package io.pravega.controller.rest.v1;
 
+import io.pravega.client.ClientConfig;
+import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.controller.server.ControllerService;
 import io.pravega.controller.server.rest.RESTServer;
 import io.pravega.controller.server.rest.RESTServerConfig;
 import io.pravega.controller.server.rest.impl.RESTServerConfigImpl;
 import io.pravega.test.common.TestUtils;
+import java.util.concurrent.TimeUnit;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.core.Response;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 
-import javax.ws.rs.client.Client;
-import javax.ws.rs.client.ClientBuilder;
-import javax.ws.rs.core.Response;
-
-import java.util.concurrent.TimeUnit;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 
@@ -47,7 +47,8 @@ public class PingTest {
         ControllerService mockControllerService = mock(ControllerService.class);
         serverConfig = RESTServerConfigImpl.builder().host("localhost").port(TestUtils.getAvailableListenPort())
                 .build();
-        restServer = new RESTServer(mockControllerService, serverConfig);
+        restServer = new RESTServer(null, mockControllerService, null, serverConfig,
+                new ConnectionFactoryImpl(ClientConfig.builder().build()));
         restServer.startAsync();
         restServer.awaitRunning();
         client = ClientBuilder.newClient();
diff --git a/controller/src/test/java/io/pravega/controller/rest/v1/SecureStreamMetaDataTests.java b/controller/src/test/java/io/pravega/controller/rest/v1/SecureStreamMetaDataTests.java
new file mode 100644
index 0000000..04a9f4e
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/rest/v1/SecureStreamMetaDataTests.java
@@ -0,0 +1,44 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.rest.v1;
+
+import io.grpc.ServerBuilder;
+import io.pravega.controller.server.rpc.auth.PravegaAuthManager;
+import io.pravega.controller.server.rpc.grpc.impl.GRPCServerConfigImpl;
+import io.pravega.test.common.TestUtils;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MultivaluedHashMap;
+import javax.ws.rs.core.MultivaluedMap;
+import org.junit.Before;
+
+public class SecureStreamMetaDataTests extends  StreamMetaDataTests {
+    @Override
+    @Before
+    public void setup() {
+        this.authManager = new PravegaAuthManager(GRPCServerConfigImpl.builder()
+                                                                      .authorizationEnabled(true)
+                                                                      .tlsCertFile("../config/cert.pem")
+                                                                      .tlsKeyFile("../config/key.pem")
+                                                                      .userPasswordFile("../config/passwd")
+                                                                      .port(1000)
+                                                                      .build());
+        ServerBuilder<?> server = ServerBuilder.forPort(TestUtils.getAvailableListenPort());
+        this.authManager.registerInterceptors(server);
+        super.setup();
+    }
+
+    @Override
+    protected Invocation.Builder addAuthHeaders(Invocation.Builder request) {
+        MultivaluedMap<String, Object> map = new MultivaluedHashMap<>();
+        map.addAll(HttpHeaders.AUTHORIZATION, "method:testHandler", "username:arvind", "password:1111_aaaa");
+        return request.headers(map);
+    }
+}
diff --git a/controller/src/test/java/io/pravega/controller/rest/v1/StreamMetaDataTests.java b/controller/src/test/java/io/pravega/controller/rest/v1/StreamMetaDataTests.java
index 22a72ad..519f73a 100644
--- a/controller/src/test/java/io/pravega/controller/rest/v1/StreamMetaDataTests.java
+++ b/controller/src/test/java/io/pravega/controller/rest/v1/StreamMetaDataTests.java
@@ -9,6 +9,13 @@
  */
 package io.pravega.controller.rest.v1;
 
+import io.pravega.client.ClientConfig;
+import io.pravega.client.netty.impl.ConnectionFactoryImpl;
+import io.pravega.client.stream.RetentionPolicy;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.controller.server.ControllerService;
+import io.pravega.controller.server.eventProcessor.LocalController;
 import io.pravega.controller.server.rest.RESTServer;
 import io.pravega.controller.server.rest.RESTServerConfig;
 import io.pravega.controller.server.rest.generated.model.CreateScopeRequest;
@@ -22,20 +29,18 @@ import io.pravega.controller.server.rest.generated.model.StreamState;
 import io.pravega.controller.server.rest.generated.model.StreamsList;
 import io.pravega.controller.server.rest.generated.model.UpdateStreamRequest;
 import io.pravega.controller.server.rest.impl.RESTServerConfigImpl;
+import io.pravega.controller.server.rpc.auth.PravegaAuthManager;
 import io.pravega.controller.store.stream.ScaleMetadata;
 import io.pravega.controller.store.stream.Segment;
-import io.pravega.shared.NameUtils;
-import io.pravega.controller.server.ControllerService;
 import io.pravega.controller.store.stream.StoreException;
 import io.pravega.controller.stream.api.grpc.v1.Controller.CreateScopeStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.CreateStreamStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.DeleteScopeStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.DeleteStreamStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.UpdateStreamStatus;
-import io.pravega.client.stream.RetentionPolicy;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.StreamConfiguration;
-
+import io.pravega.shared.NameUtils;
+import io.pravega.test.common.TestUtils;
+import java.net.URI;
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -47,10 +52,9 @@ import java.util.concurrent.TimeUnit;
 import javax.ws.rs.client.Client;
 import javax.ws.rs.client.ClientBuilder;
 import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation;
 import javax.ws.rs.core.GenericType;
 import javax.ws.rs.core.Response;
-
-import io.pravega.test.common.TestUtils;
 import lombok.extern.slf4j.Slf4j;
 import org.junit.After;
 import org.junit.Before;
@@ -78,16 +82,20 @@ public class StreamMetaDataTests {
     @Rule
     public Timeout globalTimeout = new Timeout(30, TimeUnit.SECONDS);
 
-    ControllerService mockControllerService;
+    protected final String scope1 = "scope1";
+    protected final CreateStreamRequest createStreamRequest = new CreateStreamRequest();
+    protected final UpdateStreamRequest updateStreamRequest = new UpdateStreamRequest();
+    protected ControllerService mockControllerService;
+    protected PravegaAuthManager authManager = null;
+    protected Client client;
+
     private RESTServerConfig serverConfig;
     private RESTServer restServer;
-    private Client client;
 
     private final String stream1 = "stream1";
     private final String stream2 = "stream2";
     private final String stream3 = "stream3";
     private final String stream4 = "stream4";
-    private final String scope1 = "scope1";
 
     private final ScalingConfig scalingPolicyCommon = new ScalingConfig();
     private final ScalingConfig scalingPolicyCommon2 = new ScalingConfig();
@@ -103,12 +111,10 @@ public class StreamMetaDataTests {
             .retentionPolicy(RetentionPolicy.byTime(Duration.ofDays(123L)))
             .build();
 
-    private final CreateStreamRequest createStreamRequest = new CreateStreamRequest();
     private final CreateStreamRequest createStreamRequest2 = new CreateStreamRequest();
     private final CreateStreamRequest createStreamRequest3 = new CreateStreamRequest();
     private final CreateStreamRequest createStreamRequest4 = new CreateStreamRequest();
     private final CreateStreamRequest createStreamRequest5 = new CreateStreamRequest();
-    private final UpdateStreamRequest updateStreamRequest = new UpdateStreamRequest();
     private final UpdateStreamRequest updateStreamRequest2 = new UpdateStreamRequest();
     private final UpdateStreamRequest updateStreamRequest3 = new UpdateStreamRequest();
 
@@ -135,7 +141,11 @@ public class StreamMetaDataTests {
     public void setup() {
         mockControllerService = mock(ControllerService.class);
         serverConfig = RESTServerConfigImpl.builder().host("localhost").port(TestUtils.getAvailableListenPort()).build();
-        restServer = new RESTServer(mockControllerService, serverConfig);
+        LocalController controller = new LocalController(mockControllerService, false, "");
+        restServer = new RESTServer(controller, mockControllerService, authManager, serverConfig,
+                new ConnectionFactoryImpl(ClientConfig.builder()
+                                                      .controllerURI(URI.create("tcp://localhost"))
+                                                      .build()));
         restServer.startAsync();
         restServer.awaitRunning();
         client = ClientBuilder.newClient();
@@ -215,7 +225,7 @@ public class StreamMetaDataTests {
 
         // Test to create a stream which doesn't exist
         when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus);
-        Response response = client.target(streamResourceURI).request().buildPost(Entity.json(createStreamRequest)).invoke();
+        Response response = addAuthHeaders(client.target(streamResourceURI).request()).buildPost(Entity.json(createStreamRequest)).invoke();
         assertEquals("Create Stream Status", 201, response.getStatus());
         StreamProperty streamResponseActual = response.readEntity(StreamProperty.class);
         testExpectedVsActualObject(streamResponseExpected, streamResponseActual);
@@ -223,7 +233,7 @@ public class StreamMetaDataTests {
 
         // Test to create a stream which doesn't exist and has no Retention Policy set.
         when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus);
-        response = client.target(streamResourceURI).request().buildPost(Entity.json(createStreamRequest4)).invoke();
+        response = addAuthHeaders(client.target(streamResourceURI).request()).buildPost(Entity.json(createStreamRequest4)).invoke();
         assertEquals("Create Stream Status", 201, response.getStatus());
         streamResponseActual = response.readEntity(StreamProperty.class);
         testExpectedVsActualObject(streamResponseExpected2, streamResponseActual);
@@ -233,13 +243,13 @@ public class StreamMetaDataTests {
         final CreateStreamRequest streamRequest = new CreateStreamRequest();
         streamRequest.setStreamName(NameUtils.getInternalNameForStream("stream"));
         when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus2);
-        response = client.target(streamResourceURI).request().buildPost(Entity.json(streamRequest)).invoke();
+        response = addAuthHeaders(client.target(streamResourceURI).request()).buildPost(Entity.json(streamRequest)).invoke();
         assertEquals("Create Stream Status", 400, response.getStatus());
         response.close();
 
         // Test to create a stream which doesn't exist and have Scaling Policy FIXED_NUM_SEGMENTS
         when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus);
-        response = client.target(streamResourceURI).request().buildPost(Entity.json(createStreamRequest5)).invoke();
+        response = addAuthHeaders(client.target(streamResourceURI).request()).buildPost(Entity.json(createStreamRequest5)).invoke();
         assertEquals("Create Stream Status", 201, response.getStatus());
         streamResponseActual = response.readEntity(StreamProperty.class);
         testExpectedVsActualObject(streamResponseExpected3, streamResponseActual);
@@ -247,13 +257,13 @@ public class StreamMetaDataTests {
 
         // Test to create a stream that already exists
         when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus2);
-        response = client.target(streamResourceURI).request().buildPost(Entity.json(createStreamRequest)).invoke();
+        response = addAuthHeaders(client.target(streamResourceURI).request()).buildPost(Entity.json(createStreamRequest)).invoke();
         assertEquals("Create Stream Status", 409, response.getStatus());
         response.close();
 
         // Test for validation of create stream request object
         when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus3);
-        response = client.target(streamResourceURI).request().buildPost(Entity.json(createStreamRequest2)).invoke();
+        response = addAuthHeaders(client.target(streamResourceURI).request()).buildPost(Entity.json(createStreamRequest2)).invoke();
         // TODO: Server should be returning 400 here, change this once issue
         // https://github.com/pravega/pravega/issues/531 is fixed.
         assertEquals("Create Stream Status", 500, response.getStatus());
@@ -261,7 +271,7 @@ public class StreamMetaDataTests {
 
         // Test create stream for non-existent scope
         when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus4);
-        response = client.target(streamResourceURI).request().buildPost(Entity.json(createStreamRequest3)).invoke();
+        response = addAuthHeaders(client.target(streamResourceURI).request()).buildPost(Entity.json(createStreamRequest3)).invoke();
         assertEquals("Create Stream Status for non-existent scope", 404, response.getStatus());
         response.close();
     }
@@ -278,14 +288,14 @@ public class StreamMetaDataTests {
 
         // Test to update an existing stream
         when(mockControllerService.updateStream(any())).thenReturn(updateStreamStatus);
-        Response response = client.target(resourceURI).request().buildPut(Entity.json(updateStreamRequest)).invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest)).invoke();
         assertEquals("Update Stream Status", 200, response.getStatus());
         StreamProperty streamResponseActual = response.readEntity(StreamProperty.class);
         testExpectedVsActualObject(streamResponseExpected, streamResponseActual);
         response.close();
 
         // Test sending extra fields in the request object to check if json parser can handle it.
-        response = client.target(resourceURI).request().buildPut(Entity.json(createStreamRequest)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(createStreamRequest)).invoke();
         assertEquals("Update Stream Status", 200, response.getStatus());
         streamResponseActual = response.readEntity(StreamProperty.class);
         testExpectedVsActualObject(streamResponseExpected, streamResponseActual);
@@ -293,13 +303,13 @@ public class StreamMetaDataTests {
 
         // Test to update an non-existing stream
         when(mockControllerService.updateStream(any())).thenReturn(updateStreamStatus2);
-        response = client.target(resourceURI).request().buildPut(Entity.json(updateStreamRequest2)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest2)).invoke();
         assertEquals("Update Stream Status", 404, response.getStatus());
         response.close();
 
         // Test for validation of request object
         when(mockControllerService.updateStream(any())).thenReturn(updateStreamStatus3);
-        response = client.target(resourceURI).request().buildPut(Entity.json(updateStreamRequest3)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest3)).invoke();
         // TODO: Server should be returning 400 here, change this once issue
         // https://github.com/pravega/pravega/issues/531 is fixed.
         assertEquals("Update Stream Status", 500, response.getStatus());
@@ -307,11 +317,15 @@ public class StreamMetaDataTests {
 
         // Test to update stream for non-existent scope
         when(mockControllerService.updateStream(any())).thenReturn(updateStreamStatus4);
-        response = client.target(resourceURI).request().buildPut(Entity.json(updateStreamRequest)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest)).invoke();
         assertEquals("Update Stream Status", 404, response.getStatus());
         response.close();
     }
 
+    protected Invocation.Builder addAuthHeaders(Invocation.Builder request) {
+        return request;
+    }
+
     /**
      * Test for getStreamConfig REST API
      *
@@ -325,7 +339,7 @@ public class StreamMetaDataTests {
 
         // Test to get an existing stream
         when(mockControllerService.getStream(scope1, stream1)).thenReturn(streamConfigFuture);
-        Response response = client.target(resourceURI).request().buildGet().invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("Get Stream Config Status", 200, response.getStatus());
         StreamProperty streamResponseActual = response.readEntity(StreamProperty.class);
         testExpectedVsActualObject(streamResponseExpected, streamResponseActual);
@@ -335,7 +349,7 @@ public class StreamMetaDataTests {
         when(mockControllerService.getStream(scope1, stream2)).thenReturn(CompletableFuture.supplyAsync(() -> {
             throw StoreException.create(StoreException.Type.DATA_NOT_FOUND, stream2);
         }));
-        response = client.target(resourceURI2).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI2).request()).buildGet().invoke();
         assertEquals("Get Stream Config Status", 404, response.getStatus());
         response.close();
     }
@@ -352,28 +366,28 @@ public class StreamMetaDataTests {
         // Test to delete a sealed stream
         when(mockControllerService.deleteStream(scope1, stream1)).thenReturn(CompletableFuture.completedFuture(
                 DeleteStreamStatus.newBuilder().setStatus(DeleteStreamStatus.Status.SUCCESS).build()));
-        Response response = client.target(resourceURI).request().buildDelete().invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
         assertEquals("Delete Stream response code", 204, response.getStatus());
         response.close();
 
         // Test to delete a unsealed stream
         when(mockControllerService.deleteStream(scope1, stream1)).thenReturn(CompletableFuture.completedFuture(
                 DeleteStreamStatus.newBuilder().setStatus(DeleteStreamStatus.Status.STREAM_NOT_SEALED).build()));
-        response = client.target(resourceURI).request().buildDelete().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
         assertEquals("Delete Stream response code", 412, response.getStatus());
         response.close();
 
         // Test to delete a non existent stream
         when(mockControllerService.deleteStream(scope1, stream1)).thenReturn(CompletableFuture.completedFuture(
                 DeleteStreamStatus.newBuilder().setStatus(DeleteStreamStatus.Status.STREAM_NOT_FOUND).build()));
-        response = client.target(resourceURI).request().buildDelete().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
         assertEquals("Delete Stream response code", 404, response.getStatus());
         response.close();
 
         // Test to delete a stream giving an internal server error
         when(mockControllerService.deleteStream(scope1, stream1)).thenReturn(CompletableFuture.completedFuture(
                 DeleteStreamStatus.newBuilder().setStatus(DeleteStreamStatus.Status.FAILURE).build()));
-        response = client.target(resourceURI).request().buildDelete().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
         assertEquals("Delete Stream response code", 500, response.getStatus());
         response.close();
     }
@@ -392,21 +406,21 @@ public class StreamMetaDataTests {
         // Test to create a new scope.
         when(mockControllerService.createScope(scope1)).thenReturn(CompletableFuture.completedFuture(
                 CreateScopeStatus.newBuilder().setStatus(CreateScopeStatus.Status.SUCCESS).build()));
-        Response response = client.target(resourceURI).request().buildPost(Entity.json(createScopeRequest)).invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildPost(Entity.json(createScopeRequest)).invoke();
         assertEquals("Create Scope response code", 201, response.getStatus());
         response.close();
 
         // Test to create an existing scope.
         when(mockControllerService.createScope(scope1)).thenReturn(CompletableFuture.completedFuture(
                 CreateScopeStatus.newBuilder().setStatus(CreateScopeStatus.Status.SCOPE_EXISTS).build()));
-        response = client.target(resourceURI).request().buildPost(Entity.json(createScopeRequest)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPost(Entity.json(createScopeRequest)).invoke();
         assertEquals("Create Scope response code", 409, response.getStatus());
         response.close();
 
         // create scope failure.
         when(mockControllerService.createScope(scope1)).thenReturn(CompletableFuture.completedFuture(
                 CreateScopeStatus.newBuilder().setStatus(CreateScopeStatus.Status.FAILURE).build()));
-        response = client.target(resourceURI).request().buildPost(Entity.json(createScopeRequest)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPost(Entity.json(createScopeRequest)).invoke();
         assertEquals("Create Scope response code", 500, response.getStatus());
         response.close();
 
@@ -414,7 +428,7 @@ public class StreamMetaDataTests {
         when(mockControllerService.createScope(scope1)).thenReturn(CompletableFuture.completedFuture(
                 CreateScopeStatus.newBuilder().setStatus(CreateScopeStatus.Status.SCOPE_EXISTS).build()));
         createScopeRequest.setScopeName("_system");
-        response = client.target(resourceURI).request().buildPost(Entity.json(createScopeRequest)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPost(Entity.json(createScopeRequest)).invoke();
         assertEquals("Create Scope response code", 400, response.getStatus());
         response.close();
     }
@@ -432,28 +446,28 @@ public class StreamMetaDataTests {
         // Test to delete a scope.
         when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(
                 DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.SUCCESS).build()));
-        Response response = client.target(resourceURI).request().buildDelete().invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
         assertEquals("Delete Scope response code", 204, response.getStatus());
         response.close();
 
         // Test to delete scope with existing streams.
         when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(
                 DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.SCOPE_NOT_EMPTY).build()));
-        response = client.target(resourceURI).request().buildDelete().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
         assertEquals("Delete Scope response code", 412, response.getStatus());
         response.close();
 
         // Test to delete non-existing scope.
         when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(
                 DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.SCOPE_NOT_FOUND).build()));
-        response = client.target(resourceURI).request().buildDelete().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
         assertEquals("Delete Scope response code", 404, response.getStatus());
         response.close();
 
         // Test delete scope failure.
         when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(
                 DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.FAILURE).build()));
-        response = client.target(resourceURI).request().buildDelete().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke();
         assertEquals("Delete Scope response code", 500, response.getStatus());
         response.close();
     }
@@ -471,7 +485,7 @@ public class StreamMetaDataTests {
 
         // Test to get existent scope
         when(mockControllerService.getScope(scope1)).thenReturn(CompletableFuture.completedFuture("scope1"));
-        Response response = client.target(resourceURI).request().buildGet().invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("Get existent scope", 200, response.getStatus());
         response.close();
 
@@ -479,7 +493,7 @@ public class StreamMetaDataTests {
         when(mockControllerService.getScope("scope2")).thenReturn(CompletableFuture.supplyAsync(() -> {
             throw StoreException.create(StoreException.Type.DATA_NOT_FOUND, "scope2");
         }));
-        response = client.target(resourceURI2).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI2).request()).buildGet().invoke();
         assertEquals("Get non existent scope", 404, response.getStatus());
         response.close();
 
@@ -487,7 +501,7 @@ public class StreamMetaDataTests {
         final CompletableFuture<String> completableFuture2 = new CompletableFuture<>();
         completableFuture2.completeExceptionally(new Exception());
         when(mockControllerService.getScope(scope1)).thenReturn(completableFuture2);
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("Get scope fail test", 500, response.getStatus());
         response.close();
     }
@@ -505,7 +519,7 @@ public class StreamMetaDataTests {
         // Test to list scopes.
         List<String> scopesList = Arrays.asList("scope1", "scope2");
         when(mockControllerService.listScopes()).thenReturn(CompletableFuture.completedFuture(scopesList));
-        Response response = client.target(resourceURI).request().buildGet().invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Scopes response code", 200, response.getStatus());
         assertTrue(response.bufferEntity());
         final ScopesList scopesList1 = response.readEntity(ScopesList.class);
@@ -518,7 +532,7 @@ public class StreamMetaDataTests {
         final CompletableFuture<List<String>> completableFuture = new CompletableFuture<>();
         completableFuture.completeExceptionally(new Exception());
         when(mockControllerService.listScopes()).thenReturn(completableFuture);
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Scopes response code", 500, response.getStatus());
         response.close();
     }
@@ -551,7 +565,7 @@ public class StreamMetaDataTests {
         List<StreamConfiguration> streamsList = Arrays.asList(streamConfiguration1, streamConfiguration2);
 
         when(mockControllerService.listStreamsInScope("scope1")).thenReturn(CompletableFuture.completedFuture(streamsList));
-        Response response = client.target(resourceURI).request().buildGet().invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Streams response code", 200, response.getStatus());
         assertTrue(response.bufferEntity());
         final StreamsList streamsList1 = response.readEntity(StreamsList.class);
@@ -564,7 +578,7 @@ public class StreamMetaDataTests {
         final CompletableFuture<List<StreamConfiguration>> completableFuture1 = new CompletableFuture<>();
         completableFuture1.completeExceptionally(StoreException.create(StoreException.Type.DATA_NOT_FOUND, "scope1"));
         when(mockControllerService.listStreamsInScope("scope1")).thenReturn(completableFuture1);
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Streams response code", 404, response.getStatus());
         response.close();
 
@@ -572,7 +586,7 @@ public class StreamMetaDataTests {
         final CompletableFuture<List<StreamConfiguration>> completableFuture = new CompletableFuture<>();
         completableFuture.completeExceptionally(new Exception());
         when(mockControllerService.listStreamsInScope("scope1")).thenReturn(completableFuture);
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Streams response code", 500, response.getStatus());
         response.close();
 
@@ -586,7 +600,7 @@ public class StreamMetaDataTests {
                 streamConfiguration3);
         when(mockControllerService.listStreamsInScope("scope1")).thenReturn(
                 CompletableFuture.completedFuture(allStreamsList));
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Streams response code", 200, response.getStatus());
         assertTrue(response.bufferEntity());
         StreamsList streamsListResp = response.readEntity(StreamsList.class);
@@ -595,7 +609,7 @@ public class StreamMetaDataTests {
         assertEquals("List element", "stream2", streamsListResp.getStreams().get(1).getStreamName());
         response.close();
 
-        response = client.target(resourceURI).queryParam("showInternalStreams", "true").request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).queryParam("showInternalStreams", "true").request()).buildGet().invoke();
         assertEquals("List Streams response code", 200, response.getStatus());
         assertTrue(response.bufferEntity());
         streamsListResp = response.readEntity(StreamsList.class);
@@ -607,7 +621,7 @@ public class StreamMetaDataTests {
         // Test to list large number of streams.
         streamsList = Collections.nCopies(50000, streamConfiguration1);
         when(mockControllerService.listStreamsInScope("scope1")).thenReturn(CompletableFuture.completedFuture(streamsList));
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Streams response code", 200, response.getStatus());
         assertTrue(response.bufferEntity());
         final StreamsList streamsList2 = response.readEntity(StreamsList.class);
@@ -626,7 +640,7 @@ public class StreamMetaDataTests {
         when(mockControllerService.sealStream("scope1", "stream1")).thenReturn(CompletableFuture.completedFuture(
                 UpdateStreamStatus.newBuilder().setStatus(UpdateStreamStatus.Status.SUCCESS).build()));
         StreamState streamState = new StreamState().streamState(StreamState.StreamStateEnum.SEALED);
-        Response response = client.target(resourceURI).request().buildPut(Entity.json(streamState)).invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(streamState)).invoke();
         assertEquals("Update Stream State response code", 200, response.getStatus());
         response.close();
 
@@ -634,7 +648,7 @@ public class StreamMetaDataTests {
         when(mockControllerService.sealStream(scope1, stream1)).thenReturn(CompletableFuture.completedFuture(
                 UpdateStreamStatus.newBuilder().setStatus(UpdateStreamStatus.Status.SCOPE_NOT_FOUND).build()));
         streamState = new StreamState().streamState(StreamState.StreamStateEnum.SEALED);
-        response = client.target(resourceURI).request().buildPut(Entity.json(streamState)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(streamState)).invoke();
         assertEquals("Update Stream State response code", 404, response.getStatus());
         response.close();
 
@@ -642,7 +656,7 @@ public class StreamMetaDataTests {
         when(mockControllerService.sealStream(scope1, stream1)).thenReturn(CompletableFuture.completedFuture(
                 UpdateStreamStatus.newBuilder().setStatus(UpdateStreamStatus.Status.STREAM_NOT_FOUND).build()));
         streamState = new StreamState().streamState(StreamState.StreamStateEnum.SEALED);
-        response = client.target(resourceURI).request().buildPut(Entity.json(streamState)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(streamState)).invoke();
         assertEquals("Update Stream State response code", 404, response.getStatus());
         response.close();
 
@@ -650,7 +664,7 @@ public class StreamMetaDataTests {
         when(mockControllerService.sealStream(scope1, stream1)).thenReturn(CompletableFuture.completedFuture(
                 UpdateStreamStatus.newBuilder().setStatus(UpdateStreamStatus.Status.FAILURE).build()));
         streamState = new StreamState().streamState(StreamState.StreamStateEnum.SEALED);
-        response = client.target(resourceURI).request().buildPut(Entity.json(streamState)).invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(streamState)).invoke();
         assertEquals("Update Stream State response code", 500, response.getStatus());
         response.close();
     }
@@ -712,8 +726,8 @@ public class StreamMetaDataTests {
 
         when(mockControllerService.getScaleRecords(scope1, stream1)).
                 thenReturn(CompletableFuture.completedFuture(scaleMetadataList));
-        Response response = client.target(resourceURI).queryParam("from", fromDateTime).
-                queryParam("to", toDateTime).request().buildGet().invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).queryParam("from", fromDateTime).
+                queryParam("to", toDateTime).request()).buildGet().invoke();
         assertEquals("Get Scaling Events response code", 200, response.getStatus());
         assertTrue(response.bufferEntity());
         List<ScaleMetadata> scaleMetadataListResponse = response.readEntity(
@@ -732,8 +746,8 @@ public class StreamMetaDataTests {
         scaleMetadataList.addAll(Collections.nCopies(50000, scaleMetadata3));
         when(mockControllerService.getScaleRecords(scope1, stream1)).
                 thenReturn(CompletableFuture.completedFuture(scaleMetadataList));
-        response = client.target(resourceURI).queryParam("from", fromDateTime).
-                queryParam("to", toDateTime).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).queryParam("from", fromDateTime).
+                queryParam("to", toDateTime).request()).buildGet().invoke();
         assertEquals("Get Scaling Events response code", 200, response.getStatus());
         assertTrue(response.bufferEntity());
         scaleMetadataListResponse = response.readEntity(
@@ -744,23 +758,23 @@ public class StreamMetaDataTests {
         final CompletableFuture<List<ScaleMetadata>> completableFuture1 = new CompletableFuture<>();
         completableFuture1.completeExceptionally(StoreException.create(StoreException.Type.DATA_NOT_FOUND, "stream1"));
         when(mockControllerService.getScaleRecords("scope1", "stream1")).thenReturn(completableFuture1);
-        response = client.target(resourceURI).queryParam("from", fromDateTime).
-                queryParam("to", toDateTime).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).queryParam("from", fromDateTime).
+                queryParam("to", toDateTime).request()).buildGet().invoke();
         assertEquals("Get Scaling Events response code", 404, response.getStatus());
 
         // Test for getScalingEvents for bad request.
         // from > to is tested here
         when(mockControllerService.getScaleRecords("scope1", "stream1")).
                 thenReturn(CompletableFuture.completedFuture(scaleMetadataList));
-        response = client.target(resourceURI).queryParam("from", fromDateTime * 2).
-                queryParam("to", fromDateTime).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).queryParam("from", fromDateTime * 2).
+                queryParam("to", fromDateTime).request()).buildGet().invoke();
         assertEquals("Get Scaling Events response code", 400, response.getStatus());
 
         // Test for getScalingEvents failure.
         final CompletableFuture<List<ScaleMetadata>> completableFuture = new CompletableFuture<>();
         completableFuture.completeExceptionally(new Exception());
         when(mockControllerService.getScaleRecords("scope1", "stream1")).thenReturn(completableFuture);
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("Get Scaling Events response code", 500, response.getStatus());
     }
 
@@ -796,7 +810,7 @@ public class StreamMetaDataTests {
         List<StreamConfiguration> streamsList = Arrays.asList(streamconf1, streamconf2, readerGroup1, readerGroup2);
         when(mockControllerService.listStreamsInScope(scope1)).thenReturn(CompletableFuture.completedFuture(
                 streamsList));
-        Response response = client.target(resourceURI).request().buildGet().invoke();
+        Response response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Reader Groups response code", 200, response.getStatus());
         assertTrue(response.bufferEntity());
         final ReaderGroupsList readerGroupsList1 = response.readEntity(ReaderGroupsList.class);
@@ -811,7 +825,7 @@ public class StreamMetaDataTests {
         final CompletableFuture<List<StreamConfiguration>> completableFuture1 = new CompletableFuture<>();
         completableFuture1.completeExceptionally(StoreException.create(StoreException.Type.DATA_NOT_FOUND, "scope1"));
         when(mockControllerService.listStreamsInScope("scope1")).thenReturn(completableFuture1);
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Reader Groups response code", 404, response.getStatus());
         response.close();
 
@@ -819,7 +833,7 @@ public class StreamMetaDataTests {
         final CompletableFuture<List<StreamConfiguration>> completableFuture = new CompletableFuture<>();
         completableFuture.completeExceptionally(new Exception());
         when(mockControllerService.listStreamsInScope("scope1")).thenReturn(completableFuture);
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Reader Groups response code", 500, response.getStatus());
         response.close();
 
@@ -827,7 +841,7 @@ public class StreamMetaDataTests {
         streamsList = Collections.nCopies(50000, readerGroup1);
         when(mockControllerService.listStreamsInScope("scope1")).thenReturn(
                 CompletableFuture.completedFuture(streamsList));
-        response = client.target(resourceURI).request().buildGet().invoke();
+        response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke();
         assertEquals("List Reader Groups response code", 200, response.getStatus());
         assertTrue(response.bufferEntity());
         final ReaderGroupsList readerGroupsList = response.readEntity(ReaderGroupsList.class);
@@ -857,7 +871,7 @@ public class StreamMetaDataTests {
                 actual.getRetentionPolicy());
     }
 
-    private String getURI() {
+    protected String getURI() {
         return "http://localhost:" + serverConfig.getPort() + "/";
     }
 }
diff --git a/controller/src/test/java/io/pravega/controller/server/ControllerServiceStarterTest.java b/controller/src/test/java/io/pravega/controller/server/ControllerServiceStarterTest.java
index d33106b..3ad654b 100644
--- a/controller/src/test/java/io/pravega/controller/server/ControllerServiceStarterTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/ControllerServiceStarterTest.java
@@ -9,8 +9,10 @@
  */
 package io.pravega.controller.server;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.admin.StreamManager;
 import io.pravega.client.admin.impl.StreamManagerImpl;
+import io.pravega.client.stream.impl.DefaultCredentials;
 import io.pravega.controller.server.impl.ControllerServiceConfigImpl;
 import io.pravega.controller.server.rpc.grpc.impl.GRPCServerConfigImpl;
 import io.pravega.controller.store.client.StoreClient;
@@ -20,16 +22,15 @@ import io.pravega.controller.store.host.impl.HostMonitorConfigImpl;
 import io.pravega.controller.timeout.TimeoutServiceConfig;
 import io.pravega.controller.util.Config;
 import io.pravega.test.common.TestUtils;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Optional;
 import lombok.extern.slf4j.Slf4j;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.Optional;
-
 /**
  * ControllerServiceStarter tests.
  */
@@ -39,9 +40,11 @@ public abstract class ControllerServiceStarterTest {
     protected StoreClient storeClient;
     private final boolean disableControllerCluster;
     private final int grpcPort;
+    private final boolean enableAuth;
 
-    ControllerServiceStarterTest(final boolean disableControllerCluster) {
+    ControllerServiceStarterTest(final boolean disableControllerCluster, boolean enableAuth) {
         this.disableControllerCluster = disableControllerCluster;
+        this.enableAuth = enableAuth;
         this.grpcPort = TestUtils.getAvailableListenPort();
     }
 
@@ -67,7 +70,7 @@ public abstract class ControllerServiceStarterTest {
         // Now, that starter has started, perform some rpc operations.
         URI uri;
         try {
-            uri = new URI("tcp://localhost:" + grpcPort);
+            uri = new URI( (enableAuth ? "tls" : "tcp") + "://localhost:" + grpcPort);
         } catch (URISyntaxException e) {
             log.error("Error creating controller URI", e);
             Assert.fail("Error creating controller URI");
@@ -75,7 +78,10 @@ public abstract class ControllerServiceStarterTest {
         }
 
         final String testScope = "testScope";
-        StreamManager streamManager = new StreamManagerImpl(uri);
+        StreamManager streamManager = new StreamManagerImpl(ClientConfig.builder().controllerURI(uri)
+                                                                        .credentials(new DefaultCredentials("1111_aaaa", "admin"))
+                                                                        .trustStore("../config/cert.pem").build());
+
         streamManager.createScope(testScope);
         streamManager.deleteScope(testScope);
         streamManager.close();
@@ -110,7 +116,13 @@ public abstract class ControllerServiceStarterTest {
                 .hostMonitorConfig(hostMonitorConfig)
                 .timeoutServiceConfig(timeoutServiceConfig)
                 .eventProcessorConfig(Optional.empty())
-                .grpcServerConfig(Optional.of(GRPCServerConfigImpl.builder().port(grpcPort).build()))
+                .grpcServerConfig(Optional.of(GRPCServerConfigImpl.builder()
+                                                                  .port(grpcPort)
+                                                                  .authorizationEnabled(enableAuth)
+                                                                  .tlsEnabled(enableAuth)
+                                                                  .tlsCertFile("../config/cert.pem")
+                                                                  .tlsKeyFile("../config/key.pem")
+                                                                  .build()))
                 .restServerConfig(Optional.empty())
                 .build();
     }
diff --git a/controller/src/test/java/io/pravega/controller/server/ControllerServiceWithZKStreamTest.java b/controller/src/test/java/io/pravega/controller/server/ControllerServiceWithZKStreamTest.java
index a2e3d86..bde43bb 100644
--- a/controller/src/test/java/io/pravega/controller/server/ControllerServiceWithZKStreamTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/ControllerServiceWithZKStreamTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.controller.server;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.StreamConfiguration;
@@ -34,6 +35,14 @@ import io.pravega.controller.stream.api.grpc.v1.Controller;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.task.Stream.StreamTransactionMetadataTasks;
 import io.pravega.test.common.TestingServerStarter;
+import java.net.URI;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.atomic.AtomicBoolean;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.curator.framework.CuratorFramework;
 import org.apache.curator.framework.CuratorFrameworkFactory;
@@ -43,14 +52,6 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 
@@ -90,9 +91,11 @@ public class ControllerServiceWithZKStreamTest {
         HostControllerStore hostStore = HostStoreFactory.createInMemoryStore(HostMonitorConfigImpl.dummyConfig());
 
         SegmentHelper segmentHelperMock = SegmentHelperMock.getSegmentHelperMock();
-        connectionFactory = new ConnectionFactoryImpl(false);
+        connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder()
+                                                                  .controllerURI(URI.create("tcp://localhost"))
+                                                                  .build());
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore, taskMetadataStore, segmentHelperMock,
-                executor, "host", connectionFactory);
+                executor, "host", connectionFactory, false, "");
         this.streamRequestHandler = new StreamRequestHandler(new AutoScaleTask(streamMetadataTasks, streamStore, executor),
                 new ScaleOperationTask(streamMetadataTasks, streamStore, executor),
                 new UpdateStreamTask(streamMetadataTasks, streamStore, executor),
@@ -103,7 +106,7 @@ public class ControllerServiceWithZKStreamTest {
 
         streamMetadataTasks.setRequestEventWriter(new ControllerEventStreamWriterMock(streamRequestHandler, executor));
         streamTransactionMetadataTasks = new StreamTransactionMetadataTasks(streamStore, hostStore,
-                segmentHelperMock, executor, "host", connectionFactory);
+                segmentHelperMock, executor, "host", connectionFactory, false, "");
         consumer = new ControllerService(streamStore, hostStore, streamMetadataTasks,
                 streamTransactionMetadataTasks, segmentHelperMock, executor, null);
     }
diff --git a/controller/src/test/java/io/pravega/controller/server/InMemoryControllerServiceStarterTest.java b/controller/src/test/java/io/pravega/controller/server/InMemoryControllerServiceStarterTest.java
index 5a9e9a3..1b1caa5 100644
--- a/controller/src/test/java/io/pravega/controller/server/InMemoryControllerServiceStarterTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/InMemoryControllerServiceStarterTest.java
@@ -16,8 +16,13 @@ import io.pravega.controller.store.client.impl.StoreClientConfigImpl;
  * In-memory store based ControllerServiceStarter tests.
  */
 public class InMemoryControllerServiceStarterTest extends ControllerServiceStarterTest {
+
     public InMemoryControllerServiceStarterTest() {
-        super(true);
+        this(false);
+    }
+
+    InMemoryControllerServiceStarterTest(boolean auth) {
+        super(true, auth);
     }
 
     @Override
diff --git a/controller/src/test/java/io/pravega/controller/server/SecureInMemoryControllerServiceStarterTest.java b/controller/src/test/java/io/pravega/controller/server/SecureInMemoryControllerServiceStarterTest.java
new file mode 100644
index 0000000..f48a6f9
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/server/SecureInMemoryControllerServiceStarterTest.java
@@ -0,0 +1,16 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server;
+
+public class SecureInMemoryControllerServiceStarterTest extends InMemoryControllerServiceStarterTest {
+    public SecureInMemoryControllerServiceStarterTest() {
+        super(true);
+    }
+}
diff --git a/controller/src/test/java/io/pravega/controller/server/SegmentHelperTest.java b/controller/src/test/java/io/pravega/controller/server/SegmentHelperTest.java
new file mode 100644
index 0000000..9233143
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/server/SegmentHelperTest.java
@@ -0,0 +1,251 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server;
+
+import io.pravega.client.netty.impl.ClientConnection;
+import io.pravega.client.netty.impl.ConnectionFactory;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.common.auth.AuthenticationException;
+import io.pravega.common.cluster.Host;
+import io.pravega.controller.store.host.HostControllerStore;
+import io.pravega.controller.stream.api.grpc.v1.Controller;
+import io.pravega.shared.protocol.netty.Append;
+import io.pravega.shared.protocol.netty.ConnectionFailedException;
+import io.pravega.shared.protocol.netty.PravegaNodeUri;
+import io.pravega.shared.protocol.netty.ReplyProcessor;
+import io.pravega.shared.protocol.netty.WireCommand;
+import io.pravega.shared.protocol.netty.WireCommands;
+import io.pravega.test.common.AssertExtensions;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ScheduledExecutorService;
+import lombok.Getter;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class SegmentHelperTest {
+
+    private SegmentHelper helper;
+
+    @Before
+    public void setUp() throws Exception {
+        helper = new SegmentHelper();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void getSegmentUri() {
+        helper.getSegmentUri("", "", 0, new MockHostControllerStore());
+    }
+
+    @Test
+    public void createSegment() {
+        MockConnectionFactory factory = new MockConnectionFactory();
+        CompletableFuture<Boolean> retVal = helper.createSegment("", "",
+                0, ScalingPolicy.fixed(2), new MockHostControllerStore(), factory, "");
+        factory.rp.authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(0));
+        AssertExtensions.assertThrows("",
+                () -> retVal.join(),
+                ex -> ex instanceof WireCommandFailedException
+                 && ex.getCause() instanceof AuthenticationException
+                );
+    }
+
+    @Test
+    public void truncateSegment() {
+        MockConnectionFactory factory = new MockConnectionFactory();
+        CompletableFuture<Boolean> retVal = helper.truncateSegment("", "", 0, 0L,
+                new MockHostControllerStore(), factory, "");
+        factory.rp.authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(0));
+        AssertExtensions.assertThrows("",
+                () -> retVal.join(),
+                ex -> ex instanceof WireCommandFailedException
+                        && ex.getCause() instanceof AuthenticationException
+        );
+    }
+
+
+    @Test
+    public void deleteSegment() {
+        MockConnectionFactory factory = new MockConnectionFactory();
+        CompletableFuture<Boolean> retVal = helper.deleteSegment("", "", 0, new MockHostControllerStore(),
+                factory, "");
+        factory.rp.authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(0));
+        AssertExtensions.assertThrows("",
+                () -> retVal.join(),
+                ex -> ex instanceof WireCommandFailedException
+                        && ex.getCause() instanceof AuthenticationException
+        );
+    }
+
+    @Test
+    public void sealSegment() {
+        MockConnectionFactory factory = new MockConnectionFactory();
+        CompletableFuture<Boolean> retVal = helper.sealSegment("", "", 0,
+                new MockHostControllerStore(), factory, "");
+        factory.rp.authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(0));
+        AssertExtensions.assertThrows("",
+                () -> retVal.join(),
+                ex -> ex instanceof WireCommandFailedException
+                        && ex.getCause() instanceof AuthenticationException
+        );
+    }
+
+    @Test
+    public void createTransaction() {
+        MockConnectionFactory factory = new MockConnectionFactory();
+        CompletableFuture<UUID> retVal = helper.createTransaction("", "", 0, UUID.randomUUID(),
+                new MockHostControllerStore(), factory, "");
+        factory.rp.authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(0));
+        AssertExtensions.assertThrows("",
+                () -> retVal.join(),
+                ex -> ex instanceof WireCommandFailedException
+                        && ex.getCause() instanceof AuthenticationException
+        );
+    }
+
+    @Test
+    public void commitTransaction() {
+        MockConnectionFactory factory = new MockConnectionFactory();
+        CompletableFuture<Controller.TxnStatus> retVal = helper.commitTransaction("", "", 0, UUID.randomUUID(),
+                new MockHostControllerStore(), factory, "");
+        factory.rp.authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(0));
+        AssertExtensions.assertThrows("",
+                () -> retVal.join(),
+                ex -> ex instanceof WireCommandFailedException
+                        && ex.getCause() instanceof AuthenticationException
+        );
+    }
+
+    @Test
+    public void abortTransaction() {
+        MockConnectionFactory factory = new MockConnectionFactory();
+        CompletableFuture<Controller.TxnStatus> retVal = helper.abortTransaction("", "", 0, UUID.randomUUID(),
+                new MockHostControllerStore(), factory, "");
+        factory.rp.authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(0));
+        AssertExtensions.assertThrows("",
+                () -> retVal.join(),
+                ex -> ex instanceof WireCommandFailedException
+                        && ex.getCause() instanceof AuthenticationException
+        );
+    }
+
+    @Test
+    public void updatePolicy() {
+        MockConnectionFactory factory = new MockConnectionFactory();
+        CompletableFuture<Void> retVal = helper.updatePolicy("", "", ScalingPolicy.fixed(0), 0,
+                new MockHostControllerStore(), factory, "");
+        factory.rp.authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(0));
+        AssertExtensions.assertThrows("",
+                () -> retVal.join(),
+                ex -> ex instanceof WireCommandFailedException
+                        && ex.getCause() instanceof AuthenticationException
+        );
+    }
+
+    @Test
+    public void getSegmentInfo() {
+        MockConnectionFactory factory = new MockConnectionFactory();
+        CompletableFuture<WireCommands.StreamSegmentInfo> retVal = helper.getSegmentInfo("", "", 0,
+                new MockHostControllerStore(), factory, "");
+        factory.rp.authTokenCheckFailed(new WireCommands.AuthTokenCheckFailed(0));
+        AssertExtensions.assertThrows("",
+                () -> retVal.join(),
+                ex -> ex instanceof WireCommandFailedException
+                        && ex.getCause() instanceof AuthenticationException
+        );
+    }
+
+    private static class MockHostControllerStore implements HostControllerStore {
+
+        @Override
+        public Map<Host, Set<Integer>> getHostContainersMap() {
+            return null;
+        }
+
+        @Override
+        public void updateHostContainersMap(Map<Host, Set<Integer>> newMapping) {
+
+        }
+
+        @Override
+        public int getContainerCount() {
+            return 0;
+        }
+
+        @Override
+        public Host getHostForSegment(String scope, String stream, int segmentNumber) {
+            return new Host("localhost", 1000, "");
+        }
+    }
+
+    private class MockConnectionFactory implements ConnectionFactory {
+        @Getter
+        private ReplyProcessor rp;
+
+        @Override
+        public CompletableFuture<ClientConnection> establishConnection(PravegaNodeUri endpoint, ReplyProcessor rp) {
+            this.rp = rp;
+            ClientConnection connection = new MockConnection(rp);
+            return CompletableFuture.completedFuture(connection);
+        }
+
+        @Override
+        public ScheduledExecutorService getInternalExecutor() {
+            return null;
+        }
+
+        @Override
+        public void close() {
+
+        }
+    }
+
+    private class MockConnection implements ClientConnection {
+        @Getter
+        private final ReplyProcessor rp;
+
+        public MockConnection(ReplyProcessor rp) {
+            this.rp = rp;
+        }
+
+        @Override
+        public void send(WireCommand cmd) throws ConnectionFailedException {
+
+        }
+
+        @Override
+        public void send(Append append) throws ConnectionFailedException {
+
+        }
+
+        @Override
+        public void sendAsync(WireCommand cmd) throws ConnectionFailedException {
+
+        }
+
+        @Override
+        public void sendAsync(List<Append> appends, CompletedCallback callback) {
+
+        }
+
+        @Override
+        public void close() {
+
+        }
+    }
+}
\ No newline at end of file
diff --git a/controller/src/test/java/io/pravega/controller/server/ZKControllerServiceStarterTest.java b/controller/src/test/java/io/pravega/controller/server/ZKControllerServiceStarterTest.java
index 5b9d7f4..b2edee3 100644
--- a/controller/src/test/java/io/pravega/controller/server/ZKControllerServiceStarterTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/ZKControllerServiceStarterTest.java
@@ -9,18 +9,17 @@
  */
 package io.pravega.controller.server;
 
-import io.pravega.test.common.TestingServerStarter;
 import io.pravega.controller.store.client.StoreClientFactory;
 import io.pravega.controller.store.client.ZKClientConfig;
 import io.pravega.controller.store.client.impl.StoreClientConfigImpl;
 import io.pravega.controller.store.client.impl.ZKClientConfigImpl;
+import io.pravega.test.common.TestingServerStarter;
+import java.io.IOException;
+import java.util.UUID;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.curator.test.TestingServer;
 import org.junit.Assert;
 
-import java.io.IOException;
-import java.util.UUID;
-
 /**
  * ControllerServiceStarter backed by ZK store tests.
  */
@@ -29,7 +28,7 @@ public class ZKControllerServiceStarterTest extends ControllerServiceStarterTest
     private TestingServer zkServer;
 
     public ZKControllerServiceStarterTest() {
-        super(true);
+        super(true, false);
     }
 
     @Override
diff --git a/controller/src/test/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessorTest.java b/controller/src/test/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessorTest.java
index d470a77..4e4f40c 100644
--- a/controller/src/test/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessorTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessorTest.java
@@ -79,7 +79,7 @@ public class ControllerEventProcessorTest {
         hostStore = HostStoreFactory.createInMemoryStore(HostMonitorConfigImpl.dummyConfig());
         segmentHelperMock = SegmentHelperMock.getSegmentHelperMock();
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore, TaskStoreFactory.createInMemoryStore(executor),
-                segmentHelperMock, executor, "1", mock(ConnectionFactory.class));
+                segmentHelperMock, executor, "1", mock(ConnectionFactory.class), false, "");
         // region createStream
         final ScalingPolicy policy1 = ScalingPolicy.fixed(2);
         final StreamConfiguration configuration1 = StreamConfiguration.builder().scope(SCOPE).streamName(STREAM).scalingPolicy(policy1).build();
diff --git a/controller/src/test/java/io/pravega/controller/server/eventProcessor/LocalControllerTest.java b/controller/src/test/java/io/pravega/controller/server/eventProcessor/LocalControllerTest.java
index 201aaa6..3d5696a 100644
--- a/controller/src/test/java/io/pravega/controller/server/eventProcessor/LocalControllerTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/eventProcessor/LocalControllerTest.java
@@ -47,6 +47,7 @@ public class LocalControllerTest {
     //Ensure each test completes within 10 seconds.
     @Rule
     public Timeout globalTimeout = new Timeout(10, TimeUnit.SECONDS);
+    boolean authEnabled = false;
 
     private ControllerService mockControllerService;
     private LocalController testController;
@@ -55,7 +56,7 @@ public class LocalControllerTest {
     @Before
     public void setup() {
         this.mockControllerService = mock(ControllerService.class);
-        this.testController = new LocalController(this.mockControllerService);
+        this.testController = new LocalController(this.mockControllerService, authEnabled, "secret");
         this.executor = Executors.newSingleThreadScheduledExecutor();
     }
 
diff --git a/controller/src/test/java/io/pravega/controller/server/eventProcessor/ScaleRequestHandlerTest.java b/controller/src/test/java/io/pravega/controller/server/eventProcessor/ScaleRequestHandlerTest.java
index 7cbe2fe..276b868 100644
--- a/controller/src/test/java/io/pravega/controller/server/eventProcessor/ScaleRequestHandlerTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/eventProcessor/ScaleRequestHandlerTest.java
@@ -11,6 +11,7 @@ package io.pravega.controller.server.eventProcessor;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.stream.EventStreamWriter;
@@ -41,14 +42,6 @@ import io.pravega.shared.controller.event.AutoScaleEvent;
 import io.pravega.shared.controller.event.ControllerEvent;
 import io.pravega.shared.controller.event.ScaleOpEvent;
 import io.pravega.test.common.TestingServerStarter;
-import org.apache.curator.framework.CuratorFramework;
-import org.apache.curator.framework.CuratorFrameworkFactory;
-import org.apache.curator.retry.ExponentialBackoffRetry;
-import org.apache.curator.test.TestingServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.AbstractMap;
@@ -60,6 +53,13 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.function.Consumer;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.CuratorFrameworkFactory;
+import org.apache.curator.retry.ExponentialBackoffRetry;
+import org.apache.curator.test.TestingServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -113,13 +113,13 @@ public class ScaleRequestHandlerTest {
         hostStore = HostStoreFactory.createInMemoryStore(HostMonitorConfigImpl.dummyConfig());
 
         SegmentHelper segmentHelper = SegmentHelperMock.getSegmentHelperMock();
-        connectionFactory = new ConnectionFactoryImpl(false);
+        connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         clientFactory = mock(ClientFactory.class);
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore, taskMetadataStore, segmentHelper,
-                executor, hostId, connectionFactory);
+                executor, hostId, connectionFactory, false, "");
         streamMetadataTasks.initializeStreamWriters(clientFactory, Config.SCALE_STREAM_NAME);
         streamTransactionMetadataTasks = new StreamTransactionMetadataTasks(streamStore, hostStore,
-                segmentHelper, executor, hostId, connectionFactory);
+                segmentHelper, executor, hostId, connectionFactory, false, "");
 
         long createTimestamp = System.currentTimeMillis();
 
diff --git a/controller/src/test/java/io/pravega/controller/server/eventProcessor/SecureLocalControllerTest.java b/controller/src/test/java/io/pravega/controller/server/eventProcessor/SecureLocalControllerTest.java
new file mode 100644
index 0000000..ba5310d
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/server/eventProcessor/SecureLocalControllerTest.java
@@ -0,0 +1,22 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server.eventProcessor;
+
+import org.junit.Before;
+
+public class SecureLocalControllerTest extends LocalControllerTest {
+    @Override
+    @Before
+    public void setup() {
+        this.authEnabled = true;
+        super.setup();
+    }
+
+}
\ No newline at end of file
diff --git a/controller/src/test/java/io/pravega/controller/server/retention/StreamCutServiceTest.java b/controller/src/test/java/io/pravega/controller/server/retention/StreamCutServiceTest.java
index 698b089..db84b8d 100644
--- a/controller/src/test/java/io/pravega/controller/server/retention/StreamCutServiceTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/retention/StreamCutServiceTest.java
@@ -10,6 +10,7 @@
 package io.pravega.controller.server.retention;
 
 import com.google.common.collect.Lists;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.stream.RetentionPolicy;
 import io.pravega.client.stream.Stream;
@@ -25,10 +26,6 @@ import io.pravega.controller.store.task.TaskStoreFactory;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.util.RetryHelper;
 import io.pravega.test.common.AssertExtensions;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
 import java.time.Duration;
 import java.util.List;
 import java.util.UUID;
@@ -37,6 +34,9 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
@@ -60,9 +60,10 @@ public abstract class StreamCutServiceTest {
         HostControllerStore hostStore = HostStoreFactory.createInMemoryStore(HostMonitorConfigImpl.dummyConfig());
 
         SegmentHelper segmentHelper = SegmentHelperMock.getSegmentHelperMock();
-        connectionFactory = new ConnectionFactoryImpl(false);
+        connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
 
-        streamMetadataTasks = new StreamMetadataTasks(streamMetadataStore, hostStore, taskMetadataStore, segmentHelper, executor, hostId, connectionFactory);
+        streamMetadataTasks = new StreamMetadataTasks(streamMetadataStore, hostStore, taskMetadataStore, segmentHelper, executor, hostId, connectionFactory,
+               false, "");
         service = new StreamCutService(3, hostId, streamMetadataStore, streamMetadataTasks, executor);
         service.startAsync();
         service.awaitRunning();
diff --git a/controller/src/test/java/io/pravega/controller/server/retention/ZkStoreRetentionTest.java b/controller/src/test/java/io/pravega/controller/server/retention/ZkStoreRetentionTest.java
index 7829c53..bb96a36 100644
--- a/controller/src/test/java/io/pravega/controller/server/retention/ZkStoreRetentionTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/retention/ZkStoreRetentionTest.java
@@ -10,6 +10,7 @@
 package io.pravega.controller.server.retention;
 
 import com.google.common.collect.Lists;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.stream.RetentionPolicy;
 import io.pravega.client.stream.Stream;
@@ -26,13 +27,6 @@ import io.pravega.controller.store.task.TaskStoreFactory;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.util.RetryHelper;
 import io.pravega.test.common.TestingServerStarter;
-import org.apache.curator.framework.CuratorFramework;
-import org.apache.curator.framework.CuratorFrameworkFactory;
-import org.apache.curator.test.TestingServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
 import java.time.Duration;
 import java.util.List;
 import java.util.UUID;
@@ -41,6 +35,12 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.CuratorFrameworkFactory;
+import org.apache.curator.test.TestingServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -123,9 +123,10 @@ public class ZkStoreRetentionTest extends StreamCutServiceTest {
         HostControllerStore hostStore = HostStoreFactory.createInMemoryStore(HostMonitorConfigImpl.dummyConfig());
 
         SegmentHelper segmentHelper = SegmentHelperMock.getSegmentHelperMock();
-        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
 
-        StreamMetadataTasks streamMetadataTasks2 = new StreamMetadataTasks(streamMetadataStore2, hostStore, taskMetadataStore, segmentHelper, executor2, hostId, connectionFactory);
+        StreamMetadataTasks streamMetadataTasks2 = new StreamMetadataTasks(streamMetadataStore2, hostStore, taskMetadataStore, segmentHelper, executor2, hostId, connectionFactory,
+                false, "");
 
         String scope = "scope1";
         String streamName = "stream1";
diff --git a/controller/src/test/java/io/pravega/controller/server/rpc/auth/PravegaAuthManagerTest.java b/controller/src/test/java/io/pravega/controller/server/rpc/auth/PravegaAuthManagerTest.java
new file mode 100644
index 0000000..d58f61c
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/server/rpc/auth/PravegaAuthManagerTest.java
@@ -0,0 +1,162 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server.rpc.auth;
+
+import io.grpc.ServerBuilder;
+import io.pravega.auth.AuthHandler;
+import io.pravega.client.ClientConfig;
+import io.pravega.client.stream.impl.ControllerImpl;
+import io.pravega.client.stream.impl.ControllerImplConfig;
+import io.pravega.client.stream.impl.Credentials;
+import io.pravega.client.stream.impl.DefaultCredentials;
+import io.pravega.common.auth.AuthenticationException;
+import io.pravega.common.util.RetriesExhaustedException;
+import io.pravega.controller.server.rpc.grpc.GRPCServerConfig;
+import io.pravega.controller.server.rpc.grpc.impl.GRPCServerConfigImpl;
+import io.pravega.controller.stream.api.grpc.v1.Controller;
+import io.pravega.controller.stream.api.grpc.v1.ControllerServiceGrpc;
+import io.pravega.test.common.InlineExecutor;
+import io.pravega.test.common.TestUtils;
+import java.io.File;
+import java.io.FileWriter;
+import java.net.URI;
+import javax.ws.rs.core.MultivaluedHashMap;
+import javax.ws.rs.core.MultivaluedMap;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static io.pravega.test.common.AssertExtensions.assertThrows;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class PravegaAuthManagerTest {
+
+    private final ControllerServiceGrpc.ControllerServiceImplBase serviceImpl = new ControllerServiceGrpc.ControllerServiceImplBase() {
+        @Override
+        public void createScope(io.pravega.controller.stream.api.grpc.v1.Controller.ScopeInfo request,
+                                io.grpc.stub.StreamObserver<io.pravega.controller.stream.api.grpc.v1.Controller.CreateScopeStatus> responseObserver) {
+            responseObserver.onNext(Controller.CreateScopeStatus.newBuilder().build());
+        }
+    };
+    private ControllerImpl client;
+
+    private File file;
+
+    @Before
+    public void setUp() throws Exception {
+        file = File.createTempFile("passwd", ".txt");
+        StrongPasswordProcessor passwordEncryptor = StrongPasswordProcessor.builder().build();
+
+        try (FileWriter writer = new FileWriter(file.getAbsolutePath())) {
+            writer.write("#:\n");
+            writer.write(":\n");
+            writer.write("::\n");
+            writer.write(":::\n");
+            writer.write("dummy:password:\n");
+            writer.write("dummy1:password:readresource;;\n");
+            writer.write("dummy2:password:readresource;specificresouce,READ;totalaccess,READ_UPDATE\n");
+            writer.write("dummy3:" + passwordEncryptor.encryptPassword("password") + ":readresource;specificresouce,READ;totalaccess,READ_UPDATE\n");
+            writer.write("dummy4:" + passwordEncryptor.encryptPassword("password") + ":readresource;specificresouce,READ;*,READ_UPDATE\n");
+            writer.close();
+        }
+
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void registerInterceptors() throws Exception {
+        //Test the registration method.
+        GRPCServerConfig config = GRPCServerConfigImpl.builder()
+                                                      .authorizationEnabled(true)
+                                                      .userPasswordFile(file.getAbsolutePath())
+                                                      .port(1000)
+                                                      .build();
+
+        PravegaAuthManager manager = new PravegaAuthManager(config);
+        int port = TestUtils.getAvailableListenPort();
+        ServerBuilder<?> server = ServerBuilder.forPort(port).useTransportSecurity(new File("../config/cert.pem"),
+                new File("../config/key.pem"));
+
+        server.addService(serviceImpl);
+        manager.registerInterceptors(server);
+        server.build().start();
+
+        InlineExecutor executor = new InlineExecutor();
+        Credentials creds = new DefaultCredentials("1111_aaaa", "admin");
+
+        final ControllerImpl controllerClient = new ControllerImpl(ControllerImplConfig.builder()
+                .clientConfig(ClientConfig.builder()
+                                          .controllerURI(URI.create("tcp://localhost:" + port)).build())
+                .retryAttempts(1).build(),
+                executor);
+
+        MultivaluedMap<String, String> map = new MultivaluedHashMap();
+
+        //Without specifying a valid handler.
+        assertThrows(AuthenticationException.class, () ->
+                manager.authenticate("hi", map, AuthHandler.Permissions.READ));
+
+        //Non existent interceptor method.
+        map.add("method", "invalid");
+        assertThrows(AuthenticationException.class, () ->
+        manager.authenticate("hi", map, AuthHandler.Permissions.READ));
+
+        //Specify a valid method but no parameters for default interceptor.
+        map.putSingle("method", "Pravega-Default");
+        assertThrows(AuthenticationException.class, () ->
+        manager.authenticate("hi", map, AuthHandler.Permissions.READ));
+
+        //Specify a valid method but no password for default interceptor.
+        map.putSingle("username", "dummy3");
+        assertThrows(AuthenticationException.class, () ->
+                manager.authenticate("hi", map, AuthHandler.Permissions.READ));
+
+        //Specify a valid method and parameters but invalid resource for default interceptor.
+        map.putSingle("password", "password");
+        assertFalse("Not existent resource should return false",
+                manager.authenticate("invalid", map, AuthHandler.Permissions.READ));
+
+        //Valid parameters for default interceptor
+        map.putSingle("username", "dummy3");
+        map.putSingle("password", "password");
+        assertTrue("Read access for read resource should return true",
+                manager.authenticate("readresource", map, AuthHandler.Permissions.READ));
+
+        //Stream/scope access should be extended to segment.
+        assertTrue("Read access for read resource should return true",
+                manager.authenticate("readresource/segment", map, AuthHandler.Permissions.READ));
+
+        //Levels of access
+        assertFalse("Write access for read resource should return false",
+                manager.authenticate("readresource", map, AuthHandler.Permissions.READ_UPDATE));
+
+        assertTrue("Read access for write resource should return true",
+                manager.authenticate("totalaccess", map, AuthHandler.Permissions.READ));
+
+        assertTrue("Write access for write resource should return true",
+                manager.authenticate("totalaccess", map, AuthHandler.Permissions.READ_UPDATE));
+
+        //Check the wildcard access
+        map.putSingle("username", "dummy4");
+        assertTrue("Write access for write resource should return true",
+                manager.authenticate("totalaccess", map, AuthHandler.Permissions.READ_UPDATE));
+
+        map.putSingle("method", "testHandler");
+        assertTrue("Test handler should be called", manager.authenticate("any", map, AuthHandler.Permissions.READ));
+
+        assertThrows(RetriesExhaustedException.class, () -> controllerClient.createScope("hi").join());
+    }
+
+
+}
\ No newline at end of file
diff --git a/controller/src/test/java/io/pravega/controller/server/rpc/auth/StrongPasswordProcessorTest.java b/controller/src/test/java/io/pravega/controller/server/rpc/auth/StrongPasswordProcessorTest.java
new file mode 100644
index 0000000..e25e92e
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/server/rpc/auth/StrongPasswordProcessorTest.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.server.rpc.auth;
+
+import java.security.NoSuchAlgorithmException;
+import java.security.spec.InvalidKeySpecException;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class StrongPasswordProcessorTest {
+
+    @Test
+    public void checkPassword() throws InvalidKeySpecException, NoSuchAlgorithmException {
+        StrongPasswordProcessor processor = StrongPasswordProcessor.builder().iterations(5000).build();
+        String encrypted = processor.encryptPassword("1111_aaaa");
+        StrongPasswordProcessor secondProcessor = StrongPasswordProcessor.builder().iterations(5000).build();
+
+        secondProcessor.checkPassword("1111_aaaa", encrypted);
+
+        StrongPasswordProcessor failingProcessor = StrongPasswordProcessor.builder().iterations(1000).build();
+        Assert.assertTrue("Passwords with different iterations should not match",
+                !encrypted.equals(failingProcessor.encryptPassword("1111_aaaa")));
+    }
+}
\ No newline at end of file
diff --git a/controller/src/test/java/io/pravega/controller/server/v1/ControllerServiceImplTest.java b/controller/src/test/java/io/pravega/controller/server/v1/ControllerServiceImplTest.java
index 597f536..51411bf 100644
--- a/controller/src/test/java/io/pravega/controller/server/v1/ControllerServiceImplTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/v1/ControllerServiceImplTest.java
@@ -9,6 +9,12 @@
  */
 package io.pravega.controller.server.v1;
 
+import io.grpc.StatusRuntimeException;
+import io.grpc.stub.StreamObserver;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.impl.ModelHelper;
+import io.pravega.controller.server.rpc.grpc.v1.ControllerServiceImpl;
 import io.pravega.controller.stream.api.grpc.v1.Controller;
 import io.pravega.controller.stream.api.grpc.v1.Controller.CreateScopeStatus;
 import io.pravega.controller.stream.api.grpc.v1.Controller.CreateStreamStatus;
@@ -30,14 +36,11 @@ import io.pravega.controller.stream.api.grpc.v1.Controller.StreamInfo;
 import io.pravega.controller.stream.api.grpc.v1.Controller.SuccessorResponse;
 import io.pravega.controller.stream.api.grpc.v1.Controller.UpdateStreamStatus;
 import io.pravega.shared.NameUtils;
-import io.pravega.controller.server.rpc.grpc.v1.ControllerServiceImpl;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.StreamConfiguration;
-import io.pravega.client.stream.impl.ModelHelper;
 import io.pravega.test.common.AssertExtensions;
-import io.grpc.StatusRuntimeException;
-import io.grpc.stub.StreamObserver;
-
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 import lombok.SneakyThrows;
 import org.junit.After;
 import org.junit.Assert;
@@ -46,11 +49,6 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import static org.junit.Assert.assertEquals;
 
 /**
@@ -306,6 +304,38 @@ public abstract class ControllerServiceImplTest {
     }
 
     @Test
+    public void truncateStreamTests() {
+        CreateScopeStatus createScopeStatus;
+        CreateStreamStatus createStreamStatus;
+
+        final StreamConfiguration configuration1 =
+                StreamConfiguration.builder().scope(SCOPE1).streamName(STREAM1).scalingPolicy(ScalingPolicy.fixed(4))
+                                   .build();
+
+        // Create a test scope.
+        ResultObserver<CreateScopeStatus> result1 = new ResultObserver<>();
+        this.controllerService.createScope(ModelHelper.createScopeInfo(SCOPE1), result1);
+        createScopeStatus = result1.get();
+        assertEquals("Create Scope", CreateScopeStatus.Status.SUCCESS, createScopeStatus.getStatus());
+
+        // Create a test stream.
+        ResultObserver<CreateStreamStatus> result2 = new ResultObserver<>();
+        this.controllerService.createStream(ModelHelper.decode(configuration1), result2);
+        createStreamStatus = result2.get();
+        assertEquals("Create stream", CreateStreamStatus.Status.SUCCESS, createStreamStatus.getStatus());
+
+        //Truncate the stream
+        ResultObserver<UpdateStreamStatus> result3 = new ResultObserver<>();
+        this.controllerService.truncateStream(Controller.StreamCut.newBuilder()
+                                                                  .setStreamInfo(StreamInfo.newBuilder()
+                                                                                           .setScope(SCOPE1)
+                                                                                           .setStream(STREAM1)
+                                                                                           .build())
+                .putCut(0, 0).build(), result3);
+        UpdateStreamStatus truncateStreamStatus = result3.get();
+    }
+
+        @Test
     public void sealStreamTests() {
         CreateScopeStatus createScopeStatus;
         CreateStreamStatus createStreamStatus;
@@ -461,6 +491,12 @@ public abstract class ControllerServiceImplTest {
     }
 
     @Test
+    public void delegationTokenTests() {
+        //TODO: Test for creation of token in context and out of context.
+        //TODO: Add tests for checkAuthorizationWithToken and checkAuthorization.
+    }
+
+    @Test
     public void createTransactionFailureTest() {
         createScopeAndStream(SCOPE1, STREAM1, ScalingPolicy.fixed(4));
 
diff --git a/controller/src/test/java/io/pravega/controller/server/v1/ControllerServiceTest.java b/controller/src/test/java/io/pravega/controller/server/v1/ControllerServiceTest.java
index 22b0292..2d9027e 100644
--- a/controller/src/test/java/io/pravega/controller/server/v1/ControllerServiceTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/v1/ControllerServiceTest.java
@@ -9,36 +9,29 @@
  */
 package io.pravega.controller.server.v1;
 
-import io.pravega.controller.store.stream.OperationContext;
-import io.pravega.controller.store.stream.StartScaleResponse;
-import io.pravega.controller.store.stream.tables.State;
-import io.pravega.test.common.TestingServerStarter;
+import io.pravega.client.ClientConfig;
+import io.pravega.client.netty.impl.ConnectionFactoryImpl;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.impl.ModelHelper;
 import io.pravega.controller.mocks.SegmentHelperMock;
 import io.pravega.controller.server.ControllerService;
 import io.pravega.controller.server.SegmentHelper;
 import io.pravega.controller.store.host.HostControllerStore;
 import io.pravega.controller.store.host.HostStoreFactory;
 import io.pravega.controller.store.host.impl.HostMonitorConfigImpl;
+import io.pravega.controller.store.stream.OperationContext;
 import io.pravega.controller.store.stream.Segment;
+import io.pravega.controller.store.stream.StartScaleResponse;
 import io.pravega.controller.store.stream.StreamMetadataStore;
 import io.pravega.controller.store.stream.StreamStoreFactory;
+import io.pravega.controller.store.stream.tables.State;
 import io.pravega.controller.store.task.TaskMetadataStore;
 import io.pravega.controller.store.task.TaskStoreFactory;
 import io.pravega.controller.stream.api.grpc.v1.Controller.SegmentId;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.task.Stream.StreamTransactionMetadataTasks;
-import io.pravega.client.netty.impl.ConnectionFactoryImpl;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.StreamConfiguration;
-import io.pravega.client.stream.impl.ModelHelper;
-import org.apache.curator.framework.CuratorFramework;
-import org.apache.curator.framework.CuratorFrameworkFactory;
-import org.apache.curator.retry.ExponentialBackoffRetry;
-import org.apache.curator.test.TestingServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
+import io.pravega.test.common.TestingServerStarter;
 import java.util.AbstractMap.SimpleEntry;
 import java.util.Arrays;
 import java.util.Collections;
@@ -48,6 +41,13 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.stream.Collectors;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.CuratorFrameworkFactory;
+import org.apache.curator.retry.ExponentialBackoffRetry;
+import org.apache.curator.test.TestingServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
@@ -85,11 +85,11 @@ public class ControllerServiceTest {
         final HostControllerStore hostStore = HostStoreFactory.createInMemoryStore(HostMonitorConfigImpl.dummyConfig());
 
         SegmentHelper segmentHelper = SegmentHelperMock.getSegmentHelperMock();
-        connectionFactory = new ConnectionFactoryImpl(false);
+        connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore,
-                taskMetadataStore, segmentHelper, executor, "host", connectionFactory);
+                taskMetadataStore, segmentHelper, executor, "host", connectionFactory, false, "");
         streamTransactionMetadataTasks = new StreamTransactionMetadataTasks(streamStore,
-                hostStore, segmentHelper, executor, "host", connectionFactory);
+                hostStore, segmentHelper, executor, "host", connectionFactory, false, "");
 
         consumer = new ControllerService(streamStore, hostStore, streamMetadataTasks, streamTransactionMetadataTasks,
                 new SegmentHelper(), executor, null);
diff --git a/controller/src/test/java/io/pravega/controller/server/v1/InMemoryControllerServiceImplTest.java b/controller/src/test/java/io/pravega/controller/server/v1/InMemoryControllerServiceImplTest.java
index 0bcffc5..1adbdf1 100644
--- a/controller/src/test/java/io/pravega/controller/server/v1/InMemoryControllerServiceImplTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/v1/InMemoryControllerServiceImplTest.java
@@ -9,12 +9,13 @@
  */
 package io.pravega.controller.server.v1;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.common.cluster.Cluster;
 import io.pravega.common.cluster.Host;
 import io.pravega.common.concurrent.ExecutorServiceHelpers;
-import io.pravega.controller.mocks.EventStreamWriterMock;
 import io.pravega.controller.mocks.ControllerEventStreamWriterMock;
+import io.pravega.controller.mocks.EventStreamWriterMock;
 import io.pravega.controller.mocks.SegmentHelperMock;
 import io.pravega.controller.server.ControllerService;
 import io.pravega.controller.server.SegmentHelper;
@@ -35,6 +36,7 @@ import io.pravega.controller.store.task.TaskMetadataStore;
 import io.pravega.controller.store.task.TaskStoreFactory;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.task.Stream.StreamTransactionMetadataTasks;
+import java.net.URI;
 import java.util.Collections;
 import java.util.concurrent.ScheduledExecutorService;
 
@@ -64,9 +66,11 @@ public class InMemoryControllerServiceImplTest extends ControllerServiceImplTest
         streamStore = StreamStoreFactory.createInMemoryStore(executorService);
         segmentHelper = SegmentHelperMock.getSegmentHelperMock();
 
-        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder()
+                                                                                        .controllerURI(URI.create("tcp://localhost"))
+                                                                                        .build());
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore, taskMetadataStore, segmentHelper,
-                executorService, "host", connectionFactory);
+                executorService, "host", connectionFactory,  false, "");
         this.streamRequestHandler = new StreamRequestHandler(new AutoScaleTask(streamMetadataTasks, streamStore, executorService),
                 new ScaleOperationTask(streamMetadataTasks, streamStore, executorService),
                 new UpdateStreamTask(streamMetadataTasks, streamStore, executorService),
@@ -77,7 +81,7 @@ public class InMemoryControllerServiceImplTest extends ControllerServiceImplTest
 
         streamMetadataTasks.setRequestEventWriter(new ControllerEventStreamWriterMock(streamRequestHandler, executorService));
         streamTransactionMetadataTasks = new StreamTransactionMetadataTasks(
-                streamStore, hostStore, segmentHelper, executorService, "host", connectionFactory);
+                streamStore, hostStore, segmentHelper, executorService, "host", connectionFactory, false, "");
         streamTransactionMetadataTasks.initializeStreamWriters("commitStream", new EventStreamWriterMock<>(),
                 "abortStream", new EventStreamWriterMock<>());
 
@@ -85,7 +89,7 @@ public class InMemoryControllerServiceImplTest extends ControllerServiceImplTest
         when(mockCluster.getClusterMembers()).thenReturn(Collections.singleton(new Host("localhost", 9090, null)));
         controllerService = new ControllerServiceImpl(
                 new ControllerService(streamStore, hostStore, streamMetadataTasks, streamTransactionMetadataTasks,
-                                      new SegmentHelper(), executorService, mockCluster));
+                                      new SegmentHelper(), executorService, mockCluster), "secret", false);
     }
 
     @Override
diff --git a/controller/src/test/java/io/pravega/controller/server/v1/ZKControllerServiceImplTest.java b/controller/src/test/java/io/pravega/controller/server/v1/ZKControllerServiceImplTest.java
index 50e4905..4a18485 100644
--- a/controller/src/test/java/io/pravega/controller/server/v1/ZKControllerServiceImplTest.java
+++ b/controller/src/test/java/io/pravega/controller/server/v1/ZKControllerServiceImplTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.controller.server.v1;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.impl.ModelHelper;
@@ -17,8 +18,8 @@ import io.pravega.common.cluster.ClusterType;
 import io.pravega.common.cluster.Host;
 import io.pravega.common.cluster.zkImpl.ClusterZKImpl;
 import io.pravega.common.concurrent.ExecutorServiceHelpers;
-import io.pravega.controller.mocks.EventStreamWriterMock;
 import io.pravega.controller.mocks.ControllerEventStreamWriterMock;
+import io.pravega.controller.mocks.EventStreamWriterMock;
 import io.pravega.controller.mocks.SegmentHelperMock;
 import io.pravega.controller.server.ControllerService;
 import io.pravega.controller.server.SegmentHelper;
@@ -89,9 +90,9 @@ public class ZKControllerServiceImplTest extends ControllerServiceImplTest {
         streamStore = StreamStoreFactory.createZKStore(zkClient, executorService);
         segmentHelper = SegmentHelperMock.getSegmentHelperMock();
 
-        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore, taskMetadataStore, segmentHelper,
-                executorService, "host", connectionFactory);
+                executorService, "host", connectionFactory,  false, "");
         this.streamRequestHandler = new StreamRequestHandler(new AutoScaleTask(streamMetadataTasks, streamStore, executorService),
                 new ScaleOperationTask(streamMetadataTasks, streamStore, executorService),
                 new UpdateStreamTask(streamMetadataTasks, streamStore, executorService),
@@ -103,7 +104,7 @@ public class ZKControllerServiceImplTest extends ControllerServiceImplTest {
         streamMetadataTasks.setRequestEventWriter(new ControllerEventStreamWriterMock(streamRequestHandler, executorService));
 
         streamTransactionMetadataTasks = new StreamTransactionMetadataTasks(
-                streamStore, hostStore, segmentHelper, executorService, "host", connectionFactory);
+                streamStore, hostStore, segmentHelper, executorService, "host", connectionFactory, false, "");
         streamTransactionMetadataTasks.initializeStreamWriters("commitStream", new EventStreamWriterMock<>(),
                 "abortStream", new EventStreamWriterMock<>());
 
@@ -115,7 +116,7 @@ public class ZKControllerServiceImplTest extends ControllerServiceImplTest {
 
         ControllerService controller = new ControllerService(streamStore, hostStore, streamMetadataTasks,
                 streamTransactionMetadataTasks, new SegmentHelper(), executorService, cluster);
-        controllerService = new ControllerServiceImpl(controller);
+        controllerService = new ControllerServiceImpl(controller, "", false);
     }
 
     @Override
diff --git a/controller/src/test/java/io/pravega/controller/task/Stream/IntermittentCnxnFailureTest.java b/controller/src/test/java/io/pravega/controller/task/Stream/IntermittentCnxnFailureTest.java
index 959b3a9..3d848ec 100644
--- a/controller/src/test/java/io/pravega/controller/task/Stream/IntermittentCnxnFailureTest.java
+++ b/controller/src/test/java/io/pravega/controller/task/Stream/IntermittentCnxnFailureTest.java
@@ -9,25 +9,31 @@
  */
 package io.pravega.controller.task.Stream;
 
+import io.pravega.client.ClientConfig;
+import io.pravega.client.netty.impl.ConnectionFactoryImpl;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.common.Exceptions;
 import io.pravega.common.concurrent.Futures;
 import io.pravega.common.util.Retry;
-import io.pravega.controller.store.stream.StoreException;
-import io.pravega.test.common.TestingServerStarter;
 import io.pravega.controller.server.ControllerService;
 import io.pravega.controller.server.SegmentHelper;
 import io.pravega.controller.store.host.HostControllerStore;
 import io.pravega.controller.store.host.HostStoreFactory;
 import io.pravega.controller.store.host.impl.HostMonitorConfigImpl;
+import io.pravega.controller.store.stream.StoreException;
 import io.pravega.controller.store.stream.StreamMetadataStore;
 import io.pravega.controller.store.stream.StreamStoreFactory;
 import io.pravega.controller.store.task.TaskMetadataStore;
 import io.pravega.controller.store.task.TaskStoreFactory;
 import io.pravega.controller.stream.api.grpc.v1.Controller;
-import io.pravega.client.netty.impl.ConnectionFactoryImpl;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.controller.util.Config;
+import io.pravega.test.common.TestingServerStarter;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.atomic.AtomicBoolean;
 import org.apache.curator.framework.CuratorFramework;
 import org.apache.curator.framework.CuratorFrameworkFactory;
 import org.apache.curator.retry.ExponentialBackoffRetry;
@@ -37,12 +43,6 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
@@ -86,13 +86,13 @@ public class IntermittentCnxnFailureTest {
         doReturn(Controller.NodeUri.newBuilder().setEndpoint("localhost").setPort(Config.SERVICE_PORT).build()).when(segmentHelperMock).getSegmentUri(
                 anyString(), anyString(), anyInt(), any());
 
-        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore,
                 taskMetadataStore, segmentHelperMock,
-                executor, "host", connectionFactory);
+                executor, "host", connectionFactory, false, "");
 
         streamTransactionMetadataTasks = new StreamTransactionMetadataTasks(
-                streamStore, hostStore, segmentHelperMock, executor, "host", connectionFactory);
+                streamStore, hostStore, segmentHelperMock, executor, "host", connectionFactory, false, "");
 
         controllerService = new ControllerService(streamStore, hostStore, streamMetadataTasks,
                 streamTransactionMetadataTasks, segmentHelperMock, executor, null);
@@ -136,7 +136,7 @@ public class IntermittentCnxnFailureTest {
 
         // Mock createSegment to return success.
         doReturn(CompletableFuture.completedFuture(true)).when(segmentHelperMock).createSegment(
-                anyString(), anyString(), anyInt(), any(), any(), any());
+                anyString(), anyString(), anyInt(), any(), any(), any(), any());
 
         AtomicBoolean result = new AtomicBoolean(false);
         Retry.withExpBackoff(10, 10, 4)
diff --git a/controller/src/test/java/io/pravega/controller/task/Stream/SecureStreamMetadataTasksTest.java b/controller/src/test/java/io/pravega/controller/task/Stream/SecureStreamMetadataTasksTest.java
new file mode 100644
index 0000000..8c569e1
--- /dev/null
+++ b/controller/src/test/java/io/pravega/controller/task/Stream/SecureStreamMetadataTasksTest.java
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.controller.task.Stream;
+
+import org.junit.Before;
+
+public class SecureStreamMetadataTasksTest extends StreamMetadataTasksTest {
+    @Override
+    @Before
+    public void setup() throws Exception {
+        this.authEnabled = true;
+        super.setup();
+    }
+}
diff --git a/controller/src/test/java/io/pravega/controller/task/Stream/StreamMetadataTasksTest.java b/controller/src/test/java/io/pravega/controller/task/Stream/StreamMetadataTasksTest.java
index 1a3cd72..bf8f2c1 100644
--- a/controller/src/test/java/io/pravega/controller/task/Stream/StreamMetadataTasksTest.java
+++ b/controller/src/test/java/io/pravega/controller/task/Stream/StreamMetadataTasksTest.java
@@ -10,6 +10,7 @@
 package io.pravega.controller.task.Stream;
 
 import com.google.common.collect.Lists;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.stream.EventStreamWriter;
 import io.pravega.client.stream.EventWriterConfig;
@@ -58,16 +59,6 @@ import io.pravega.shared.controller.event.TruncateStreamEvent;
 import io.pravega.shared.controller.event.UpdateStreamEvent;
 import io.pravega.test.common.AssertExtensions;
 import io.pravega.test.common.TestingServerStarter;
-import lombok.Data;
-import lombok.Getter;
-import org.apache.curator.framework.CuratorFramework;
-import org.apache.curator.framework.CuratorFrameworkFactory;
-import org.apache.curator.retry.ExponentialBackoffRetry;
-import org.apache.curator.test.TestingServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
 import java.time.Duration;
 import java.util.AbstractMap;
 import java.util.ArrayList;
@@ -84,6 +75,15 @@ import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.stream.Collectors;
+import lombok.Data;
+import lombok.Getter;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.CuratorFrameworkFactory;
+import org.apache.curator.retry.ExponentialBackoffRetry;
+import org.apache.curator.test.TestingServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -98,6 +98,7 @@ import static org.mockito.Mockito.spy;
 public class StreamMetadataTasksTest {
 
     private static final String SCOPE = "scope";
+    protected boolean authEnabled = false;
     private final String stream1 = "stream1";
     private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);
 
@@ -129,13 +130,13 @@ public class StreamMetadataTasksTest {
         HostControllerStore hostStore = HostStoreFactory.createInMemoryStore(HostMonitorConfigImpl.dummyConfig());
 
         SegmentHelper segmentHelperMock = SegmentHelperMock.getSegmentHelperMock();
-        connectionFactory = new ConnectionFactoryImpl(false);
+        connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         streamMetadataTasks = spy(new StreamMetadataTasks(streamStorePartialMock, hostStore,
                 taskMetadataStore, segmentHelperMock,
-                executor, "host", connectionFactory));
+                executor, "host", connectionFactory,  authEnabled, "key"));
 
         streamTransactionMetadataTasks = new StreamTransactionMetadataTasks(
-                streamStorePartialMock, hostStore, segmentHelperMock, executor, "host", connectionFactory);
+                streamStorePartialMock, hostStore, segmentHelperMock, executor, "host", connectionFactory, authEnabled, "key");
 
         this.streamRequestHandler = new StreamRequestHandler(new AutoScaleTask(streamMetadataTasks, streamStorePartialMock, executor),
                 new ScaleOperationTask(streamMetadataTasks, streamStorePartialMock, executor),
@@ -394,9 +395,9 @@ public class StreamMetadataTasksTest {
         StreamCutRecord streamCut1 = new StreamCutRecord(recordingTime1, Long.MIN_VALUE, map1);
 
         doReturn(CompletableFuture.completedFuture(streamCut1)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any()); //mock only isTransactionOngoing call.
+                anyString(), anyString(), any(), any()); //mock only isTransactionOngoing call.
 
-        streamMetadataTasks.retention(SCOPE, "test", retentionPolicy, recordingTime1, null).get();
+        streamMetadataTasks.retention(SCOPE, "test", retentionPolicy, recordingTime1, null, "").get();
         // verify that one streamCut is generated and added.
 
         List<StreamCutRecord> list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, "test", null, executor).get();
@@ -409,9 +410,9 @@ public class StreamMetadataTasksTest {
 
         StreamCutRecord streamCut2 = new StreamCutRecord(recordingTime2, Long.MIN_VALUE, map2);
         doReturn(CompletableFuture.completedFuture(streamCut2)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any()); //mock only isTransactionOngoing call.
+                anyString(), anyString(), any(), any()); //mock only isTransactionOngoing call.
 
-        streamMetadataTasks.retention(SCOPE, "test", retentionPolicy, recordingTime2, null).get();
+        streamMetadataTasks.retention(SCOPE, "test", retentionPolicy, recordingTime2, null, "").get();
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, "test", null, executor).get();
         StreamProperty<StreamTruncationRecord> truncProp = streamStorePartialMock.getTruncationProperty(SCOPE, "test", true, null, executor).get();
         // verify that only one stream cut is in retention set. streamCut2 is not added
@@ -426,9 +427,9 @@ public class StreamMetadataTasksTest {
         long recordingTime3 = recordingTime1 + Duration.ofMinutes(Config.MINIMUM_RETENTION_FREQUENCY_IN_MINUTES).toMillis() + 1;
         StreamCutRecord streamCut3 = new StreamCutRecord(recordingTime3, Long.MIN_VALUE, map3);
         doReturn(CompletableFuture.completedFuture(streamCut3)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any()); //mock only isTransactionOngoing call.
+                anyString(), anyString(), any(), any()); //mock only isTransactionOngoing call.
 
-        streamMetadataTasks.retention(SCOPE, "test", retentionPolicy, recordingTime3, null).get();
+        streamMetadataTasks.retention(SCOPE, "test", retentionPolicy, recordingTime3, null, "").get();
         // verify two stream cuts are in retention set. Cut 1 and 3.
         // verify that Truncation not not happened.
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, "test", null, executor).get();
@@ -445,9 +446,9 @@ public class StreamMetadataTasksTest {
         long recordingTime4 = recordingTime1 + retentionPolicy.getRetentionParam() + 2;
         StreamCutRecord streamCut4 = new StreamCutRecord(recordingTime4, Long.MIN_VALUE, map4);
         doReturn(CompletableFuture.completedFuture(streamCut4)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any());
+                anyString(), anyString(), any(), any());
 
-        streamMetadataTasks.retention(SCOPE, "test", retentionPolicy, recordingTime4, null).get();
+        streamMetadataTasks.retention(SCOPE, "test", retentionPolicy, recordingTime4, null, "").get();
         // verify that only two stream cut are in retention set. streamcut 3 and 4
         // verify that truncation has started. verify that streamCut1 is removed from retention set as that has been used for truncation
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, "test", null, executor).get();
@@ -491,9 +492,9 @@ public class StreamMetadataTasksTest {
         StreamCutRecord streamCut1 = new StreamCutRecord(recordingTime1, size, map1);
 
         doReturn(CompletableFuture.completedFuture(streamCut1)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any());
+                anyString(), anyString(), any(), any());
 
-        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime1, null).get();
+        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime1, null, "").get();
         // verify that one streamCut is generated and added.
         List<StreamCutRecord> list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, streamName, null, executor).get();
         assertTrue(list.contains(streamCut1));
@@ -510,9 +511,9 @@ public class StreamMetadataTasksTest {
         assertEquals(size, 100L);
         StreamCutRecord streamCut2 = new StreamCutRecord(recordingTime2, size, map2);
         doReturn(CompletableFuture.completedFuture(streamCut2)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any());
+                anyString(), anyString(), any(), anyString());
 
-        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime2, null).get();
+        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime2, null, "").get();
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, streamName, null, executor).get();
         StreamProperty<StreamTruncationRecord> truncProp = streamStorePartialMock.getTruncationProperty(SCOPE, streamName, true, null, executor).get();
         // verify that two stream cut is in retention set. streamCut2 is added
@@ -534,9 +535,9 @@ public class StreamMetadataTasksTest {
         long recordingTime3 = recordingTime2 + Duration.ofMinutes(Config.MINIMUM_RETENTION_FREQUENCY_IN_MINUTES).toMillis() + 1;
         StreamCutRecord streamCut3 = new StreamCutRecord(recordingTime3, size, map3);
         doReturn(CompletableFuture.completedFuture(streamCut3)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any());
+                anyString(), anyString(), any(), anyString());
 
-        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime3, null).get();
+        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime3, null, "").get();
         // verify two stream cuts are in retention set. Cut 2 and 3.
         // verify that Truncation has happened.
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, streamName, null, executor).get();
@@ -576,9 +577,9 @@ public class StreamMetadataTasksTest {
         long recordingTime4 = recordingTime3 + Duration.ofMinutes(Config.MINIMUM_RETENTION_FREQUENCY_IN_MINUTES).toMillis() + 1;
         StreamCutRecord streamCut4 = new StreamCutRecord(recordingTime4, size, map4);
         doReturn(CompletableFuture.completedFuture(streamCut4)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any());
+                anyString(), anyString(), any(), anyString());
 
-        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime4, null).get();
+        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime4, null, "").get();
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, streamName, null, executor).get();
         truncProp = streamStorePartialMock.getTruncationProperty(SCOPE, streamName, true, null, executor).get();
 
@@ -602,9 +603,9 @@ public class StreamMetadataTasksTest {
         long recordingTime5 = recordingTime4 + Duration.ofMinutes(Config.MINIMUM_RETENTION_FREQUENCY_IN_MINUTES).toMillis() + 1;
         StreamCutRecord streamCut5 = new StreamCutRecord(recordingTime5, size, map5);
         doReturn(CompletableFuture.completedFuture(streamCut5)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any());
+                anyString(), anyString(), any(), anyString());
 
-        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime5, null).get();
+        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime5, null, "").get();
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, streamName, null, executor).get();
         truncProp = streamStorePartialMock.getTruncationProperty(SCOPE, streamName, true, null, executor).get();
 
@@ -643,9 +644,9 @@ public class StreamMetadataTasksTest {
         long recordingTime6 = recordingTime5 + Duration.ofMinutes(Config.MINIMUM_RETENTION_FREQUENCY_IN_MINUTES).toMillis() + 1;
         StreamCutRecord streamCut6 = new StreamCutRecord(recordingTime6, size, map6);
         doReturn(CompletableFuture.completedFuture(streamCut6)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any());
+                anyString(), anyString(), any(), anyString());
 
-        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime6, null).get();
+        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime6, null, "").get();
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, streamName, null, executor).get();
         truncProp = streamStorePartialMock.getTruncationProperty(SCOPE, streamName, true, null, executor).get();
 
@@ -658,7 +659,7 @@ public class StreamMetadataTasksTest {
         assertFalse(truncProp.isUpdating());
 
         // endregion
-        
+
         // truncate on manual streamcutManual: (1/65, 4/10, 5/10)
         Map<Integer, Long> streamCutManual = new HashMap<>();
         streamCutManual.put(1, 65L);
@@ -680,10 +681,10 @@ public class StreamMetadataTasksTest {
         long recordingTime7 = recordingTime6 + Duration.ofMinutes(Config.MINIMUM_RETENTION_FREQUENCY_IN_MINUTES).toMillis() + 1;
         StreamCutRecord streamCut7 = new StreamCutRecord(recordingTime7, size, map7);
         doReturn(CompletableFuture.completedFuture(streamCut7)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any());
+                anyString(), anyString(), any(), anyString());
 
         // verify no new truncation.. streamcut5 should be chosen but discarded because it is not strictly-ahead-of-truncationRecord
-        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime7, null).join();
+        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime7, null, "").join();
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, streamName, null, executor).get();
         truncProp = streamStorePartialMock.getTruncationProperty(SCOPE, streamName, true, null, executor).get();
 
@@ -707,9 +708,9 @@ public class StreamMetadataTasksTest {
         long recordingTime8 = recordingTime7 + Duration.ofMinutes(Config.MINIMUM_RETENTION_FREQUENCY_IN_MINUTES).toMillis() + 1;
         StreamCutRecord streamCut8 = new StreamCutRecord(recordingTime8, size, map8);
         doReturn(CompletableFuture.completedFuture(streamCut8)).when(streamMetadataTasks).generateStreamCut(
-                anyString(), anyString(), any());
+                anyString(), anyString(), any(), anyString());
 
-        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime8, null).get();
+        streamMetadataTasks.retention(SCOPE, streamName, retentionPolicy, recordingTime8, null, "").get();
         list = streamStorePartialMock.getStreamCutsFromRetentionSet(SCOPE, streamName, null, executor).get();
         truncProp = streamStorePartialMock.getTruncationProperty(SCOPE, streamName, true, null, executor).get();
 
@@ -910,7 +911,7 @@ public class StreamMetadataTasksTest {
                 response.getActiveEpoch(), 30, context, executor).get(),
                 ex -> Exceptions.unwrap(ex) instanceof StoreException.IllegalStateException);
 
-        List<Segment> segments = streamMetadataTasks.startScale((ScaleOpEvent) requestEventWriter.getEventQueue().take(), true, context).get();
+        List<Segment> segments = streamMetadataTasks.startScale((ScaleOpEvent) requestEventWriter.getEventQueue().take(), true, context, "").get();
 
         assertTrue(segments.stream().anyMatch(x -> x.getNumber() == 1 && x.getKeyStart() == 0.0 && x.getKeyEnd() == 0.5));
         assertTrue(segments.stream().anyMatch(x -> x.getNumber() == 2 && x.getKeyStart() == 0.5 && x.getKeyEnd() == 1.0));
diff --git a/controller/src/test/java/io/pravega/controller/task/Stream/StreamTransactionMetadataTasksTest.java b/controller/src/test/java/io/pravega/controller/task/Stream/StreamTransactionMetadataTasksTest.java
index af14049..1b76cd0 100644
--- a/controller/src/test/java/io/pravega/controller/task/Stream/StreamTransactionMetadataTasksTest.java
+++ b/controller/src/test/java/io/pravega/controller/task/Stream/StreamTransactionMetadataTasksTest.java
@@ -145,7 +145,7 @@ public class StreamTransactionMetadataTasksTest {
         segmentHelperMock = SegmentHelperMock.getSegmentHelperMock();
         connectionFactory = Mockito.mock(ConnectionFactory.class);
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore, taskMetadataStore, segmentHelperMock,
-                executor, "host", connectionFactory);
+                executor, "host", connectionFactory,  false, "");
     }
 
     @After
@@ -184,7 +184,7 @@ public class StreamTransactionMetadataTasksTest {
 
         // Create transaction tasks.
         txnTasks = new StreamTransactionMetadataTasks(streamStore, hostStore, segmentHelperMock,
-                executor, "host", connectionFactory);
+                executor, "host", connectionFactory, false, "");
         txnTasks.initializeStreamWriters("commitStream", commitWriter, "abortStream",
                 abortWriter);
 
@@ -239,7 +239,7 @@ public class StreamTransactionMetadataTasksTest {
 
         // Set up txn task for creating transactions from a failedHost.
         StreamTransactionMetadataTasks failedTxnTasks = new StreamTransactionMetadataTasks(streamStore, hostStore,
-                segmentHelperMock, executor, "failedHost", connectionFactory);
+                segmentHelperMock, executor, "failedHost", connectionFactory, false, "");
         failedTxnTasks.initializeStreamWriters("commitStream", new EventStreamWriterMock<>(), "abortStream",
                 new EventStreamWriterMock<>());
 
@@ -276,7 +276,7 @@ public class StreamTransactionMetadataTasksTest {
 
         // Create transaction tasks for sweeping txns from failedHost.
         txnTasks = new StreamTransactionMetadataTasks(streamStore, hostStore, segmentHelperMock, executor, "host",
-                connectionFactory);
+                connectionFactory, false, "");
         TxnSweeper txnSweeper = new TxnSweeper(streamStore, txnTasks, 100, executor);
 
         // Before initializing, txnSweeper.sweepFailedHosts would throw an error
@@ -346,7 +346,7 @@ public class StreamTransactionMetadataTasksTest {
 
         // Create transaction tasks.
         txnTasks = new StreamTransactionMetadataTasks(streamStore, hostStore, segmentHelperMock, executor, "host",
-                connectionFactory);
+                connectionFactory, false, "");
         txnTasks.initializeStreamWriters("commitStream", commitWriter, "abortStream", abortWriter);
 
         consumer = new ControllerService(streamStore, hostStore, streamMetadataTasks, txnTasks,
@@ -426,7 +426,7 @@ public class StreamTransactionMetadataTasksTest {
 
         // Create transaction tasks.
         txnTasks = new StreamTransactionMetadataTasks(streamStore, hostStore,
-                SegmentHelperMock.getFailingSegmentHelperMock(), executor, "host", connectionFactory);
+                SegmentHelperMock.getFailingSegmentHelperMock(), executor, "host", connectionFactory, false, "");
         txnTasks.initializeStreamWriters("commitStream", commitWriter, "abortStream",
                 abortWriter);
 
diff --git a/controller/src/test/java/io/pravega/controller/task/TaskTest.java b/controller/src/test/java/io/pravega/controller/task/TaskTest.java
index 9b24bea..771502d 100644
--- a/controller/src/test/java/io/pravega/controller/task/TaskTest.java
+++ b/controller/src/test/java/io/pravega/controller/task/TaskTest.java
@@ -9,20 +9,21 @@
  */
 package io.pravega.controller.task;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
-import io.pravega.controller.store.stream.StartScaleResponse;
-import io.pravega.controller.store.stream.Segment;
-import io.pravega.controller.store.stream.StreamMetadataStore;
-import io.pravega.controller.store.stream.StreamStoreFactory;
-import io.pravega.controller.store.stream.tables.State;
-import io.pravega.test.common.AssertExtensions;
-import io.pravega.test.common.TestingServerStarter;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.controller.mocks.SegmentHelperMock;
 import io.pravega.controller.server.SegmentHelper;
 import io.pravega.controller.store.host.HostControllerStore;
 import io.pravega.controller.store.host.HostStoreFactory;
 import io.pravega.controller.store.host.impl.HostMonitorConfigImpl;
+import io.pravega.controller.store.stream.Segment;
+import io.pravega.controller.store.stream.StartScaleResponse;
+import io.pravega.controller.store.stream.StreamMetadataStore;
+import io.pravega.controller.store.stream.StreamStoreFactory;
+import io.pravega.controller.store.stream.tables.State;
 import io.pravega.controller.store.task.LockFailedException;
 import io.pravega.controller.store.task.Resource;
 import io.pravega.controller.store.task.TaggedResource;
@@ -31,22 +32,10 @@ import io.pravega.controller.store.task.TaskStoreFactory;
 import io.pravega.controller.stream.api.grpc.v1.Controller.CreateStreamStatus;
 import io.pravega.controller.task.Stream.StreamMetadataTasks;
 import io.pravega.controller.task.Stream.TestTasks;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.StreamConfiguration;
-import lombok.Data;
-import lombok.EqualsAndHashCode;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.curator.framework.CuratorFramework;
-import org.apache.curator.framework.CuratorFrameworkFactory;
-import org.apache.curator.retry.RetryOneTime;
-import org.apache.curator.test.TestingServer;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mockito;
-
+import io.pravega.test.common.AssertExtensions;
+import io.pravega.test.common.TestingServerStarter;
 import java.io.Serializable;
+import java.net.URI;
 import java.util.AbstractMap;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -60,6 +49,18 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.stream.Collectors;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.curator.framework.CuratorFramework;
+import org.apache.curator.framework.CuratorFrameworkFactory;
+import org.apache.curator.retry.RetryOneTime;
+import org.apache.curator.test.TestingServer;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mockito;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -101,7 +102,10 @@ public class TaskTest {
         segmentHelperMock = SegmentHelperMock.getSegmentHelperMock();
 
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore, taskMetadataStore, segmentHelperMock,
-                executor, HOSTNAME, new ConnectionFactoryImpl(false));
+                executor, HOSTNAME, new ConnectionFactoryImpl(ClientConfig.builder()
+                                                                          .controllerURI(URI.create("tcp://localhost"))
+                                                                          .build()),
+                false, "");
     }
 
     @Before
@@ -218,7 +222,7 @@ public class TaskTest {
 
         // Create objects.
         StreamMetadataTasks mockStreamTasks = new StreamMetadataTasks(streamStore, hostStore, taskMetadataStore,
-                segmentHelperMock, executor, deadHost, Mockito.mock(ConnectionFactory.class));
+                segmentHelperMock, executor, deadHost, Mockito.mock(ConnectionFactory.class),  false, "");
         mockStreamTasks.setCreateIndexOnlyMode();
         TaskSweeper sweeper = new TaskSweeper(taskMetadataStore, HOSTNAME, executor, streamMetadataTasks);
 
diff --git a/controller/src/test/java/io/pravega/controller/timeout/TimeoutServiceTest.java b/controller/src/test/java/io/pravega/controller/timeout/TimeoutServiceTest.java
index b63563b..af08c67 100644
--- a/controller/src/test/java/io/pravega/controller/timeout/TimeoutServiceTest.java
+++ b/controller/src/test/java/io/pravega/controller/timeout/TimeoutServiceTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.controller.timeout;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.StreamConfiguration;
@@ -46,7 +47,6 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
-
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.curator.framework.CuratorFramework;
@@ -101,12 +101,12 @@ public class TimeoutServiceTest {
         HostControllerStore hostStore = HostStoreFactory.createInMemoryStore(HostMonitorConfigImpl.dummyConfig());
         TaskMetadataStore taskMetadataStore = TaskStoreFactory.createStore(storeClient, executor);
 
-        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         streamMetadataTasks = new StreamMetadataTasks(streamStore, hostStore, taskMetadataStore,
-                new SegmentHelper(), executor, hostId, connectionFactory);
+                new SegmentHelper(), executor, hostId, connectionFactory, false, "");
         streamTransactionMetadataTasks = new StreamTransactionMetadataTasks(streamStore, hostStore,
                 SegmentHelperMock.getSegmentHelperMock(), executor, hostId, TimeoutServiceConfig.defaultConfig(),
-                new LinkedBlockingQueue<>(5), connectionFactory);
+                new LinkedBlockingQueue<>(5), connectionFactory, false, "");
         streamTransactionMetadataTasks.initializeStreamWriters("commitStream", new EventStreamWriterMock<>(),
                 "abortStream", new EventStreamWriterMock<>());
 
@@ -243,14 +243,14 @@ public class TimeoutServiceTest {
         HostControllerStore hostStore = HostStoreFactory.createInMemoryStore(HostMonitorConfigImpl.dummyConfig());
         TaskMetadataStore taskMetadataStore = TaskStoreFactory.createStore(storeClient, executor);
 
-        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         @Cleanup
         StreamMetadataTasks streamMetadataTasks2 = new StreamMetadataTasks(streamStore2, hostStore, taskMetadataStore,
-                new SegmentHelper(), executor, "2", connectionFactory);
+                new SegmentHelper(), executor, "2", connectionFactory,  false, "");
         @Cleanup
         StreamTransactionMetadataTasks streamTransactionMetadataTasks2 = new StreamTransactionMetadataTasks(streamStore2, hostStore,
                 SegmentHelperMock.getSegmentHelperMock(), executor, "2", TimeoutServiceConfig.defaultConfig(),
-                new LinkedBlockingQueue<>(5), connectionFactory);
+                new LinkedBlockingQueue<>(5), connectionFactory, false, "");
         streamTransactionMetadataTasks2.initializeStreamWriters("commitStream", new EventStreamWriterMock<>(),
                 "abortStream", new EventStreamWriterMock<>());
 
diff --git a/controller/src/test/resources/META-INF/services/io.pravega.auth.AuthHandler b/controller/src/test/resources/META-INF/services/io.pravega.auth.AuthHandler
new file mode 100644
index 0000000..352443a
--- /dev/null
+++ b/controller/src/test/resources/META-INF/services/io.pravega.auth.AuthHandler
@@ -0,0 +1,10 @@
+#
+# Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+io.pravega.controller.server.rpc.auth.TestAuthHandler
\ No newline at end of file
diff --git a/controller/src/test/resources/application.conf b/controller/src/test/resources/application.conf
index e54da1a..1d5d340 100644
--- a/controller/src/test/resources/application.conf
+++ b/controller/src/test/resources/application.conf
@@ -29,6 +29,9 @@ config {
     #Enable the Zookeeper based segment container monitor.
     hostMonitorEnabled = false
 
+    #Enable authorization check.
+    authorizationEnabled = false
+
     #Minimum time between any two rebalance operation in seconds. 0 indicates no waits.
     minRebalanceInterval = 10
 
diff --git a/gradle.properties b/gradle.properties
index fcb4125..8d1c60c 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -22,7 +22,7 @@ findbugsVersion=3.0.1
 gradleDockerPlugin=3.1.0
 gradleMkdocsPluginVersion=1.0.0
 gradleSshPluginVersion=2.9.0
-grpcVersion=1.6.1
+grpcVersion=1.8.0
 guavaVersion=20.0
 guavaServiceStorageImplVersion=16.0
 hadoopVersion=2.8.1
@@ -37,7 +37,7 @@ metricsVersion=3.2.5
 metricsGangliaVersion=1.0.10
 mockitoVersion=2.10.0
 #Check issue in https://github.com/pravega/pravega/pull/2146 before when upgrading netty
-nettyVersion=4.1.15.Final
+nettyVersion=4.1.16.Final
 protobufGradlePlugin=0.8.3
 protobufProtocVersion=3.3.0
 qosLogbackVersion=1.2.3
diff --git a/gradle/rat.gradle b/gradle/rat.gradle
index 3dd32cd..2b71c22 100644
--- a/gradle/rat.gradle
+++ b/gradle/rat.gradle
@@ -16,6 +16,7 @@ rat {
             '**/*.iml',
             '**/*.iws',
             '**/*.ipr',
+            '**/passwd',
             '**/gradle/wrapper/**',
             '**/build/**',
             '**/out/**',
diff --git a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/ServiceStarter.java b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/ServiceStarter.java
index 4b55835..e4634f3 100644
--- a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/ServiceStarter.java
+++ b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/ServiceStarter.java
@@ -12,6 +12,7 @@ package io.pravega.segmentstore.server.host;
 import io.pravega.common.Exceptions;
 import io.pravega.common.cluster.Host;
 import io.pravega.segmentstore.contracts.StreamSegmentStore;
+import io.pravega.segmentstore.server.host.delegationtoken.TokenVerifierImpl;
 import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
 import io.pravega.segmentstore.server.host.stat.AutoScalerConfig;
 import io.pravega.segmentstore.server.host.stat.SegmentStatsFactory;
@@ -101,8 +102,9 @@ public final class ServiceStarter {
         SegmentStatsRecorder statsRecorder = segmentStatsFactory
                 .createSegmentStatsRecorder(service, builderConfig.getConfig(AutoScalerConfig::builder));
 
-        this.listener = new PravegaConnectionListener(false, this.serviceConfig.getListeningIPAddress(),
-                this.serviceConfig.getListeningPort(), service, statsRecorder);
+        TokenVerifierImpl tokenVerifier = new TokenVerifierImpl(builderConfig.getConfig(AutoScalerConfig::builder));
+        this.listener = new PravegaConnectionListener(this.serviceConfig.isEnableTls(), this.serviceConfig.getListeningIPAddress(),
+                this.serviceConfig.getListeningPort(), service, statsRecorder, tokenVerifier, this.serviceConfig.getCertFile(), this.serviceConfig.getKeyFile());
         this.listener.startListening();
         log.info("PravegaConnectionListener started successfully.");
         log.info("StreamSegmentService started.");
diff --git a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/DelegationTokenVerifier.java b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/DelegationTokenVerifier.java
new file mode 100644
index 0000000..095e99b
--- /dev/null
+++ b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/DelegationTokenVerifier.java
@@ -0,0 +1,26 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.segmentstore.server.host.delegationtoken;
+
+import io.pravega.auth.AuthHandler;
+
+/**
+ * This interface represents the code on segment store side that verifies the delegation token.
+ */
+public interface DelegationTokenVerifier {
+    /**
+     * Verifies whether the token represents access to a given resource to the level expected.
+     * @param resource       The resource for which access is to be verified.
+     * @param token          The delegation token.
+     * @param expectedLevel  Maximum expected access to the given resoure after this verification.
+     * @return               true if the delegation token allows access to the resource for the expected level.
+     */
+    boolean verifyToken(String resource, String token, AuthHandler.Permissions expectedLevel);
+}
diff --git a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/PassingTokenVerifier.java b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/PassingTokenVerifier.java
new file mode 100644
index 0000000..98031c1
--- /dev/null
+++ b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/PassingTokenVerifier.java
@@ -0,0 +1,24 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+package io.pravega.segmentstore.server.host.delegationtoken;
+
+import io.pravega.auth.AuthHandler;
+
+/**
+ * Default implementation of DelegegationTokenVerifier which asserts all the tokens as valid.
+ * This is used when no verifier is configured.
+ */
+public class PassingTokenVerifier implements DelegationTokenVerifier {
+    @Override
+    public boolean verifyToken(String resource, String token, AuthHandler.Permissions expectedLevel) {
+        return true;
+    }
+}
diff --git a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/TokenVerifierImpl.java b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/TokenVerifierImpl.java
new file mode 100644
index 0000000..bf3bc98
--- /dev/null
+++ b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/TokenVerifierImpl.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.segmentstore.server.host.delegationtoken;
+
+import io.jsonwebtoken.Claims;
+import io.jsonwebtoken.Jws;
+import io.jsonwebtoken.JwtException;
+import io.jsonwebtoken.Jwts;
+import io.pravega.auth.AuthHandler;
+import io.pravega.segmentstore.server.host.stat.AutoScalerConfig;
+import java.util.Map;
+import java.util.Optional;
+import lombok.extern.slf4j.Slf4j;
+
+@Slf4j
+public class TokenVerifierImpl implements DelegationTokenVerifier {
+    private final AutoScalerConfig config;
+
+    public TokenVerifierImpl(AutoScalerConfig config) {
+        this.config = config;
+    }
+
+    @Override
+    public boolean verifyToken(String resource, String token, AuthHandler.Permissions expectedLevel) {
+        if (config.isAuthEnabled()) {
+            try {
+                Jws<Claims> claims = Jwts.parser()
+                                         .setSigningKey(config.getTokenSigningKey().getBytes())
+                                         .parseClaimsJws(token);
+                Optional<Map.Entry<String, Object>> matchingClaim = claims.getBody().entrySet().stream().filter(entry ->
+                        validateEntry(entry, resource)
+                        && expectedLevel.compareTo(AuthHandler.Permissions.valueOf(entry.getValue().toString()))
+                        <= 0).findFirst();
+                if (matchingClaim.isPresent()) {
+                    log.debug("Found a matching claim {} for resource {}", matchingClaim, resource);
+                    return true;
+                } else {
+                    log.debug("Could not find a matching claim {} for resource {} in claims {}",
+                            expectedLevel, resource, claims);
+                    return false;
+                }
+            } catch (JwtException e) {
+                log.warn("Claim verification failed for resource {} because {}", resource, e);
+                return false;
+            }
+        } else {
+            return true;
+        }
+    }
+
+    private boolean validateEntry(Map.Entry<String, Object> entry, String resource) {
+        return (entry.getKey().endsWith("/") && resource.startsWith(entry.getKey()))
+                    ||  resource.startsWith(entry.getKey() + "/")
+                || entry.getKey().equals("*");
+    }
+}
diff --git a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java
index 73947a4..193ee87 100644
--- a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java
+++ b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java
@@ -14,9 +14,11 @@ import com.google.common.base.Preconditions;
 import com.google.common.collect.LinkedListMultimap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.pravega.auth.AuthHandler;
 import io.pravega.common.Exceptions;
 import io.pravega.common.LoggerHelpers;
 import io.pravega.common.Timer;
+import io.pravega.common.auth.AuthenticationException;
 import io.pravega.segmentstore.contracts.AttributeUpdate;
 import io.pravega.segmentstore.contracts.AttributeUpdateType;
 import io.pravega.segmentstore.contracts.BadAttributeUpdateException;
@@ -28,6 +30,7 @@ import io.pravega.segmentstore.contracts.StreamSegmentSealedException;
 import io.pravega.segmentstore.contracts.StreamSegmentStore;
 import io.pravega.segmentstore.contracts.TooManyAttributesException;
 import io.pravega.segmentstore.server.SegmentMetadata;
+import io.pravega.segmentstore.server.host.delegationtoken.DelegationTokenVerifier;
 import io.pravega.segmentstore.server.host.stat.SegmentStatsRecorder;
 import io.pravega.shared.metrics.DynamicLogger;
 import io.pravega.shared.metrics.MetricsProvider;
@@ -85,6 +88,7 @@ public class AppendProcessor extends DelegatingRequestProcessor {
     private final RequestProcessor nextRequestProcessor;
     private final Object lock = new Object();
     private final SegmentStatsRecorder statsRecorder;
+    private final DelegationTokenVerifier tokenVerifier;
 
     @GuardedBy("lock")
     private final LinkedListMultimap<UUID, Append> waitingAppends = LinkedListMultimap.create(2);
@@ -104,25 +108,27 @@ public class AppendProcessor extends DelegatingRequestProcessor {
      * @param store      The SegmentStore to send append requests to.
      * @param connection The ServerConnection to send responses to.
      * @param next       The RequestProcessor to invoke next.
+     * @param verifier    The token verifier.
      */
     @VisibleForTesting
-    public AppendProcessor(StreamSegmentStore store, ServerConnection connection, RequestProcessor next) {
-        this(store, connection, next, null);
+    public AppendProcessor(StreamSegmentStore store, ServerConnection connection, RequestProcessor next, DelegationTokenVerifier verifier) {
+        this(store, connection, next, null, verifier);
     }
 
     /**
      * Creates a new instance of the AppendProcessor class.
-     *
-     * @param store         The SegmentStore to send append requests to.
+     *  @param store         The SegmentStore to send append requests to.
      * @param connection    The ServerConnection to send responses to.
      * @param next          The RequestProcessor to invoke next.
      * @param statsRecorder (Optional) A StatsRecorder to record Metrics.
+     * @param tokenVerifier Delegation token verifier.
      */
-    AppendProcessor(StreamSegmentStore store, ServerConnection connection, RequestProcessor next, SegmentStatsRecorder statsRecorder) {
+    AppendProcessor(StreamSegmentStore store, ServerConnection connection, RequestProcessor next, SegmentStatsRecorder statsRecorder, DelegationTokenVerifier tokenVerifier) {
         this.store = Preconditions.checkNotNull(store, "store");
         this.connection = Preconditions.checkNotNull(connection, "connection");
         this.nextRequestProcessor = Preconditions.checkNotNull(next, "next");
         this.statsRecorder = statsRecorder;
+        this.tokenVerifier = tokenVerifier;
     }
 
     //endregion
@@ -150,6 +156,14 @@ public class AppendProcessor extends DelegatingRequestProcessor {
         String newSegment = setupAppend.getSegment();
         UUID writer = setupAppend.getWriterId();
         log.info("Setting up appends for writer: {} on segment: {}", writer, newSegment);
+        if (this.tokenVerifier != null && !tokenVerifier.verifyToken(newSegment,
+                setupAppend.getDelegationToken(), AuthHandler.Permissions.READ_UPDATE)) {
+            log.warn("Delegation token verification failed");
+            handleException(setupAppend.getWriterId(), setupAppend.getRequestId(), newSegment,
+                    "Update Segment Attribute", new AuthenticationException("Token verification failed"));
+            return;
+        }
+
         store.getStreamSegmentInfo(newSegment, true, TIMEOUT)
                 .whenComplete((info, u) -> {
                     try {
@@ -334,6 +348,10 @@ public class AppendProcessor extends DelegatingRequestProcessor {
             log.warn("Attribute limit would be exceeded by {} on segment {}.", writerId, segment, u);
             connection.send(new InvalidEventNumber(writerId, requestId));
             connection.close();
+        } else if (u instanceof AuthenticationException) {
+            log.warn("Token check failed while being written by {} on segment {}.", writerId, segment, u);
+            connection.send(new WireCommands.AuthTokenCheckFailed(requestId));
+            connection.close();
         } else if (u instanceof UnsupportedOperationException) {
             log.warn("Unsupported Operation '{}'.", doingWhat, u);
             connection.send(new OperationUnsupported(requestId, doingWhat));
diff --git a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java
index 654c225..b626791 100644
--- a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java
+++ b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java
@@ -27,17 +27,19 @@ import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslContextBuilder;
-import io.netty.handler.ssl.util.SelfSignedCertificate;
+import io.netty.handler.ssl.SslHandler;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import io.netty.util.internal.logging.Slf4JLoggerFactory;
 import io.pravega.common.Exceptions;
 import io.pravega.segmentstore.contracts.StreamSegmentStore;
+import io.pravega.segmentstore.server.host.delegationtoken.DelegationTokenVerifier;
+import io.pravega.segmentstore.server.host.delegationtoken.PassingTokenVerifier;
 import io.pravega.segmentstore.server.host.stat.SegmentStatsRecorder;
 import io.pravega.shared.protocol.netty.AppendDecoder;
 import io.pravega.shared.protocol.netty.CommandDecoder;
 import io.pravega.shared.protocol.netty.CommandEncoder;
 import io.pravega.shared.protocol.netty.ExceptionLoggingHandler;
-import java.security.cert.CertificateException;
+import java.io.File;
 import javax.net.ssl.SSLException;
 
 import static io.pravega.shared.protocol.netty.WireCommands.MAX_WIRECOMMAND_SIZE;
@@ -52,6 +54,9 @@ public final class PravegaConnectionListener implements AutoCloseable {
     private final String host;
     private final int port;
     private final StreamSegmentStore store;
+    private final DelegationTokenVerifier tokenVerifier;
+    private final String certFile;
+    private final String keyFile;
     private Channel serverChannel;
     private EventLoopGroup bossGroup;
     private EventLoopGroup workerGroup;
@@ -70,26 +75,35 @@ public final class PravegaConnectionListener implements AutoCloseable {
      */
     @VisibleForTesting
     public PravegaConnectionListener(boolean ssl, int port, StreamSegmentStore streamSegmentStore) {
-        this(ssl, "0.0.0.0", port, streamSegmentStore, null);
+        this(ssl, "localhost", port, streamSegmentStore, null, new PassingTokenVerifier(), null, null);
     }
 
     /**
      * Creates a new instance of the PravegaConnectionListener class.
-     *
      * @param ssl                Whether to use SSL.
      * @param host               The name of the host to listen to.
      * @param port               The port to listen on.
      * @param streamSegmentStore The SegmentStore to delegate all requests to.
      * @param statsRecorder      (Optional) A StatsRecorder for Metrics.
+     * @param tokenVerifier      The object to verify delegation token.
+     * @param certFile           Path to the certificate file to be used for TLS.
+     * @param keyFile            PAth to be key file to be used for TLS.
      */
     public PravegaConnectionListener(boolean ssl, String host, int port, StreamSegmentStore streamSegmentStore,
-                                     SegmentStatsRecorder statsRecorder) {
+                                     SegmentStatsRecorder statsRecorder, DelegationTokenVerifier tokenVerifier, String certFile, String keyFile) {
         this.ssl = ssl;
         this.host = Exceptions.checkNotNullOrEmpty(host, "host");
         this.port = port;
         this.store = Preconditions.checkNotNull(streamSegmentStore, "streamSegmentStore");
         this.statsRecorder = statsRecorder;
+        this.certFile = certFile;
+        this.keyFile = keyFile;
         InternalLoggerFactory.setDefaultFactory(Slf4JLoggerFactory.INSTANCE);
+        if (tokenVerifier != null) {
+            this.tokenVerifier = tokenVerifier;
+        } else {
+            this.tokenVerifier = new PassingTokenVerifier();
+        }
     }
 
     //endregion
@@ -99,9 +113,8 @@ public final class PravegaConnectionListener implements AutoCloseable {
         final SslContext sslCtx;
         if (ssl) {
             try {
-                SelfSignedCertificate ssc = new SelfSignedCertificate();
-                sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
-            } catch (CertificateException | SSLException e) {
+                sslCtx = SslContextBuilder.forServer(new File(this.certFile), new File(this.keyFile)).build();
+            } catch (SSLException e) {
                 throw new RuntimeException(e);
             }
         } else {
@@ -127,7 +140,8 @@ public final class PravegaConnectionListener implements AutoCloseable {
              public void initChannel(SocketChannel ch) throws Exception {
                  ChannelPipeline p = ch.pipeline();
                  if (sslCtx != null) {
-                     p.addLast(sslCtx.newHandler(ch.alloc()));
+                     SslHandler handler = sslCtx.newHandler(ch.alloc());
+                     p.addLast(handler);
                  }
                  ServerConnectionInboundHandler lsh = new ServerConnectionInboundHandler();
                  // p.addLast(new LoggingHandler(LogLevel.INFO));
@@ -139,8 +153,9 @@ public final class PravegaConnectionListener implements AutoCloseable {
                          lsh);
                  lsh.setRequestProcessor(new AppendProcessor(store,
                          lsh,
-                         new PravegaRequestProcessor(store, lsh, statsRecorder),
-                         statsRecorder));
+                         new PravegaRequestProcessor(store, lsh, statsRecorder, tokenVerifier),
+                         statsRecorder,
+                         tokenVerifier));
              }
          });
 
diff --git a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java
index 1574761..0d277cc 100644
--- a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java
+++ b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java
@@ -11,9 +11,11 @@ package io.pravega.segmentstore.server.host.handler;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
+import io.pravega.auth.AuthHandler;
 import io.pravega.common.Exceptions;
 import io.pravega.common.LoggerHelpers;
 import io.pravega.common.Timer;
+import io.pravega.common.auth.AuthenticationException;
 import io.pravega.common.io.StreamHelpers;
 import io.pravega.segmentstore.contracts.AttributeUpdate;
 import io.pravega.segmentstore.contracts.AttributeUpdateType;
@@ -30,6 +32,8 @@ import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;
 import io.pravega.segmentstore.contracts.StreamSegmentSealedException;
 import io.pravega.segmentstore.contracts.StreamSegmentStore;
 import io.pravega.segmentstore.contracts.StreamSegmentTruncatedException;
+import io.pravega.segmentstore.server.host.delegationtoken.DelegationTokenVerifier;
+import io.pravega.segmentstore.server.host.delegationtoken.PassingTokenVerifier;
 import io.pravega.segmentstore.server.host.stat.SegmentStatsRecorder;
 import io.pravega.shared.metrics.DynamicLogger;
 import io.pravega.shared.metrics.MetricsProvider;
@@ -89,6 +93,8 @@ import lombok.SneakyThrows;
 import lombok.extern.slf4j.Slf4j;
 import lombok.val;
 
+import static io.pravega.auth.AuthHandler.Permissions.READ;
+import static io.pravega.auth.AuthHandler.Permissions.READ_UPDATE;
 import static io.pravega.segmentstore.contracts.Attributes.CREATION_TIME;
 import static io.pravega.segmentstore.contracts.Attributes.SCALE_POLICY_RATE;
 import static io.pravega.segmentstore.contracts.Attributes.SCALE_POLICY_TYPE;
@@ -125,6 +131,7 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
     private final StreamSegmentStore segmentStore;
     private final ServerConnection connection;
     private final SegmentStatsRecorder statsRecorder;
+    private final DelegationTokenVerifier tokenVerifier;
 
     //endregion
 
@@ -138,7 +145,7 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
      */
     @VisibleForTesting
     public PravegaRequestProcessor(StreamSegmentStore segmentStore, ServerConnection connection) {
-        this(segmentStore, connection, null);
+        this(segmentStore, connection, null, new PassingTokenVerifier());
     }
 
     /**
@@ -147,10 +154,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
      * @param segmentStore  The StreamSegmentStore to attach to (and issue requests to).
      * @param connection    The ServerConnection to attach to (and send responses to).
      * @param statsRecorder (Optional) A StatsRecorder for Metrics.
+     * @param tokenVerifier  Verifier class that verifies delegation token.
      */
-    PravegaRequestProcessor(StreamSegmentStore segmentStore, ServerConnection connection, SegmentStatsRecorder statsRecorder) {
+    PravegaRequestProcessor(StreamSegmentStore segmentStore, ServerConnection connection, SegmentStatsRecorder statsRecorder, DelegationTokenVerifier tokenVerifier) {
         this.segmentStore = Preconditions.checkNotNull(segmentStore, "segmentStore");
         this.connection = Preconditions.checkNotNull(connection, "connection");
+        this.tokenVerifier = Preconditions.checkNotNull(tokenVerifier, "tokenVerifier");
         this.statsRecorder = statsRecorder;
     }
 
@@ -162,6 +171,11 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
     public void readSegment(ReadSegment readSegment) {
         Timer timer = new Timer();
         final String segment = readSegment.getSegment();
+
+        if (!verifyToken(segment, readSegment.getOffset(), readSegment.getDelegationToken(), READ, "Read Segment")) {
+            return;
+        }
+
         final int readSize = min(MAX_READ_SIZE, max(TYPE_PLUS_LENGTH_SIZE, readSegment.getSuggestedLength()));
         long trace = LoggerHelpers.traceEnter(log, "readSegment", readSegment);
         segmentStore.read(segment, readSegment.getOffset(), readSize, TIMEOUT)
@@ -174,6 +188,16 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
                 .exceptionally(ex -> handleException(readSegment.getOffset(), segment, "Read segment", ex));
     }
 
+    private boolean verifyToken(String segment, long requestId, String delegationToken, AuthHandler.Permissions read, String operation) {
+        if (!tokenVerifier.verifyToken(segment, delegationToken, READ)) {
+            log.warn("Delegation token verification failed");
+            handleException(requestId, segment,
+                    "Read Segment", new AuthenticationException("Token verification failed"));
+            return false;
+        }
+        return true;
+    }
+
     /**
      * Handles a readResult.
      * If there are cached entries that can be returned without blocking only these are returned.
@@ -270,6 +294,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
         UUID attributeId = updateSegmentAttribute.getAttributeId();
         long newValue = updateSegmentAttribute.getNewValue();
         long expectedValue = updateSegmentAttribute.getExpectedValue();
+
+        if (!verifyToken(segmentName, updateSegmentAttribute.getRequestId(), updateSegmentAttribute.getDelegationToken(),
+                READ, "Update Segment Attribute")) {
+            return;
+        }
+
         long trace = LoggerHelpers.traceEnter(log, "updateSegmentAttribute", updateSegmentAttribute);
         val update = new AttributeUpdate(attributeId, AttributeUpdateType.ReplaceIfEquals, newValue, expectedValue);
         segmentStore.updateAttributes(segmentName, Collections.singletonList(update), TIMEOUT)
@@ -294,6 +324,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
         long requestId = getSegmentAttribute.getRequestId();
         String segmentName = getSegmentAttribute.getSegmentName();
         UUID attributeId = getSegmentAttribute.getAttributeId();
+
+        if (!verifyToken(segmentName, getSegmentAttribute.getRequestId(), getSegmentAttribute.getDelegationToken(),
+                READ, "Get StreamSegment Attribute" )) {
+            return;
+        }
+
         long trace = LoggerHelpers.traceEnter(log, "getSegmentAttribute", getSegmentAttribute);
         segmentStore.getStreamSegmentInfo(segmentName, false, TIMEOUT)
                 .thenAccept(properties -> {
@@ -315,6 +351,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
     @Override
     public void getStreamSegmentInfo(GetStreamSegmentInfo getStreamSegmentInfo) {
         String segmentName = getStreamSegmentInfo.getSegmentName();
+
+        if (!verifyToken(segmentName, getStreamSegmentInfo.getRequestId(), getStreamSegmentInfo.getDelegationToken(),
+                READ, "Get Stream Segment Info")) {
+            return;
+        }
+
         segmentStore.getStreamSegmentInfo(segmentName, false, TIMEOUT)
                 .thenAccept(properties -> {
                     if (properties != null) {
@@ -334,6 +376,11 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
     @Override
     public void getTransactionInfo(GetTransactionInfo request) {
         String transactionName = StreamSegmentNameUtils.getTransactionNameFromId(request.getSegment(), request.getTxid());
+
+        if (!verifyToken(request.getSegment(), request.getRequestId(), request.getDelegationToken(), READ, "Get Transaction Info")) {
+            return;
+        }
+
         segmentStore.getStreamSegmentInfo(transactionName, false, TIMEOUT)
                 .thenAccept(properties -> {
                     if (properties != null) {
@@ -359,6 +406,11 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
                 new AttributeUpdate(SCALE_POLICY_RATE, AttributeUpdateType.Replace, ((Integer) createStreamsSegment.getTargetRate()).longValue())
         );
 
+       if (!verifyToken(createStreamsSegment.getSegment(), createStreamsSegment.getRequestId(),
+               createStreamsSegment.getDelegationToken(), READ_UPDATE, "Create Segment")) {
+            return;
+       }
+
         segmentStore.createStreamSegment(createStreamsSegment.getSegment(), attributes, TIMEOUT)
                 .thenAccept(v -> {
                     createStreamSegment.reportSuccessEvent(timer.getElapsed());
@@ -385,6 +437,7 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
         }
 
         u = Exceptions.unwrap(u);
+
         if (u instanceof StreamSegmentExistsException) {
             log.info("Segment '{}' already exists and cannot perform operation '{}'.", segment, operation);
             connection.send(new SegmentAlreadyExists(requestId, segment));
@@ -401,13 +454,16 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
         } else if (u instanceof CancellationException) {
             log.info("Closing connection {} while performing {} due to {}.", connection, operation, u.getMessage());
             connection.close();
+        } else if (u instanceof AuthenticationException) {
+            log.warn("Authentication error during '{}'.", operation);
+            connection.send(new WireCommands.AuthTokenCheckFailed(requestId));
+            connection.close();
         } else if (u instanceof UnsupportedOperationException) {
             log.warn("Unsupported Operation '{}'.", operation, u);
             connection.send(new OperationUnsupported(requestId, operation));
         } else if (u instanceof BadOffsetException) {
             BadOffsetException badOffset = (BadOffsetException) u;
-            log.warn("Bad offset when performing '{}'; Expected Offset {}, Given {}.", operation, badOffset.getExpectedOffset(), badOffset.getGivenOffset());
-            connection.send(new SegmentIsTruncated(requestId, segment, badOffset.getExpectedOffset()));
+            connection.send(new SegmentIsTruncated(requestId, segment,  badOffset.getExpectedOffset()));
         } else {
             log.error("Error (Segment = '{}', Operation = '{}')", segment, operation, u);
             connection.close(); // Closing connection should reinitialize things, and hopefully fix the problem
@@ -419,6 +475,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
 
     @Override
     public void createTransaction(CreateTransaction createTransaction) {
+
+        if (!verifyToken(createStreamSegment.getName(), createTransaction.getRequestId(),
+                createTransaction.getDelegationToken(), READ_UPDATE, "Create Transaction")) {
+           return;
+        }
+
         Collection<AttributeUpdate> attributes = Collections.singleton(
                 new AttributeUpdate(CREATION_TIME, AttributeUpdateType.None, System.currentTimeMillis()));
         log.debug("Creating transaction {} ", createTransaction);
@@ -435,6 +497,11 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
         long requestId = commitTx.getRequestId();
         log.debug("Committing transaction {} ", commitTx);
 
+        if (!verifyToken(commitTx.getSegment(), commitTx.getRequestId(), commitTx.getDelegationToken(), READ_UPDATE,
+                "Commit Transaction")) {
+            return;
+        }
+
         // Seal and Merge can execute concurrently, as long as they are invoked in the correct order (first Seal, then Merge).
         // If Seal fails for whatever reason (except already sealed), then Merge will also fail because the txn is not sealed,
         // but invoking them in parallel does provide benefits in terms of reduced latency.
@@ -466,6 +533,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
     @Override
     public void abortTransaction(AbortTransaction abortTx) {
         long requestId = abortTx.getRequestId();
+
+        if (!verifyToken(abortTx.getSegment(), abortTx.getRequestId(), abortTx.getDelegationToken(), READ_UPDATE,
+                "Abort Transaction")) {
+            return;
+        }
+
         String transactionName = StreamSegmentNameUtils.getTransactionNameFromId(abortTx.getSegment(), abortTx.getTxid());
         log.debug("Aborting transaction {} ", abortTx);
         segmentStore.deleteStreamSegment(transactionName, TIMEOUT)
@@ -484,6 +557,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
     public void sealSegment(SealSegment sealSegment) {
         String segment = sealSegment.getSegment();
         log.debug("Sealing segment {} ", sealSegment);
+
+        if (!verifyToken(segment, sealSegment.getRequestId(), sealSegment.getDelegationToken(), READ_UPDATE,
+                "Seal Segment")) {
+            return;
+        }
+
         segmentStore.sealStreamSegment(segment, TIMEOUT)
                 .thenAccept(size -> connection.send(new SegmentSealed(sealSegment.getRequestId(), segment)))
                 .whenComplete((r, e) -> {
@@ -502,6 +581,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
     @Override
     public void truncateSegment(TruncateSegment truncateSegment) {
         String segment = truncateSegment.getSegment();
+
+        if (!verifyToken(segment, truncateSegment.getRequestId(), truncateSegment.getDelegationToken(),
+                READ_UPDATE, "Truncate Segment")) {
+            return;
+        }
+
         long offset = truncateSegment.getTruncationOffset();
         log.debug("Truncating segment {} at offset {} ", segment, offset);
         segmentStore.truncateStreamSegment(segment, offset, TIMEOUT)
@@ -513,6 +598,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
     public void deleteSegment(DeleteSegment deleteSegment) {
         String segment = deleteSegment.getSegment();
         log.debug("Deleting segment {} ", deleteSegment);
+
+        if (!verifyToken(segment, deleteSegment.getRequestId(), deleteSegment.getDelegationToken(), READ_UPDATE,
+                "Delete Segment")) {
+            return;
+        }
+
         segmentStore.deleteStreamSegment(segment, TIMEOUT)
                 .thenRun(() -> {
                     connection.send(new SegmentDeleted(deleteSegment.getRequestId(), segment));
@@ -525,6 +616,12 @@ public class PravegaRequestProcessor extends FailingRequestProcessor implements
 
     @Override
     public void updateSegmentPolicy(UpdateSegmentPolicy updateSegmentPolicy) {
+
+        if (!verifyToken(updateSegmentPolicy.getSegment(), updateSegmentPolicy.getRequestId(),
+                updateSegmentPolicy.getDelegationToken(), READ, "Update Segment Policy")) {
+            return;
+        }
+
         Collection<AttributeUpdate> attributes = Arrays.asList(
                 new AttributeUpdate(SCALE_POLICY_TYPE, AttributeUpdateType.Replace, (long) updateSegmentPolicy.getScaleType()),
                 new AttributeUpdate(SCALE_POLICY_RATE, AttributeUpdateType.Replace, updateSegmentPolicy.getTargetRate()));
diff --git a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java
index f5b5f17..84120e4 100644
--- a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java
+++ b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessor.java
@@ -15,11 +15,13 @@ import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.RemovalCause;
 import com.google.common.cache.RemovalListener;
 import com.google.common.cache.RemovalListeners;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.segment.impl.Segment;
 import io.pravega.client.stream.EventStreamWriter;
 import io.pravega.client.stream.EventWriterConfig;
 import io.pravega.client.stream.Serializer;
+import io.pravega.client.stream.impl.DefaultCredentials;
 import io.pravega.client.stream.impl.JavaSerializer;
 import io.pravega.common.util.Retry;
 import io.pravega.shared.NameUtils;
@@ -111,7 +113,18 @@ public class AutoScaleProcessor {
                 })
                 .runAsync(() -> {
                     if (clientFactory.get() == null) {
-                        clientFactory.compareAndSet(null, ClientFactory.withScope(NameUtils.INTERNAL_SCOPE_NAME, configuration.getControllerUri()));
+                        ClientFactory factory = null;
+                        if (configuration.isAuthEnabled()) {
+                            factory = ClientFactory.withScope(NameUtils.INTERNAL_SCOPE_NAME,
+                                    ClientConfig.builder().controllerURI(configuration.getControllerUri())
+                                                .credentials(new DefaultCredentials(configuration.getAuthPassword(), configuration.getAuthUsername()))
+                                                .trustStore(configuration.getTlsCertFile())
+                                                .build());
+                        } else {
+                            factory = ClientFactory.withScope(NameUtils.INTERNAL_SCOPE_NAME,
+                                    ClientConfig.builder().controllerURI(configuration.getControllerUri()).build());
+                        }
+                        clientFactory.compareAndSet(null, factory);
                     }
 
                     this.writer.set(clientFactory.get().createEventWriter(configuration.getInternalRequestStream(),
diff --git a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScalerConfig.java b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScalerConfig.java
index 608ba2b..d3492a2 100644
--- a/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScalerConfig.java
+++ b/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/stat/AutoScalerConfig.java
@@ -27,6 +27,12 @@ public class AutoScalerConfig {
     public static final Property<Integer> CACHE_CLEANUP_IN_SECONDS = Property.named("cacheCleanUpInSeconds", 5 * 60);
     public static final Property<Integer> CACHE_EXPIRY_IN_SECONDS = Property.named("cacheExpiryInSeconds", 20 * 60);
     public static final Property<String> CONTROLLER_URI = Property.named("controllerUri", "tcp://localhost:9090");
+    public static final Property<Boolean> TLS_ENABLED = Property.named("tlsEnabled", false);
+    public static final Property<String> TLS_CERT_FILE = Property.named("tlsCertFile", "");
+    public static final Property<Boolean> AUTH_ENABLED = Property.named("authEnabled", false);
+    public static final Property<String> AUTH_USERNAME = Property.named("authUsername", "");
+    public static final Property<String> AUTH_PASSWORD = Property.named("authPassword", "");
+    public static final Property<String> TOKEN_SIGNING_KEY = Property.named("tokenSigningKey", "secret");
 
     public static final String COMPONENT_CODE = "autoScale";
 
@@ -69,6 +75,40 @@ public class AutoScalerConfig {
     @Getter
     private final Duration cacheCleanup;
 
+    /**
+     * Flag to represent the case where interactions with controller are encrypted with TLS.
+     */
+    @Getter
+    private final boolean tlsEnabled;
+
+    /**
+     * The X.509 certificate file used for TLS connection to controller.
+     */
+    @Getter
+    private final String tlsCertFile;
+
+    /**
+     * Flag to represent the case where controller expects authorization details.
+     */
+    @Getter
+    private final boolean authEnabled;
+
+    /**
+     * Password for connection to Controller.
+     */
+    @Getter
+    private final String authPassword;
+    /**
+     * Username for connection to Controller.
+     */
+    @Getter
+    private final String authUsername;
+    /**
+     *
+     */
+    @Getter
+    private final String tokenSigningKey;
+
     private AutoScalerConfig(TypedProperties properties) throws ConfigurationException {
         this.internalRequestStream = properties.get(REQUEST_STREAM);
         this.cooldownDuration = Duration.ofSeconds(properties.getInt(COOLDOWN_IN_SECONDS));
@@ -76,6 +116,12 @@ public class AutoScalerConfig {
         this.cacheCleanup = Duration.ofSeconds(properties.getInt(CACHE_CLEANUP_IN_SECONDS));
         this.cacheExpiry = Duration.ofSeconds(properties.getInt(CACHE_EXPIRY_IN_SECONDS));
         this.controllerUri = URI.create(properties.get(CONTROLLER_URI));
+        this.tlsEnabled = properties.getBoolean(TLS_ENABLED);
+        this.authEnabled = properties.getBoolean(AUTH_ENABLED);
+        this.authUsername = properties.get(AUTH_USERNAME);
+        this.authPassword = properties.get(AUTH_PASSWORD);
+        this.tlsCertFile = properties.get(TLS_CERT_FILE);
+        this.tokenSigningKey = properties.get(TOKEN_SIGNING_KEY);
     }
 
     public static ConfigBuilder<AutoScalerConfig> builder() {
diff --git a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/delegationtoken/TokenVerifierImplTest.java b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/delegationtoken/TokenVerifierImplTest.java
new file mode 100644
index 0000000..5a563bb
--- /dev/null
+++ b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/delegationtoken/TokenVerifierImplTest.java
@@ -0,0 +1,98 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.segmentstore.server.host.delegationtoken;
+
+import io.jsonwebtoken.Jwts;
+import io.jsonwebtoken.SignatureAlgorithm;
+import io.pravega.segmentstore.server.host.stat.AutoScalerConfig;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static io.pravega.auth.AuthHandler.Permissions.READ;
+import static io.pravega.auth.AuthHandler.Permissions.READ_UPDATE;
+import static io.pravega.test.common.AssertExtensions.assertThrows;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class TokenVerifierImplTest {
+
+    @Before
+    public void setUp() throws Exception {
+
+    }
+
+
+    @Test
+    public void testTokenVerifier() {
+        AutoScalerConfig config = AutoScalerConfig.builder()
+                                                  .with(AutoScalerConfig.AUTH_ENABLED, false)
+                                                  .with(AutoScalerConfig.TOKEN_SIGNING_KEY, "secret")
+                                                  .build();
+        DelegationTokenVerifier tokenVerifier = new TokenVerifierImpl(config);
+
+        //Auth disabled. No token is checked.
+        tokenVerifier.verifyToken("xyz", null, READ);
+
+        //Auth enabled, error on null token
+        config = AutoScalerConfig.builder()
+                                 .with(AutoScalerConfig.AUTH_ENABLED, true)
+                                 .with(AutoScalerConfig.TOKEN_SIGNING_KEY, "secret")
+                                 .build();
+        tokenVerifier = new TokenVerifierImpl(config);
+        DelegationTokenVerifier finalTokenVerifier = tokenVerifier;
+        assertThrows(IllegalArgumentException.class, () -> {
+            finalTokenVerifier.verifyToken("xyz", null, READ);
+        });
+
+        Map<String, Object> claims = new HashMap();
+
+        claims.put("*", String.valueOf(READ_UPDATE));
+
+        String token = Jwts.builder()
+                           .setSubject("segmentstoreresource")
+                           .setAudience("segmentstore")
+                           .setClaims(claims)
+                           .signWith(SignatureAlgorithm.HS512, "secret".getBytes())
+                           .compact();
+        assertTrue("Wildcard check should pass", finalTokenVerifier.verifyToken("xyz", token, READ));
+
+        //TODO: Add more tests..  level mismatch, timer expiry.
+        //Level mismatch test
+        claims = new HashMap<>();
+        claims.put("xyz", String.valueOf(READ));
+
+        token = Jwts.builder()
+                           .setSubject("segmentstoreresource")
+                           .setAudience("segmentstore")
+                           .setClaims(claims)
+                           .signWith(SignatureAlgorithm.HS512, "secret".getBytes())
+                           .compact();
+        assertFalse("Level check should fail", finalTokenVerifier.verifyToken("xyz", token, READ_UPDATE));
+
+        claims = new HashMap<>();
+        claims.put("xyz", String.valueOf(READ_UPDATE));
+        token = Jwts.builder()
+                    .setSubject("segmentstoreresource")
+                    .setAudience("segmentstore")
+                    .setClaims(claims)
+                    .signWith(SignatureAlgorithm.HS512, "secret".getBytes())
+                    .setExpiration(new Date())
+                    .compact();
+        assertFalse("Level check should fail", finalTokenVerifier.verifyToken("xyz", token, READ_UPDATE));
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+}
\ No newline at end of file
diff --git a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorAuthFailedTest.java b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorAuthFailedTest.java
new file mode 100644
index 0000000..dc11298
--- /dev/null
+++ b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorAuthFailedTest.java
@@ -0,0 +1,45 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.segmentstore.server.host.handler;
+
+import io.pravega.segmentstore.contracts.StreamSegmentStore;
+import io.pravega.shared.protocol.netty.FailingRequestProcessor;
+import io.pravega.shared.protocol.netty.WireCommands;
+import java.util.UUID;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+public class AppendProcessorAuthFailedTest {
+
+    private AppendProcessor processor;
+    private ServerConnection connection;
+
+    @Before
+    public void setUp() throws Exception {
+        StreamSegmentStore store = mock(StreamSegmentStore.class);
+        connection = mock(ServerConnection.class);
+        processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), (resource, token, expectedLevel) -> false);
+
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void setupAppend() {
+        processor.setupAppend(new WireCommands.SetupAppend(100L, UUID.randomUUID(), "segment", "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+}
\ No newline at end of file
diff --git a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorTest.java b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorTest.java
index 72a8e10..88fa3a4 100644
--- a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorTest.java
+++ b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorTest.java
@@ -27,7 +27,6 @@ import io.pravega.shared.protocol.netty.WireCommands.ConditionalCheckFailed;
 import io.pravega.shared.protocol.netty.WireCommands.DataAppended;
 import io.pravega.shared.protocol.netty.WireCommands.OperationUnsupported;
 import io.pravega.shared.protocol.netty.WireCommands.SetupAppend;
-import lombok.Cleanup;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -36,6 +35,7 @@ import java.util.Map;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
+import lombok.Cleanup;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.mockito.InOrder;
@@ -64,14 +64,14 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         setupGetStreamSegmentInfo(streamSegmentName, clientId, store);
         CompletableFuture<Void> result = CompletableFuture.completedFuture(null);
         when(store.append(streamSegmentName, data, updateEventNumber(clientId, data.length), AppendProcessor.TIMEOUT))
             .thenReturn(result);
 
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName, ""));
         processor.append(new Append(streamSegmentName, clientId, data.length, Unpooled.wrappedBuffer(data), null));
         verify(store).getStreamSegmentInfo(anyString(), eq(true), eq(AppendProcessor.TIMEOUT));
         verify(store).append(streamSegmentName,
@@ -94,10 +94,10 @@ public class AppendProcessorTest {
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         InOrder verifier = Mockito.inOrder(store);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         setupGetStreamSegmentInfo(streamSegmentName1, clientId, store);
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName1));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName1, ""));
         verifier.verify(store).getStreamSegmentInfo(anyString(), eq(true), eq(AppendProcessor.TIMEOUT));
         
         CompletableFuture<Void> result = CompletableFuture.completedFuture(null);
@@ -107,7 +107,7 @@ public class AppendProcessorTest {
         verifier.verify(store).append(streamSegmentName1, data, updateEventNumber(clientId, 10), AppendProcessor.TIMEOUT);
 
         setupGetStreamSegmentInfo(streamSegmentName2, clientId, store);
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName2));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName2, ""));
         verifier.verify(store).getStreamSegmentInfo(anyString(), eq(true), eq(AppendProcessor.TIMEOUT));
         
         CompletableFuture<Void> result2 = CompletableFuture.completedFuture(null);
@@ -132,13 +132,13 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         setupGetStreamSegmentInfo(streamSegmentName, clientId, store);
         CompletableFuture<Void> result = CompletableFuture.completedFuture(null);
         when(store.append(streamSegmentName, data, updateEventNumber(clientId, 1),
                           AppendProcessor.TIMEOUT)).thenReturn(result);
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName, ""));
         processor.append(new Append(streamSegmentName, clientId, 1, Unpooled.wrappedBuffer(data), null));
 
         result = CompletableFuture.completedFuture(null);
@@ -165,13 +165,13 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         setupGetStreamSegmentInfo(streamSegmentName, clientId, store);
         CompletableFuture<Void> result = CompletableFuture.completedFuture(null);
         when(store.append(streamSegmentName, data, updateEventNumber(clientId, 1),
                           AppendProcessor.TIMEOUT)).thenReturn(result);
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName, ""));
         processor.append(new Append(streamSegmentName, clientId, 1, Unpooled.wrappedBuffer(data), null));
 
         result = Futures.failedFuture(new BadOffsetException(streamSegmentName, data.length, 0));
@@ -197,10 +197,10 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         setupGetStreamSegmentInfo(streamSegmentName, clientId, 100, store);
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName, ""));
         try {
             processor.append(new Append(streamSegmentName, clientId, data.length, Unpooled.wrappedBuffer(data), null));
             fail();
@@ -221,7 +221,7 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
         try {
             processor.append(new Append(streamSegmentName, clientId, data.length, Unpooled.wrappedBuffer(data), null));
             fail();
@@ -241,7 +241,7 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         setupGetStreamSegmentInfo(segment1, clientId1, store);
         CompletableFuture<Void> result = CompletableFuture.completedFuture(null);
@@ -253,9 +253,9 @@ public class AppendProcessorTest {
         when(store.append(segment2, data, updateEventNumber(clientId2, data.length), AppendProcessor.TIMEOUT))
             .thenReturn(result);
 
-        processor.setupAppend(new SetupAppend(1, clientId1, segment1));
+        processor.setupAppend(new SetupAppend(1, clientId1, segment1, ""));
         processor.append(new Append(segment1, clientId1, data.length, Unpooled.wrappedBuffer(data), null));
-        processor.setupAppend(new SetupAppend(2, clientId2, segment2));
+        processor.setupAppend(new SetupAppend(2, clientId2, segment2, ""));
         processor.append(new Append(segment2, clientId2, data.length, Unpooled.wrappedBuffer(data), null));
 
         verify(store).getStreamSegmentInfo(eq(segment1), eq(true), eq(AppendProcessor.TIMEOUT));
@@ -284,7 +284,7 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         setupGetStreamSegmentInfo(streamSegmentName, clientId, store);
         CompletableFuture<Void> result = new CompletableFuture<>();
@@ -292,7 +292,7 @@ public class AppendProcessorTest {
         when(store.append(streamSegmentName, data, updateEventNumber(clientId, data.length), AppendProcessor.TIMEOUT))
             .thenReturn(result);
 
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName, ""));
         processor.append(new Append(streamSegmentName, clientId, data.length, Unpooled.wrappedBuffer(data), null));
         try {
             processor.append(new Append(streamSegmentName, clientId, data.length * 2, Unpooled.wrappedBuffer(data), null));
@@ -314,12 +314,12 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         CompletableFuture<SegmentProperties> propsFuture = CompletableFuture.completedFuture(
                 StreamSegmentInformation.builder().name(streamSegmentName).build());
         when(store.getStreamSegmentInfo(streamSegmentName, true, AppendProcessor.TIMEOUT)).thenReturn(propsFuture);
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName, ""));
         verify(store).getStreamSegmentInfo(streamSegmentName, true, AppendProcessor.TIMEOUT);
         
         CompletableFuture<Void> result = CompletableFuture.completedFuture(null);
@@ -377,12 +377,12 @@ public class AppendProcessorTest {
             return null;
         }).when(connection).send(any(DataAppended.class));
 
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         CompletableFuture<SegmentProperties> propsFuture = CompletableFuture.completedFuture(
                 StreamSegmentInformation.builder().name(streamSegmentName).build());
         when(store.getStreamSegmentInfo(streamSegmentName, true, AppendProcessor.TIMEOUT)).thenReturn(propsFuture);
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName, ""));
         verify(store).getStreamSegmentInfo(streamSegmentName, true, AppendProcessor.TIMEOUT);
 
         CompletableFuture<Void> result = CompletableFuture.completedFuture(null);
@@ -429,7 +429,7 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         CompletableFuture<SegmentProperties> propsFuture = CompletableFuture.completedFuture(
                 StreamSegmentInformation.builder()
@@ -438,7 +438,7 @@ public class AppendProcessorTest {
                         .build());
 
         when(store.getStreamSegmentInfo(streamSegmentName, true, AppendProcessor.TIMEOUT)).thenReturn(propsFuture);
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName, ""));
         verify(store).getStreamSegmentInfo(streamSegmentName, true, AppendProcessor.TIMEOUT);
 
         int eventCount = 10;
@@ -466,14 +466,14 @@ public class AppendProcessorTest {
         byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };
         StreamSegmentStore store = mock(StreamSegmentStore.class);
         ServerConnection connection = mock(ServerConnection.class);
-        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor());
+        AppendProcessor processor = new AppendProcessor(store, connection, new FailingRequestProcessor(), null);
 
         setupGetStreamSegmentInfo(streamSegmentName, clientId, store);
         CompletableFuture<Void> result = Futures.failedFuture(new UnsupportedOperationException());
         when(store.append(streamSegmentName, data, updateEventNumber(clientId, data.length), AppendProcessor.TIMEOUT))
                 .thenReturn(result);
 
-        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName));
+        processor.setupAppend(new SetupAppend(1, clientId, streamSegmentName, ""));
         processor.append(new Append(streamSegmentName, clientId, data.length, Unpooled.wrappedBuffer(data), null));
         verify(store).getStreamSegmentInfo(anyString(), eq(true), eq(AppendProcessor.TIMEOUT));
         verify(store).append(streamSegmentName,
diff --git a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorAuthFailedTest.java b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorAuthFailedTest.java
new file mode 100644
index 0000000..45d5d81
--- /dev/null
+++ b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorAuthFailedTest.java
@@ -0,0 +1,118 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.segmentstore.server.host.handler;
+
+import io.pravega.segmentstore.contracts.StreamSegmentStore;
+import io.pravega.shared.protocol.netty.WireCommands;
+import java.util.UUID;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+public class PravegaRequestProcessorAuthFailedTest {
+
+    private PravegaRequestProcessor processor;
+    private ServerConnection connection;
+
+    @Before
+    public void setUp() throws Exception {
+        StreamSegmentStore store = mock(StreamSegmentStore.class);
+        connection = mock(ServerConnection.class);
+        processor = new PravegaRequestProcessor(store, connection, null, (resource, token, expectedLevel) -> false);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void readSegment() {
+        processor.readSegment(new WireCommands.ReadSegment("segment", 0, 10, ""));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(0));
+    }
+
+    @Test
+    public void updateSegmentAttribute() {
+        processor.updateSegmentAttribute(new WireCommands.UpdateSegmentAttribute(100L, "segment",
+                null, 0, 0, "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void getSegmentAttribute() {
+        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(100L, "segment",
+                null, "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void getStreamSegmentInfo() {
+        processor.getStreamSegmentInfo(new WireCommands.GetStreamSegmentInfo(100L,
+                "segment", "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void getTransactionInfo() {
+        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(100L, "segment", UUID.randomUUID(), "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void createSegment() {
+        processor.createSegment(new WireCommands.CreateSegment(100L, "segment", (byte) 0, 0, "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void createTransaction() {
+        processor.createTransaction(new WireCommands.CreateTransaction(100L, "segment", UUID.randomUUID(), "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void commitTransaction() {
+        processor.commitTransaction(new WireCommands.CommitTransaction(100L, "segment", UUID.randomUUID(), "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void abortTransaction() {
+        processor.abortTransaction(new WireCommands.AbortTransaction(100L, "segment", UUID.randomUUID(), "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void sealSegment() {
+        processor.sealSegment(new WireCommands.SealSegment(100L, "segment", "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void truncateSegment() {
+        processor.truncateSegment(new WireCommands.TruncateSegment(100L, "segment", 0, "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void deleteSegment() {
+        processor.deleteSegment(new WireCommands.DeleteSegment(100L, "segment", "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+
+    @Test
+    public void updateSegmentPolicy() {
+        processor.updateSegmentPolicy(new WireCommands.UpdateSegmentPolicy(100L, "segment", (byte) 0, 0, "token"));
+        verify(connection).send(new WireCommands.AuthTokenCheckFailed(100L));
+    }
+}
\ No newline at end of file
diff --git a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java
index 74b9519..349f777 100644
--- a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java
+++ b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java
@@ -145,7 +145,7 @@ public class PravegaRequestProcessorTest {
         when(store.read(streamSegmentName, 0, readLength, PravegaRequestProcessor.TIMEOUT)).thenReturn(readResult);
 
         // Execute and Verify readSegment calling stack in connection and store is executed as design.
-        processor.readSegment(new WireCommands.ReadSegment(streamSegmentName, 0, readLength));
+        processor.readSegment(new WireCommands.ReadSegment(streamSegmentName, 0,  readLength, ""));
         verify(store).read(streamSegmentName, 0, readLength, PravegaRequestProcessor.TIMEOUT);
         verify(connection).send(new WireCommands.SegmentRead(streamSegmentName, 0, true, false, ByteBuffer.wrap(data)));
         verifyNoMoreInteractions(connection);
@@ -174,7 +174,7 @@ public class PravegaRequestProcessorTest {
         when(store.read(streamSegmentName, 0, readLength, PravegaRequestProcessor.TIMEOUT)).thenReturn(readResult);
 
         // Execute and Verify readSegment calling stack in connection and store is executed as design.
-        processor.readSegment(new WireCommands.ReadSegment(streamSegmentName, 0, readLength));
+        processor.readSegment(new WireCommands.ReadSegment(streamSegmentName, 0, readLength, ""));
         verify(store).read(streamSegmentName, 0, readLength, PravegaRequestProcessor.TIMEOUT);
         verify(connection).send(new WireCommands.SegmentRead(streamSegmentName, 0, false, true, ByteBuffer.wrap(new byte[0])));
         verifyNoMoreInteractions(connection);
@@ -209,7 +209,7 @@ public class PravegaRequestProcessorTest {
                 .thenReturn(CompletableFuture.completedFuture(info));
 
         // Execute and Verify readSegment calling stack in connection and store is executed as design.
-        processor.readSegment(new WireCommands.ReadSegment(streamSegmentName, 0, readLength));
+        processor.readSegment(new WireCommands.ReadSegment(streamSegmentName, 0, readLength, ""));
         verify(store).read(streamSegmentName, 0, readLength, PravegaRequestProcessor.TIMEOUT);
         verify(store).getStreamSegmentInfo(streamSegmentName, false, PravegaRequestProcessor.TIMEOUT);
         verify(connection).send(new WireCommands.SegmentIsTruncated(0, streamSegmentName, info.getStartOffset()));
@@ -230,9 +230,9 @@ public class PravegaRequestProcessorTest {
         PravegaRequestProcessor processor = new PravegaRequestProcessor(store, connection);
 
         // Execute and Verify createSegment/getStreamSegmentInfo calling stack is executed as design.
-        processor.createSegment(new WireCommands.CreateSegment(1, streamSegmentName, WireCommands.CreateSegment.NO_SCALE, 0));
+        processor.createSegment(new WireCommands.CreateSegment(1, streamSegmentName, WireCommands.CreateSegment.NO_SCALE, 0, ""));
         assertTrue(append(streamSegmentName, 1, store));
-        processor.getStreamSegmentInfo(new WireCommands.GetStreamSegmentInfo(1, streamSegmentName));
+        processor.getStreamSegmentInfo(new WireCommands.GetStreamSegmentInfo(1,  streamSegmentName, ""));
         assertTrue(append(streamSegmentName, 2, store));
         order.verify(connection).send(new WireCommands.SegmentCreated(1, streamSegmentName));
         order.verify(connection).send(Mockito.any(WireCommands.StreamSegmentInfo.class));
@@ -257,35 +257,35 @@ public class PravegaRequestProcessorTest {
         PravegaRequestProcessor processor = new PravegaRequestProcessor(store, connection);
 
         processor.createSegment(new WireCommands.CreateSegment(0, streamSegmentName,
-                                                               WireCommands.CreateSegment.NO_SCALE, 0));
+                                                               WireCommands.CreateSegment.NO_SCALE, 0, ""));
         order.verify(connection).send(new WireCommands.SegmentCreated(0, streamSegmentName));
 
-        processor.createTransaction(new WireCommands.CreateTransaction(1, streamSegmentName, txnid));
+        processor.createTransaction(new WireCommands.CreateTransaction(1,  streamSegmentName, txnid, ""));
         assertTrue(append(StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName, txnid), 1, store));
-        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(2, streamSegmentName, txnid));
+        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(2, streamSegmentName,  txnid, ""));
         assertTrue(append(StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName, txnid), 2, store));
         order.verify(connection).send(new WireCommands.TransactionCreated(1, streamSegmentName, txnid));
         order.verify(connection).send(Mockito.argThat(t -> {
             return t instanceof TransactionInfo && ((TransactionInfo) t).exists();
         }));
-        processor.commitTransaction(new WireCommands.CommitTransaction(3, streamSegmentName, txnid));
+        processor.commitTransaction(new WireCommands.CommitTransaction(3, streamSegmentName, txnid, ""));
         order.verify(connection).send(new WireCommands.TransactionCommitted(3, streamSegmentName, txnid));
-        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(4, streamSegmentName, txnid));
+        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(4, streamSegmentName, txnid, ""));
         order.verify(connection)
              .send(new WireCommands.NoSuchSegment(4, StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName,
                                                                                                      txnid)));
 
         txnid = UUID.randomUUID();
-        processor.createTransaction(new WireCommands.CreateTransaction(1, streamSegmentName, txnid));
+        processor.createTransaction(new WireCommands.CreateTransaction(1, streamSegmentName, txnid, ""));
         assertTrue(append(StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName, txnid), 1, store));
         order.verify(connection).send(new WireCommands.TransactionCreated(1, streamSegmentName, txnid));
-        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(2, streamSegmentName, txnid));
+        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(2, streamSegmentName, txnid, ""));
         order.verify(connection).send(Mockito.argThat(t -> {
             return t instanceof TransactionInfo && ((TransactionInfo) t).exists();
         }));
-        processor.abortTransaction(new WireCommands.AbortTransaction(3, streamSegmentName, txnid));
+        processor.abortTransaction(new WireCommands.AbortTransaction(3, streamSegmentName, txnid, ""));
         order.verify(connection).send(new WireCommands.TransactionAborted(3, streamSegmentName, txnid));
-        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(4, streamSegmentName, txnid));
+        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(4, streamSegmentName, txnid, ""));
         order.verify(connection)
              .send(new WireCommands.NoSuchSegment(4, StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName,
                                                                                                      txnid)));
@@ -293,18 +293,18 @@ public class PravegaRequestProcessorTest {
         // Verify the case when the transaction segment is already sealed. This simulates the case when the process
         // crashed after sealing, but before issuing the merge.
         txnid = UUID.randomUUID();
-        processor.createTransaction(new WireCommands.CreateTransaction(1, streamSegmentName, txnid));
+        processor.createTransaction(new WireCommands.CreateTransaction(1, streamSegmentName, txnid, ""));
         assertTrue(append(StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName, txnid), 1, store));
-        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(2, streamSegmentName, txnid));
+        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(2, streamSegmentName, txnid, ""));
         assertTrue(append(StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName, txnid), 2, store));
 
         // Seal the transaction in the SegmentStore.
         String txnName = StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName, txnid);
         store.sealStreamSegment(txnName, Duration.ZERO).join();
 
-        processor.commitTransaction(new WireCommands.CommitTransaction(3, streamSegmentName, txnid));
+        processor.commitTransaction(new WireCommands.CommitTransaction(3, streamSegmentName, txnid, ""));
         order.verify(connection).send(new WireCommands.TransactionCommitted(3, streamSegmentName, txnid));
-        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(4, streamSegmentName, txnid));
+        processor.getTransactionInfo(new WireCommands.GetTransactionInfo(4, streamSegmentName, txnid, ""));
         order.verify(connection)
                 .send(new WireCommands.NoSuchSegment(4, StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName,
                         txnid)));
@@ -330,12 +330,12 @@ public class PravegaRequestProcessorTest {
         PravegaRequestProcessor processor = new PravegaRequestProcessor(store, connection);
 
         processor.createSegment(new WireCommands.CreateSegment(0, streamSegmentName,
-                WireCommands.CreateSegment.NO_SCALE, 0));
+                WireCommands.CreateSegment.NO_SCALE, 0, ""));
         order.verify(connection).send(new WireCommands.SegmentCreated(0, streamSegmentName));
 
-        processor.createTransaction(new WireCommands.CreateTransaction(1, streamSegmentName, txnid));
+        processor.createTransaction(new WireCommands.CreateTransaction(1, streamSegmentName, txnid, ""));
         order.verify(connection).send(new WireCommands.TransactionCreated(1, streamSegmentName, txnid));
-        processor.commitTransaction(new WireCommands.CommitTransaction(2, streamSegmentName, txnid));
+        processor.commitTransaction(new WireCommands.CommitTransaction(2, streamSegmentName, txnid, ""));
         order.verify(connection).send(new WireCommands.TransactionCommitted(2, streamSegmentName, txnid));
 
         txnid = UUID.randomUUID();
@@ -345,9 +345,9 @@ public class PravegaRequestProcessorTest {
         doReturn(Futures.failedFuture(new StreamSegmentNotExistsException(streamSegmentName))).when(store).mergeTransaction(
                 anyString(), any());
 
-        processor.createTransaction(new WireCommands.CreateTransaction(3, streamSegmentName, txnid));
+        processor.createTransaction(new WireCommands.CreateTransaction(3, streamSegmentName, txnid, ""));
         order.verify(connection).send(new WireCommands.TransactionCreated(3, streamSegmentName, txnid));
-        processor.commitTransaction(new WireCommands.CommitTransaction(4, streamSegmentName, txnid));
+        processor.commitTransaction(new WireCommands.CommitTransaction(4, streamSegmentName, txnid, ""));
 
         order.verify(connection).send(new WireCommands.NoSuchSegment(4, StreamSegmentNameUtils.getTransactionNameFromId(streamSegmentName, txnid)));
     }
@@ -365,30 +365,30 @@ public class PravegaRequestProcessorTest {
         PravegaRequestProcessor processor = new PravegaRequestProcessor(store, connection);
 
         // Execute and Verify createSegment/getStreamSegmentInfo calling stack is executed as design.
-        processor.createSegment(new WireCommands.CreateSegment(1, streamSegmentName, WireCommands.CreateSegment.NO_SCALE, 0));
+        processor.createSegment(new WireCommands.CreateSegment(1, streamSegmentName, WireCommands.CreateSegment.NO_SCALE, 0, ""));
         order.verify(connection).send(new WireCommands.SegmentCreated(1, streamSegmentName));
 
-        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(2, streamSegmentName, attribute));
+        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(2, streamSegmentName, attribute, ""));
         order.verify(connection).send(new WireCommands.SegmentAttribute(2, WireCommands.NULL_ATTRIBUTE_VALUE));
 
-        processor.updateSegmentAttribute(new WireCommands.UpdateSegmentAttribute(2, streamSegmentName, attribute, 1, WireCommands.NULL_ATTRIBUTE_VALUE));
+        processor.updateSegmentAttribute(new WireCommands.UpdateSegmentAttribute(2, streamSegmentName, attribute, 1, WireCommands.NULL_ATTRIBUTE_VALUE, ""));
         order.verify(connection).send(new WireCommands.SegmentAttributeUpdated(2, true));
-        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(3, streamSegmentName, attribute));
+        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(3, streamSegmentName, attribute, ""));
         order.verify(connection).send(new WireCommands.SegmentAttribute(3, 1));
 
-        processor.updateSegmentAttribute(new WireCommands.UpdateSegmentAttribute(4, streamSegmentName, attribute, 5, WireCommands.NULL_ATTRIBUTE_VALUE));
+        processor.updateSegmentAttribute(new WireCommands.UpdateSegmentAttribute(4, streamSegmentName, attribute, 5, WireCommands.NULL_ATTRIBUTE_VALUE, ""));
         order.verify(connection).send(new WireCommands.SegmentAttributeUpdated(4, false));
-        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(5, streamSegmentName, attribute));
+        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(5, streamSegmentName, attribute, ""));
         order.verify(connection).send(new WireCommands.SegmentAttribute(5, 1));
 
-        processor.updateSegmentAttribute(new WireCommands.UpdateSegmentAttribute(6, streamSegmentName, attribute, 10, 1));
+        processor.updateSegmentAttribute(new WireCommands.UpdateSegmentAttribute(6, streamSegmentName, attribute, 10, 1, ""));
         order.verify(connection).send(new WireCommands.SegmentAttributeUpdated(6, true));
-        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(7, streamSegmentName, attribute));
+        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(7, streamSegmentName, attribute, ""));
         order.verify(connection).send(new WireCommands.SegmentAttribute(7, 10));
 
-        processor.updateSegmentAttribute(new WireCommands.UpdateSegmentAttribute(8, streamSegmentName, attribute, WireCommands.NULL_ATTRIBUTE_VALUE, 10));
+        processor.updateSegmentAttribute(new WireCommands.UpdateSegmentAttribute(8, streamSegmentName, attribute, WireCommands.NULL_ATTRIBUTE_VALUE, 10, ""));
         order.verify(connection).send(new WireCommands.SegmentAttributeUpdated(8, true));
-        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(9, streamSegmentName, attribute));
+        processor.getSegmentAttribute(new WireCommands.GetSegmentAttribute(9, streamSegmentName, attribute, ""));
         order.verify(connection).send(new WireCommands.SegmentAttribute(9, WireCommands.NULL_ATTRIBUTE_VALUE));
     }
 
@@ -405,33 +405,33 @@ public class PravegaRequestProcessorTest {
         PravegaRequestProcessor processor = new PravegaRequestProcessor(store, connection);
 
         // Create a segment and append 2 bytes.
-        processor.createSegment(new WireCommands.CreateSegment(1, streamSegmentName, WireCommands.CreateSegment.NO_SCALE, 0));
+        processor.createSegment(new WireCommands.CreateSegment(1, streamSegmentName, WireCommands.CreateSegment.NO_SCALE, 0, ""));
         assertTrue(append(streamSegmentName, 1, store));
         assertTrue(append(streamSegmentName, 2, store));
 
-        processor.sealSegment(new WireCommands.SealSegment(2, streamSegmentName));
+        processor.sealSegment(new WireCommands.SealSegment(2, streamSegmentName, ""));
         assertFalse(append(streamSegmentName, 2, store));
 
         // Truncate half.
         final long truncateOffset = store.getStreamSegmentInfo(streamSegmentName, false, PravegaRequestProcessor.TIMEOUT)
                 .join().getLength() / 2;
         AssertExtensions.assertGreaterThan("Nothing to truncate.", 0, truncateOffset);
-        processor.truncateSegment(new WireCommands.TruncateSegment(3, streamSegmentName, truncateOffset));
+        processor.truncateSegment(new WireCommands.TruncateSegment(3, streamSegmentName, truncateOffset, ""));
         assertEquals(truncateOffset, store.getStreamSegmentInfo(streamSegmentName, false, PravegaRequestProcessor.TIMEOUT)
                 .join().getStartOffset());
 
         // Truncate at the same offset - verify idempotence.
-        processor.truncateSegment(new WireCommands.TruncateSegment(4, streamSegmentName, truncateOffset));
+        processor.truncateSegment(new WireCommands.TruncateSegment(4, streamSegmentName, truncateOffset, ""));
         assertEquals(truncateOffset, store.getStreamSegmentInfo(streamSegmentName, false, PravegaRequestProcessor.TIMEOUT)
                 .join().getStartOffset());
 
         // Truncate at a lower offset - verify failure.
-        processor.truncateSegment(new WireCommands.TruncateSegment(5, streamSegmentName, truncateOffset - 1));
+        processor.truncateSegment(new WireCommands.TruncateSegment(5, streamSegmentName, truncateOffset - 1, ""));
         assertEquals(truncateOffset, store.getStreamSegmentInfo(streamSegmentName, false, PravegaRequestProcessor.TIMEOUT)
                 .join().getStartOffset());
 
         // Delete.
-        processor.deleteSegment(new WireCommands.DeleteSegment(6, streamSegmentName));
+        processor.deleteSegment(new WireCommands.DeleteSegment(6, streamSegmentName, ""));
         assertFalse(append(streamSegmentName, 4, store));
 
         // Verify connection response with same order.
@@ -457,7 +457,7 @@ public class PravegaRequestProcessorTest {
         PravegaRequestProcessor processor = new PravegaRequestProcessor(store, connection);
 
         // Execute and Verify createSegment/getStreamSegmentInfo calling stack is executed as design.
-        processor.createSegment(new WireCommands.CreateSegment(1, streamSegmentName, WireCommands.CreateSegment.NO_SCALE, 0));
+        processor.createSegment(new WireCommands.CreateSegment(1, streamSegmentName, WireCommands.CreateSegment.NO_SCALE, 0, ""));
         order.verify(connection).send(new WireCommands.OperationUnsupported(1, "Create segment"));
     }
 
diff --git a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessorTest.java b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessorTest.java
index d51f0a7..7f0eaca 100644
--- a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessorTest.java
+++ b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/stat/AutoScaleProcessorTest.java
@@ -25,6 +25,7 @@ import java.util.function.Consumer;
 import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertNull;
@@ -38,6 +39,7 @@ public class AutoScaleProcessorTest {
     private static final String STREAM3 = "stream3";
     private static final String STREAM4 = "stream4";
     ScheduledExecutorService maintenanceExecutor;
+    private boolean authEnabled = false;
 
     @Before
     public void setup() {
@@ -85,6 +87,9 @@ public class AutoScaleProcessorTest {
         AutoScaleProcessor monitor = new AutoScaleProcessor(writer,
                 AutoScalerConfig.builder().with(AutoScalerConfig.MUTE_IN_SECONDS, 0)
                         .with(AutoScalerConfig.COOLDOWN_IN_SECONDS, 0)
+                        .with(AutoScalerConfig.AUTH_ENABLED, authEnabled)
+                                .with(AutoScalerConfig.AUTH_USERNAME, "admin")
+                                .with(AutoScalerConfig.AUTH_PASSWORD, "passwd")
                         .with(AutoScalerConfig.CACHE_CLEANUP_IN_SECONDS, 1)
                         .with(AutoScalerConfig.CACHE_EXPIRY_IN_SECONDS, 1).build(),
                 maintenanceExecutor);
@@ -121,6 +126,13 @@ public class AutoScaleProcessorTest {
         assertTrue(Futures.await(result4));
     }
 
+    @Ignore
+    public void scaleTestWithAuth() {
+        authEnabled = true;
+        this.scaleTest();
+        authEnabled = false;
+    }
+
     @Test(timeout = 10000)
     public void testCacheExpiry() {
         CompletableFuture<Void> scaleDownFuture = new CompletableFuture<>();
diff --git a/segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceConfig.java b/segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceConfig.java
index 4b59ed7..43a788e 100644
--- a/segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceConfig.java
+++ b/segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceConfig.java
@@ -40,6 +40,9 @@ public class ServiceConfig {
     public static final Property<DataLogType> DATALOG_IMPLEMENTATION = Property.named("dataLogImplementation", DataLogType.INMEMORY);
     public static final Property<StorageType> STORAGE_IMPLEMENTATION = Property.named("storageImplementation", StorageType.INMEMORY);
     public static final Property<Boolean> READONLY_SEGMENT_STORE = Property.named("readOnlySegmentStore", false);
+    public static final Property<Boolean> ENABLE_TLS = Property.named("enableTls", false);
+    public static final Property<String> CERT_FILE = Property.named("certFile", "");
+    public static final Property<String> KEY_FILE = Property.named("keyFile", "");
 
     public static final String COMPONENT_CODE = "pravegaservice";
 
@@ -184,6 +187,23 @@ public class ServiceConfig {
     @Getter
     private final boolean readOnlySegmentStore;
 
+    /**
+     * Enables TLS support for the serer.
+     */
+    @Getter
+    private final boolean enableTls;
+
+    /**
+     * Represents the certificate file for the TLS server.
+     */
+    @Getter
+    private final String certFile;
+
+    /**
+     * Represents the private key file for the TLS server.
+     */
+    @Getter
+    private final String keyFile;
     //endregion
 
     //region Constructor
@@ -228,6 +248,9 @@ public class ServiceConfig {
         this.dataLogTypeImplementation = properties.getEnum(DATALOG_IMPLEMENTATION, DataLogType.class);
         this.storageImplementation = properties.getEnum(STORAGE_IMPLEMENTATION, StorageType.class);
         this.readOnlySegmentStore = properties.getBoolean(READONLY_SEGMENT_STORE);
+        this.enableTls = properties.getBoolean(ENABLE_TLS);
+        this.keyFile = properties.get(KEY_FILE);
+        this.certFile = properties.get(CERT_FILE);
     }
 
     /**
diff --git a/segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperServiceRunner.java b/segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperServiceRunner.java
index dfef433..97e2c99 100644
--- a/segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperServiceRunner.java
+++ b/segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperServiceRunner.java
@@ -44,11 +44,17 @@ public class BookKeeperServiceRunner implements AutoCloseable {
     public static final String PROPERTY_ZK_PORT = "zkPort";
     public static final String PROPERTY_LEDGERS_PATH = "ledgersPath";
     public static final String PROPERTY_START_ZK = "startZk";
+    public static final String PROPERTY_SECURE_BK = "secureBk";
+    public static final String TLS_KEY_STORE_PASSWD = "tlsKeyStorePasswd";
+    public static final String TLS_KEY_STORE = "tlsKeyStore";
+
     private static final InetAddress LOOPBACK_ADDRESS = InetAddress.getLoopbackAddress();
     private final boolean startZk;
     private final int zkPort;
     private final String ledgersPath;
     private final boolean secureBK;
+    private final String tLSKeyStore;
+    private final String tLSKeyStorePasswordPath;
     private final List<Integer> bookiePorts;
     private final List<BookieServer> servers = new ArrayList<>();
     private final AtomicReference<ZooKeeperServiceRunner> zkServer = new AtomicReference<>();
@@ -219,10 +225,8 @@ public class BookKeeperServiceRunner implements AutoCloseable {
         if (secureBK) {
             conf.setTLSProvider("OpenSSL");
             conf.setTLSProviderFactoryClass("org.apache.bookkeeper.tls.TLSContextFactory");
-            conf.setTLSKeyStore("../../../config/bookie.keystore.jks");
-            conf.setTLSKeyStorePasswordPath("../../../config/bookie.keystore.jks.passwd");
-            conf.setTLSTrustStore("../../../config/bookie.truststore.jks");
-            conf.setTLSTrustStore("../../../config/bookie.truststore.jks.passwd");
+            conf.setTLSKeyStore(this.tLSKeyStore);
+            conf.setTLSKeyStorePasswordPath(this.tLSKeyStorePasswordPath);
         }
 
         log.info("Starting Bookie at port " + bkPort);
@@ -264,6 +268,10 @@ public class BookKeeperServiceRunner implements AutoCloseable {
             b.zkPort(Integer.parseInt(System.getProperty(PROPERTY_ZK_PORT)));
             b.ledgersPath(System.getProperty(PROPERTY_LEDGERS_PATH));
             b.startZk(Boolean.parseBoolean(System.getProperty(PROPERTY_START_ZK, "false")));
+            b.tLSKeyStore(System.getProperty(TLS_KEY_STORE, "../../../config/bookie.keystore.jks"));
+            b.tLSKeyStorePasswordPath(System.getProperty(TLS_KEY_STORE_PASSWD, "../../../config/bookie.keystore.jks.passwd"));
+            b.secureBK(Boolean.parseBoolean(System.getProperty(PROPERTY_SECURE_BK, "false")));
+
         } catch (Exception ex) {
             System.out.println(String.format("Invalid or missing arguments (via system properties). Expected: %s(int), " +
                             "%s(int), %s(int), %s(String). (%s).", PROPERTY_BASE_PORT, PROPERTY_BOOKIE_COUNT, PROPERTY_ZK_PORT,
diff --git a/segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogTests.java b/segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogTests.java
index a1eeb41..8abf128 100644
--- a/segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogTests.java
+++ b/segmentstore/storage/impl/src/test/java/io/pravega/segmentstore/storage/impl/bookkeeper/BookKeeperLogTests.java
@@ -95,6 +95,8 @@ public abstract class BookKeeperLogTests extends DurableDataLogTestBase {
                                             .zkPort(BK_PORT.get())
                                             .ledgersPath("/pravega/bookkeeper/ledgers")
                                             .secureBK(isSecure())
+                                            .tLSKeyStore("../../../config/bookie.keystore.jks")
+                                            .tLSKeyStorePasswordPath("../../../config/bookie.keystore.jks.passwd")
                                             .bookiePorts(bookiePorts)
                                             .build();
         runner.startAll();
diff --git a/settings.gradle b/settings.gradle
index a77b8e1..ab60767 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -11,6 +11,7 @@
 rootProject.name = 'pravega'
 
 include 'common',
+        'authplugin',
         'shared',
         'shared:metrics',
         'shared:protocol',
diff --git a/shared/controller-api/src/main/proto/Controller.proto b/shared/controller-api/src/main/proto/Controller.proto
index 0018050..62b515d 100644
--- a/shared/controller-api/src/main/proto/Controller.proto
+++ b/shared/controller-api/src/main/proto/Controller.proto
@@ -36,6 +36,7 @@ service ControllerService {
     rpc checkTransactionState(TxnRequest) returns (TxnState);
     rpc createScope(ScopeInfo) returns (CreateScopeStatus);
     rpc deleteScope(ScopeInfo) returns (DeleteScopeStatus);
+    rpc getDelegationToken(StreamInfo) returns (DelegationToken);
 }
 
 message ServerRequest {
@@ -194,6 +195,7 @@ message SegmentsAtTime {
         int64 offset = 2;
     }
     repeated SegmentLocation segments = 1;
+    string delegationToken = 2;
 }
 
 message TxnId {
@@ -210,6 +212,7 @@ message CreateTxnRequest {
 message CreateTxnResponse {
     TxnId txnId = 1;
     repeated SegmentRange activeSegments = 2;
+    string delegationToken = 3;
 }
 
 message TxnRequest {
@@ -229,6 +232,7 @@ message SuccessorResponse {
         repeated int32 value = 2;
     }
     repeated SegmentEntry segments = 1;
+    string delegationToken = 2;
 }
 
 message ScaleRequest {
@@ -271,6 +275,7 @@ message ScaleStatusResponse {
 
 message SegmentRanges {
     repeated SegmentRange segmentRanges = 1;
+    string delegationToken = 2;
 }
 
 message GetSegmentsRequest {
@@ -281,3 +286,7 @@ message GetSegmentsRequest {
 message SegmentValidityResponse {
     bool response = 1;
 }
+
+message DelegationToken {
+    string delegationToken = 1;
+ }
diff --git a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/ReplyProcessor.java b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/ReplyProcessor.java
index 77b8c38..72c0746 100644
--- a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/ReplyProcessor.java
+++ b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/ReplyProcessor.java
@@ -70,4 +70,6 @@ public interface ReplyProcessor {
     void segmentPolicyUpdated(WireCommands.SegmentPolicyUpdated segmentPolicyUpdated);
     
     void processingFailure(Exception error);
+
+    void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed);
 }
diff --git a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommandType.java b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommandType.java
index 37ef1b8..f4bf809 100644
--- a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommandType.java
+++ b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommandType.java
@@ -87,6 +87,8 @@ public enum WireCommandType {
     SEGMENT_IS_TRUNCATED(56, WireCommands.SegmentIsTruncated::readFrom),
     OPERATION_UNSUPPORTED(57, WireCommands.OperationUnsupported::readFrom),
 
+    AUTH_TOKEN_CHECK_FAILED(60, WireCommands.AuthTokenCheckFailed::readFrom),
+
     KEEP_ALIVE(100, WireCommands.KeepAlive::readFrom);
 
     private final int code;
diff --git a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java
index 28454b7..5dab45f 100644
--- a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java
+++ b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java
@@ -43,8 +43,8 @@ import static io.netty.buffer.Unpooled.wrappedBuffer;
  * Incompatible changes should instead create a new WireCommand object.
  */
 public final class WireCommands {
-    public static final int WIRE_VERSION = 4;
-    public static final int OLDEST_COMPATIBLE_VERSION = 1;
+    public static final int WIRE_VERSION = 5;
+    public static final int OLDEST_COMPATIBLE_VERSION = 5;
     public static final int TYPE_SIZE = 4;
     public static final int TYPE_PLUS_LENGTH_SIZE = 8;
     public static final int MAX_WIRECOMMAND_SIZE = 0x007FFFFF; // 8MB
@@ -390,6 +390,7 @@ public final class WireCommands {
         final long requestId;
         final UUID writerId;
         final String segment;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -402,13 +403,15 @@ public final class WireCommands {
             out.writeLong(writerId.getMostSignificantBits());
             out.writeLong(writerId.getLeastSignificantBits());
             out.writeUTF(segment);
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             UUID uuid = new UUID(in.readLong(), in.readLong());
             String segment = in.readUTF();
-            return new SetupAppend(requestId, uuid, segment);
+            String delegationToken = in.readUTF();
+            return new SetupAppend(requestId, uuid, segment, delegationToken);
         }
     }
 
@@ -620,6 +623,7 @@ public final class WireCommands {
         final String segment;
         final long offset;
         final int suggestedLength;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -631,13 +635,15 @@ public final class WireCommands {
             out.writeUTF(segment);
             out.writeLong(offset);
             out.writeInt(suggestedLength);
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             String segment = in.readUTF();
             long offset = in.readLong();
             int suggestedLength = in.readInt();
-            return new ReadSegment(segment, offset, suggestedLength);
+            String delegationToken = in.readUTF();
+            return new ReadSegment(segment, offset, suggestedLength, delegationToken);
         }
     }
 
@@ -687,6 +693,7 @@ public final class WireCommands {
         final long requestId;
         final String segmentName;
         final UUID attributeId;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -699,13 +706,15 @@ public final class WireCommands {
             out.writeUTF(segmentName);
             out.writeLong(attributeId.getMostSignificantBits());
             out.writeLong(attributeId.getLeastSignificantBits());
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             String segment = in.readUTF();
             UUID attributeId = new UUID(in.readLong(), in.readLong());
-            return new GetSegmentAttribute(requestId, segment, attributeId);
+            String delegationToken = in.readUTF();
+            return new GetSegmentAttribute(requestId, segment, attributeId, delegationToken);
         }
     }
     
@@ -741,6 +750,7 @@ public final class WireCommands {
         final UUID attributeId;
         final long newValue;
         final long expectedValue;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -755,6 +765,7 @@ public final class WireCommands {
             out.writeLong(attributeId.getLeastSignificantBits());
             out.writeLong(newValue);
             out.writeLong(expectedValue);
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
@@ -762,8 +773,9 @@ public final class WireCommands {
             String segment = in.readUTF();
             UUID attributeId = new UUID(in.readLong(), in.readLong());
             long newValue = in.readLong();                
-            long excpecteValue = in.readLong();                
-            return new UpdateSegmentAttribute(requestId, segment, attributeId, newValue, excpecteValue);
+            long excpecteValue = in.readLong();
+            String delegationToken = in.readUTF();
+            return new UpdateSegmentAttribute(requestId, segment, attributeId, newValue, excpecteValue, delegationToken);
         }
     }
     
@@ -796,6 +808,7 @@ public final class WireCommands {
         final WireCommandType type = WireCommandType.GET_STREAM_SEGMENT_INFO;
         final long requestId;
         final String segmentName;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -806,12 +819,14 @@ public final class WireCommands {
         public void writeFields(DataOutput out) throws IOException {
             out.writeLong(requestId);
             out.writeUTF(segmentName);
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             String segment = in.readUTF();
-            return new GetStreamSegmentInfo(requestId, segment);
+            String delegationToken = in.readUTF();
+            return new GetStreamSegmentInfo(requestId, segment, delegationToken);
         }
     }
 
@@ -867,6 +882,7 @@ public final class WireCommands {
         final long requestId;
         final String segment;
         final UUID txid;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -879,13 +895,15 @@ public final class WireCommands {
             out.writeUTF(segment);
             out.writeLong(txid.getMostSignificantBits());
             out.writeLong(txid.getLeastSignificantBits());
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             String segment = in.readUTF();
             UUID txid = new UUID(in.readLong(), in.readLong());
-            return new GetTransactionInfo(requestId, segment, txid);
+            String delegationToken = in.readUTF();
+            return new GetTransactionInfo(requestId, segment, txid, delegationToken);
         }
     }
 
@@ -944,6 +962,7 @@ public final class WireCommands {
         final String segment;
         final byte scaleType;
         final int targetRate;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -956,6 +975,7 @@ public final class WireCommands {
             out.writeUTF(segment);
             out.writeInt(targetRate);
             out.writeByte(scaleType);
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
@@ -963,8 +983,9 @@ public final class WireCommands {
             String segment = in.readUTF();
             int desiredRate = in.readInt();
             byte scaleType = in.readByte();
+            String delegationToken = in.readUTF();
 
-            return new CreateSegment(requestId, segment, scaleType, desiredRate);
+            return new CreateSegment(requestId, segment, scaleType, desiredRate, delegationToken);
         }
     }
 
@@ -1000,6 +1021,7 @@ public final class WireCommands {
         final String segment;
         final byte scaleType;
         final int targetRate;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -1012,6 +1034,7 @@ public final class WireCommands {
             out.writeUTF(segment);
             out.writeInt(targetRate);
             out.writeByte(scaleType);
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
@@ -1019,8 +1042,9 @@ public final class WireCommands {
             String segment = in.readUTF();
             int desiredRate = in.readInt();
             byte scaleType = in.readByte();
+            String delegationToken = in.readUTF();
 
-            return new UpdateSegmentPolicy(requestId, segment, scaleType, desiredRate);
+            return new UpdateSegmentPolicy(requestId, segment, scaleType, desiredRate, delegationToken);
         }
     }
 
@@ -1054,6 +1078,7 @@ public final class WireCommands {
         final long requestId;
         final String segment;
         final UUID txid;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -1066,13 +1091,15 @@ public final class WireCommands {
             out.writeUTF(segment);
             out.writeLong(txid.getMostSignificantBits());
             out.writeLong(txid.getLeastSignificantBits());
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             String segment = in.readUTF();
             UUID txid = new UUID(in.readLong(), in.readLong());
-            return new CreateTransaction(requestId, segment, txid);
+            String delegationToken = in.readUTF();
+            return new CreateTransaction(requestId, segment, txid, delegationToken);
         }
     }
 
@@ -1110,6 +1137,7 @@ public final class WireCommands {
         final long requestId;
         final String segment;
         final UUID txid;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -1122,13 +1150,15 @@ public final class WireCommands {
             out.writeUTF(segment);
             out.writeLong(txid.getMostSignificantBits());
             out.writeLong(txid.getLeastSignificantBits());
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             String segment = in.readUTF();
             UUID txid = new UUID(in.readLong(), in.readLong());
-            return new CommitTransaction(requestId, segment, txid);
+            String delegationToken = in.readUTF();
+            return new CommitTransaction(requestId, segment, txid, delegationToken);
         }
     }
 
@@ -1166,6 +1196,7 @@ public final class WireCommands {
         final long requestId;
         final String segment;
         final UUID txid;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -1178,13 +1209,15 @@ public final class WireCommands {
             out.writeUTF(segment);
             out.writeLong(txid.getMostSignificantBits());
             out.writeLong(txid.getLeastSignificantBits());
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             String segment = in.readUTF();
             UUID txid = new UUID(in.readLong(), in.readLong());
-            return new AbortTransaction(requestId, segment, txid);
+            String delegationToken = in.readUTF();
+            return new AbortTransaction(requestId, segment, txid, delegationToken);
         }
     }
 
@@ -1222,6 +1255,7 @@ public final class WireCommands {
         final WireCommandType type = WireCommandType.SEAL_SEGMENT;
         final long requestId;
         final String segment;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -1232,12 +1266,14 @@ public final class WireCommands {
         public void writeFields(DataOutput out) throws IOException {
             out.writeLong(requestId);
             out.writeUTF(segment);
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             String segment = in.readUTF();
-            return new SealSegment(requestId, segment);
+            String delegationToken = in.readUTF();
+            return new SealSegment(requestId, segment, delegationToken);
         }
     }
 
@@ -1271,6 +1307,7 @@ public final class WireCommands {
         final long requestId;
         final String segment;
         final long truncationOffset;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -1282,13 +1319,15 @@ public final class WireCommands {
             out.writeLong(requestId);
             out.writeUTF(segment);
             out.writeLong(truncationOffset);
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             String segment = in.readUTF();
             long truncationOffset = in.readLong();
-            return new TruncateSegment(requestId, segment, truncationOffset);
+            String delegationToken = in.readUTF();
+            return new TruncateSegment(requestId, segment, truncationOffset, delegationToken);
         }
     }
 
@@ -1321,6 +1360,7 @@ public final class WireCommands {
         final WireCommandType type = WireCommandType.DELETE_SEGMENT;
         final long requestId;
         final String segment;
+        final String delegationToken;
 
         @Override
         public void process(RequestProcessor cp) {
@@ -1331,12 +1371,14 @@ public final class WireCommands {
         public void writeFields(DataOutput out) throws IOException {
             out.writeLong(requestId);
             out.writeUTF(segment);
+            out.writeUTF(delegationToken == null ? "" : delegationToken);
         }
 
         public static WireCommand readFrom(DataInput in, int length) throws IOException {
             long requestId = in.readLong();
             String segment = in.readUTF();
-            return new DeleteSegment(requestId, segment);
+            String delegationToken = in.readUTF();
+            return new DeleteSegment(requestId, segment, delegationToken);
         }
     }
 
@@ -1398,4 +1440,25 @@ public final class WireCommands {
             throw new IllegalStateException("This command is not sent over the wire.");
         }
     }
+
+    @Data
+    public static final class AuthTokenCheckFailed implements Reply, WireCommand {
+        final WireCommandType type = WireCommandType.AUTH_TOKEN_CHECK_FAILED;
+        final long requestId;
+
+        @Override
+        public void process(ReplyProcessor cp) {
+            cp.authTokenCheckFailed(this);
+        }
+
+        @Override
+        public void writeFields(DataOutput out) throws IOException {
+            out.writeLong(requestId);
+        }
+
+        public static WireCommand readFrom(DataInput in, int length) throws IOException {
+            long requestId = in.readLong();
+            return new AuthTokenCheckFailed(requestId);
+        }
+    }
 }
diff --git a/shared/protocol/src/test/java/io/pravega/shared/protocol/netty/AppendEncodeDecodeTest.java b/shared/protocol/src/test/java/io/pravega/shared/protocol/netty/AppendEncodeDecodeTest.java
index 6ff2c25..07b7092 100644
--- a/shared/protocol/src/test/java/io/pravega/shared/protocol/netty/AppendEncodeDecodeTest.java
+++ b/shared/protocol/src/test/java/io/pravega/shared/protocol/netty/AppendEncodeDecodeTest.java
@@ -9,14 +9,21 @@
  */
 package io.pravega.shared.protocol.netty;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
+import io.netty.util.ResourceLeakDetector;
+import io.netty.util.ResourceLeakDetector.Level;
 import io.pravega.shared.protocol.netty.WireCommands.KeepAlive;
 import io.pravega.shared.protocol.netty.WireCommands.SetupAppend;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.UUID;
-
+import lombok.Cleanup;
+import lombok.RequiredArgsConstructor;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -26,16 +33,6 @@ import static io.pravega.shared.protocol.netty.WireCommands.TYPE_PLUS_LENGTH_SIZ
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
-import io.netty.util.ResourceLeakDetector;
-import io.netty.util.ResourceLeakDetector.Level;
-import lombok.Cleanup;
-import lombok.RequiredArgsConstructor;
-
 public class AppendEncodeDecodeTest {
 
     private final int appendBlockSize = 1024;  
@@ -110,7 +107,7 @@ public class AppendEncodeDecodeTest {
         ByteBuf buffer = Unpooled.wrappedBuffer(content);
         Append msg = new Append("segment", writerId, 1, buffer, null);
         CommandEncoder commandEncoder = new CommandEncoder(new FixedBatchSizeTracker(3));
-        SetupAppend setupAppend = new SetupAppend(1, writerId, "segment");
+        SetupAppend setupAppend = new SetupAppend(1, writerId, "segment", "");
         commandEncoder.encode(null, setupAppend, fakeNetwork);
         appendDecoder.processCommand(setupAppend);
         
@@ -263,7 +260,7 @@ public class AppendEncodeDecodeTest {
     }
 
     private ArrayList<Object> setupAppend(String testStream, UUID writerId, ByteBuf fakeNetwork) throws Exception {
-        SetupAppend setupAppend = new SetupAppend(1, writerId, testStream);
+        SetupAppend setupAppend = new SetupAppend(1, writerId, testStream, "");
         encoder.encode(null, setupAppend, fakeNetwork);
         ArrayList<Object> received = new ArrayList<>();
         WireCommand command = CommandDecoder.parseCommand(fakeNetwork);
diff --git a/shared/protocol/src/test/java/io/pravega/shared/protocol/netty/WireCommandsTest.java b/shared/protocol/src/test/java/io/pravega/shared/protocol/netty/WireCommandsTest.java
index 5d82ca2..8374434 100644
--- a/shared/protocol/src/test/java/io/pravega/shared/protocol/netty/WireCommandsTest.java
+++ b/shared/protocol/src/test/java/io/pravega/shared/protocol/netty/WireCommandsTest.java
@@ -18,10 +18,12 @@ import java.io.DataOutputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.UUID;
+import java.util.concurrent.atomic.AtomicReference;
 import lombok.Data;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public class WireCommandsTest {
 
@@ -46,7 +48,7 @@ public class WireCommandsTest {
 
     @Test
     public void testSetupAppend() throws IOException {
-        testCommand(new WireCommands.SetupAppend(l, uuid, testString1));
+        testCommand(new WireCommands.SetupAppend(l, uuid, testString1, ""));
     }
 
     @Test
@@ -69,6 +71,31 @@ public class WireCommandsTest {
         testCommand(new WireCommands.ConditionalAppend(uuid, l, l, buf));
     }
 
+    @Test
+    public void testAuthTokenCheckFalied() throws IOException {
+        testCommand(new WireCommands.AuthTokenCheckFailed(l));
+        AtomicReference<Boolean> authTokenCheckFailedCalled = new AtomicReference<>(false);
+        ReplyProcessor rp = new FailingReplyProcessor() {
+            @Override
+            public void connectionDropped() {
+
+            }
+
+            @Override
+            public void processingFailure(Exception error) {
+
+            }
+
+            @Override
+            public void authTokenCheckFailed(WireCommands.AuthTokenCheckFailed authTokenCheckFailed) {
+                authTokenCheckFailedCalled.set(true);
+            }
+        };
+
+        new WireCommands.AuthTokenCheckFailed(0).process(rp);
+        assertTrue("Process should call the corresponding API", authTokenCheckFailedCalled.get());
+    }
+
     /*
      * Test that we are able to decode the message of a previous version.
      * Specifically here, we create a data structure that corresponds to the
@@ -109,7 +136,7 @@ public class WireCommandsTest {
 
     @Test
     public void testReadSegment() throws IOException {
-        testCommand(new WireCommands.ReadSegment(testString1, l, i));
+        testCommand(new WireCommands.ReadSegment(testString1, l, i, ""));
     }
 
     @Test
@@ -119,7 +146,7 @@ public class WireCommandsTest {
     
     @Test
     public void testUpdateSegmentAttribute() throws IOException {
-        testCommand(new WireCommands.UpdateSegmentAttribute(l, testString1, uuid, l, l));
+        testCommand(new WireCommands.UpdateSegmentAttribute(l, testString1, uuid, l, l, ""));
     }
     
     @Test
@@ -130,7 +157,7 @@ public class WireCommandsTest {
 
     @Test
     public void testGetSegmentAttribute() throws IOException {
-        testCommand(new WireCommands.GetSegmentAttribute(l, testString1, uuid));
+        testCommand(new WireCommands.GetSegmentAttribute(l, testString1, uuid, ""));
     }
     
     @Test
@@ -140,7 +167,7 @@ public class WireCommandsTest {
     
     @Test
     public void testGetStreamSegmentInfo() throws IOException {
-        testCommand(new WireCommands.GetStreamSegmentInfo(l, testString1));
+        testCommand(new WireCommands.GetStreamSegmentInfo(l, testString1, ""));
     }
 
     @Test
@@ -150,7 +177,7 @@ public class WireCommandsTest {
 
     @Test
     public void testGetTransactionInfo() throws IOException {
-        testCommand(new WireCommands.GetTransactionInfo(l - 1, testString1, uuid));
+        testCommand(new WireCommands.GetTransactionInfo(l - 1, testString1, uuid, ""));
     }
 
     @Test
@@ -160,7 +187,7 @@ public class WireCommandsTest {
 
     @Test
     public void testCreateSegment() throws IOException {
-        testCommand(new WireCommands.CreateSegment(l, testString1, b, i));
+        testCommand(new WireCommands.CreateSegment(l, testString1, b, i, ""));
     }
 
     @Test
@@ -170,7 +197,7 @@ public class WireCommandsTest {
 
     @Test
     public void testCreateTransaction() throws IOException {
-        testCommand(new WireCommands.CreateTransaction(l, testString1, uuid));
+        testCommand(new WireCommands.CreateTransaction(l, testString1, uuid, ""));
     }
 
     @Test
@@ -180,7 +207,7 @@ public class WireCommandsTest {
 
     @Test
     public void testCommitTransaction() throws IOException {
-        testCommand(new WireCommands.CommitTransaction(l, testString1, uuid));
+        testCommand(new WireCommands.CommitTransaction(l, testString1, uuid, ""));
     }
 
     @Test
@@ -190,7 +217,7 @@ public class WireCommandsTest {
 
     @Test
     public void testAbortTransaction() throws IOException {
-        testCommand(new WireCommands.AbortTransaction(l, testString1, uuid));
+        testCommand(new WireCommands.AbortTransaction(l, testString1, uuid, ""));
     }
 
     @Test
@@ -200,7 +227,7 @@ public class WireCommandsTest {
 
     @Test
     public void testSealSegment() throws IOException {
-        testCommand(new WireCommands.SealSegment(l, testString1));
+        testCommand(new WireCommands.SealSegment(l, testString1, ""));
     }
 
     @Test
@@ -210,7 +237,7 @@ public class WireCommandsTest {
 
     @Test
     public void testTruncateSegment() throws IOException {
-        testCommand(new WireCommands.TruncateSegment(l, testString1, l + 1));
+        testCommand(new WireCommands.TruncateSegment(l, testString1, l + 1, ""));
     }
 
     @Test
@@ -225,7 +252,7 @@ public class WireCommandsTest {
 
     @Test
     public void testDeleteSegment() throws IOException {
-        testCommand(new WireCommands.DeleteSegment(l, testString1));
+        testCommand(new WireCommands.DeleteSegment(l, testString1, ""));
     }
 
     @Test
@@ -235,7 +262,7 @@ public class WireCommandsTest {
 
     @Test
     public void testUpdateSegmentPolicy() throws IOException {
-        testCommand(new WireCommands.UpdateSegmentPolicy(l, testString1, b, i));
+        testCommand(new WireCommands.UpdateSegmentPolicy(l, testString1, b, i, ""));
     }
 
     @Test
diff --git a/standalone/src/main/java/io/pravega/local/InProcPravegaCluster.java b/standalone/src/main/java/io/pravega/local/InProcPravegaCluster.java
index fe825eb..3f6151b 100644
--- a/standalone/src/main/java/io/pravega/local/InProcPravegaCluster.java
+++ b/standalone/src/main/java/io/pravega/local/InProcPravegaCluster.java
@@ -60,6 +60,10 @@ public class InProcPravegaCluster implements AutoCloseable {
     private final String clusterName = "singlenode-" + UUID.randomUUID();
     private boolean enableMetrics = false;
 
+    /*Enabling this will configure security for the singlenode with hardcoded cert files and creds.*/
+    private boolean enableAuth = false;
+    private boolean enableTls = false;
+
     /*Controller related variables*/
     private boolean isInProcController;
     private int controllerCount;
@@ -103,7 +107,8 @@ public class InProcPravegaCluster implements AutoCloseable {
                                 boolean isInProcHDFS,
                                 boolean isInProcController, int controllerCount, String controllerURI,
                                 boolean isInProcSegmentStore, int segmentStoreCount, int containerCount,
-                                boolean startRestServer, int restServerPort, boolean enableMetrics) {
+                                boolean startRestServer, int restServerPort, boolean enableMetrics, boolean enableAuth,
+                                boolean enableTls) {
 
         //Check for valid combinations of flags
         //For ZK
@@ -136,6 +141,8 @@ public class InProcPravegaCluster implements AutoCloseable {
         this.startRestServer = startRestServer;
         this.restServerPort = restServerPort;
         this.enableMetrics = enableMetrics;
+        this.enableAuth = enableAuth;
+        this.enableTls = enableTls;
     }
 
     @Synchronized
@@ -241,6 +248,9 @@ public class InProcPravegaCluster implements AutoCloseable {
                         .with(ServiceConfig.ZK_URL, "localhost:" + zkPort)
                         .with(ServiceConfig.LISTENING_PORT, this.segmentStorePorts[segmentStoreId])
                         .with(ServiceConfig.CLUSTER_NAME, this.clusterName)
+                        .with(ServiceConfig.ENABLE_TLS, this.enableTls)
+                        .with(ServiceConfig.KEY_FILE, "../config/key.pem")
+                        .with(ServiceConfig.CERT_FILE, "../config/cert.pem")
                         .with(ServiceConfig.DATALOG_IMPLEMENTATION, isInMemStorage ?
                                 ServiceConfig.DataLogType.INMEMORY :
                                 ServiceConfig.DataLogType.BOOKKEEPER)
@@ -255,7 +265,13 @@ public class InProcPravegaCluster implements AutoCloseable {
                         .with(ReadIndexConfig.CACHE_POLICY_MAX_TIME, 60 * 1000)
                         .with(ReadIndexConfig.CACHE_POLICY_MAX_SIZE, 128 * 1024 * 1024L))
                 .include(AutoScalerConfig.builder()
-                        .with(AutoScalerConfig.CONTROLLER_URI, "tcp://localhost:" + controllerPorts[0]))
+                        .with(AutoScalerConfig.CONTROLLER_URI, "tcp://localhost:" + controllerPorts[0])
+                                         .with(AutoScalerConfig.AUTH_USERNAME, "admin")
+                                         .with(AutoScalerConfig.AUTH_PASSWORD, "1111_aaaa")
+                                         .with(AutoScalerConfig.TOKEN_SIGNING_KEY, "secret")
+                                         .with(AutoScalerConfig.AUTH_ENABLED, this.enableAuth)
+                                         .with(AutoScalerConfig.TLS_ENABLED, this.enableTls)
+                                         .with(AutoScalerConfig.TLS_CERT_FILE, "../config/cert.pem"))
                 .include(MetricsConfig.builder()
                         .with(MetricsConfig.ENABLE_STATISTICS, enableMetrics));
 
@@ -269,8 +285,8 @@ public class InProcPravegaCluster implements AutoCloseable {
         for (int i = 0; i < this.controllerCount; i++) {
             controllerServers[i] = startLocalController(i);
         }
-        controllerURI = "tcp://localhost:" + controllerPorts[0];
-        for (int i = 0; i < this.controllerCount; i++) {
+        controllerURI = (this.enableTls ? "tls" : "tcp") + "://localhost:" + controllerPorts[0];
+        for (int i = 1; i < this.controllerCount; i++) {
             controllerURI += ",localhost:" + controllerPorts[i];
         }
 
@@ -301,10 +317,18 @@ public class InProcPravegaCluster implements AutoCloseable {
 
         ControllerEventProcessorConfig eventProcessorConfig = ControllerEventProcessorConfigImpl.withDefault();
 
-        GRPCServerConfig grpcServerConfig = GRPCServerConfigImpl.builder()
+        GRPCServerConfig grpcServerConfig = GRPCServerConfigImpl
+                .builder()
                 .port(this.controllerPorts[controllerId])
                 .publishedRPCHost("localhost")
                 .publishedRPCPort(this.controllerPorts[controllerId])
+                .authorizationEnabled(this.enableAuth)
+                .tlsEnabled(this.enableTls)
+                .tlsTrustStore("../config/cert.pem")
+                .tlsCertFile("../config/cert.pem")
+                .tlsKeyFile("../config/key.pem")
+                .userPasswordFile("../config/passwd")
+                .tokenSigningKey("secret")
                 .build();
 
         RESTServerConfig restServerConfig = RESTServerConfigImpl.builder()
diff --git a/standalone/src/main/java/io/pravega/local/LocalPravegaEmulator.java b/standalone/src/main/java/io/pravega/local/LocalPravegaEmulator.java
index 7495a56..ad12166 100644
--- a/standalone/src/main/java/io/pravega/local/LocalPravegaEmulator.java
+++ b/standalone/src/main/java/io/pravega/local/LocalPravegaEmulator.java
@@ -22,7 +22,7 @@ public class LocalPravegaEmulator implements AutoCloseable {
     private final InProcPravegaCluster inProcPravegaCluster;
 
     @Builder
-    private LocalPravegaEmulator(int zkPort, int controllerPort, int segmentStorePort, int restServerPort) {
+    private LocalPravegaEmulator(int zkPort, int controllerPort, int segmentStorePort, int restServerPort, boolean enableAuth, boolean enableTls) {
         inProcPravegaCluster = InProcPravegaCluster
                 .builder()
                 .isInProcZK(true)
@@ -37,6 +37,8 @@ public class LocalPravegaEmulator implements AutoCloseable {
                 .startRestServer(true)
                 .restServerPort(restServerPort)
                 .enableMetrics(false)
+                .enableAuth(enableAuth)
+                .enableTls(enableTls)
                 .build();
         inProcPravegaCluster.setControllerPorts(new int[] {controllerPort});
         inProcPravegaCluster.setSegmentStorePorts(new int[] {segmentStorePort});
@@ -44,7 +46,6 @@ public class LocalPravegaEmulator implements AutoCloseable {
 
     public static void main(String[] args) {
         try {
-
             ServiceBuilderConfig config = ServiceBuilderConfig
                     .builder()
                     .include(System.getProperties())
@@ -56,6 +57,8 @@ public class LocalPravegaEmulator implements AutoCloseable {
                     .segmentStorePort(conf.getSegmentStorePort())
                     .zkPort(conf.getZkPort())
                     .restServerPort(conf.getRestServerPort())
+                    .enableAuth(true)
+                    .enableTls(true)
                     .build();
 
             Runtime.getRuntime().addShutdownHook(new Thread() {
diff --git a/standalone/src/test/java/io/pravega/local/InProcPravegaClusterTest.java b/standalone/src/test/java/io/pravega/local/InProcPravegaClusterTest.java
index b6dcc7d..9944781 100644
--- a/standalone/src/test/java/io/pravega/local/InProcPravegaClusterTest.java
+++ b/standalone/src/test/java/io/pravega/local/InProcPravegaClusterTest.java
@@ -9,9 +9,15 @@
  */
 package io.pravega.local;
 
+import io.pravega.client.ClientConfig;
+import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.StreamManager;
+import io.pravega.client.stream.EventStreamWriter;
+import io.pravega.client.stream.EventWriterConfig;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.impl.DefaultCredentials;
+import io.pravega.client.stream.impl.JavaSerializer;
 import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
 import java.net.URI;
@@ -27,6 +33,8 @@ import org.junit.Test;
  */
 @Slf4j
 public class InProcPravegaClusterTest {
+    boolean authEnabled = false;
+    boolean tlsEnabled = false;
     private LocalPravegaEmulator localPravega;
 
     @Before
@@ -42,6 +50,8 @@ public class InProcPravegaClusterTest {
                                            .segmentStorePort(TestUtils.getAvailableListenPort())
                                            .zkPort(TestUtils.getAvailableListenPort())
                                            .restServerPort(TestUtils.getAvailableListenPort())
+                                           .enableAuth(authEnabled)
+                                           .enableTls(tlsEnabled)
                                            .build();
         localPravega.start();
     }
@@ -59,10 +69,14 @@ public class InProcPravegaClusterTest {
         String streamName = "Stream";
         int numSegments = 10;
 
+        ClientConfig clientConfig = ClientConfig.builder()
+                                                .controllerURI(URI.create(localPravega.getInProcPravegaCluster().getControllerURI()))
+                                                .credentials(new DefaultCredentials("1111_aaaa", "admin"))
+                                                .trustStore("../config/cert.pem")
+                                                .validateHostName(false)
+                                                .build();
         @Cleanup
-        StreamManager streamManager = StreamManager.create(URI.create(
-                localPravega.getInProcPravegaCluster().getControllerURI()
-        ));
+        StreamManager streamManager = StreamManager.create(clientConfig);
 
         streamManager.createScope(scope);
         Assert.assertTrue("Stream creation is not successful ",
@@ -71,8 +85,16 @@ public class InProcPravegaClusterTest {
                                    .streamName(streamName)
                                    .scalingPolicy(ScalingPolicy.fixed(numSegments))
                                    .build()));
-
         log.info("Created stream: " + streamName);
+
+        ClientFactory clientFactory = ClientFactory.withScope(scope, clientConfig);
+        EventStreamWriter<String> writer = clientFactory.createEventWriter(streamName,
+                new JavaSerializer<String>(),
+                EventWriterConfig.builder().build());
+        log.info("Created writer for stream: " + streamName);
+
+        writer.writeEvent("hello").get();
+        log.info("Wrote data to the stream");
     }
 
     @After
diff --git a/standalone/src/test/java/io/pravega/local/PartialSecurePravegaClusterTest.java b/standalone/src/test/java/io/pravega/local/PartialSecurePravegaClusterTest.java
new file mode 100644
index 0000000..bdaa6b6
--- /dev/null
+++ b/standalone/src/test/java/io/pravega/local/PartialSecurePravegaClusterTest.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.local;
+
+import org.junit.After;
+import org.junit.Before;
+
+/**
+ * Unit tests for secure standalone cluster.
+ */
+public class PartialSecurePravegaClusterTest extends InProcPravegaClusterTest {
+    @Before
+    @Override
+    public void setUp() throws Exception {
+        this.authEnabled = true;
+        this.tlsEnabled = false;
+        super.setUp();
+    }
+
+    @After
+    @Override
+    public void tearDown() throws Exception {
+        super.tearDown();
+    }
+}
\ No newline at end of file
diff --git a/standalone/src/test/java/io/pravega/local/SecurePravegaClusterTest.java b/standalone/src/test/java/io/pravega/local/SecurePravegaClusterTest.java
new file mode 100644
index 0000000..21d1b34
--- /dev/null
+++ b/standalone/src/test/java/io/pravega/local/SecurePravegaClusterTest.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright (c) 2017 Dell Inc., or its subsidiaries. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ */
+package io.pravega.local;
+
+import org.junit.After;
+import org.junit.Before;
+
+/**
+ * Unit tests for secure standalone cluster.
+ */
+public class SecurePravegaClusterTest extends InProcPravegaClusterTest {
+    @Before
+    @Override
+    public void setUp() throws Exception {
+        this.authEnabled = true;
+        this.tlsEnabled = true;
+        super.setUp();
+    }
+
+    @After
+    @Override
+    public void tearDown() throws Exception {
+        super.tearDown();
+    }
+}
diff --git a/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleDownTest.java b/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleDownTest.java
index a100f77..71e4b3e 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleDownTest.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleDownTest.java
@@ -9,10 +9,17 @@
  */
 package io.pravega.test.integration.demo;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
-import io.pravega.controller.util.Config;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.client.stream.Stream;
+import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.impl.ClientFactoryImpl;
+import io.pravega.client.stream.impl.Controller;
+import io.pravega.client.stream.impl.StreamImpl;
 import io.pravega.common.util.Retry;
+import io.pravega.controller.util.Config;
 import io.pravega.segmentstore.contracts.StreamSegmentStore;
 import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
 import io.pravega.segmentstore.server.host.stat.AutoScalerConfig;
@@ -21,22 +28,15 @@ import io.pravega.segmentstore.server.host.stat.SegmentStatsRecorder;
 import io.pravega.segmentstore.server.store.ServiceBuilder;
 import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.shared.NameUtils;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.Stream;
-import io.pravega.client.stream.StreamConfiguration;
-import io.pravega.client.stream.impl.ClientFactoryImpl;
-import io.pravega.client.stream.impl.Controller;
-import io.pravega.client.stream.impl.StreamImpl;
 import io.pravega.test.common.TestingServerStarter;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.curator.test.TestingServer;
-
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.curator.test.TestingServer;
 
 @Slf4j
 public class EndToEndAutoScaleDownTest {
@@ -55,7 +55,7 @@ public class EndToEndAutoScaleDownTest {
             Controller controller = controllerWrapper.getController();
 
             controllerWrapper.getControllerService().createScope(NameUtils.INTERNAL_SCOPE_NAME).get();
-            ClientFactory internalCF = new ClientFactoryImpl(NameUtils.INTERNAL_SCOPE_NAME, controller, new ConnectionFactoryImpl(false));
+            ClientFactory internalCF = new ClientFactoryImpl(NameUtils.INTERNAL_SCOPE_NAME, controller, new ConnectionFactoryImpl(ClientConfig.builder().build()));
 
             ServiceBuilder serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());
             serviceBuilder.initialize();
@@ -71,7 +71,7 @@ public class EndToEndAutoScaleDownTest {
 
             @Cleanup
             PravegaConnectionListener server = new PravegaConnectionListener(false, "localhost", 12345, store,
-                    statsRecorder);
+                    statsRecorder, null, null, null);
             server.startListening();
             controllerWrapper.awaitRunning();
             controllerWrapper.getControllerService().createScope("test").get();
diff --git a/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleUpTest.java b/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleUpTest.java
index 7d40532..91d26e9 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleUpTest.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleUpTest.java
@@ -9,10 +9,19 @@
  */
 package io.pravega.test.integration.demo;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
-import io.pravega.controller.util.Config;
+import io.pravega.client.stream.EventStreamWriter;
+import io.pravega.client.stream.EventWriterConfig;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.impl.ClientFactoryImpl;
+import io.pravega.client.stream.impl.Controller;
+import io.pravega.client.stream.impl.JavaSerializer;
+import io.pravega.client.stream.mock.MockClientFactory;
 import io.pravega.common.util.Retry;
+import io.pravega.controller.util.Config;
 import io.pravega.segmentstore.contracts.StreamSegmentStore;
 import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
 import io.pravega.segmentstore.server.host.stat.AutoScalerConfig;
@@ -21,23 +30,14 @@ import io.pravega.segmentstore.server.host.stat.SegmentStatsRecorder;
 import io.pravega.segmentstore.server.store.ServiceBuilder;
 import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.shared.NameUtils;
-import io.pravega.client.stream.EventStreamWriter;
-import io.pravega.client.stream.EventWriterConfig;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.StreamConfiguration;
-import io.pravega.client.stream.impl.ClientFactoryImpl;
-import io.pravega.client.stream.impl.Controller;
-import io.pravega.client.stream.impl.JavaSerializer;
-import io.pravega.client.stream.mock.MockClientFactory;
 import io.pravega.test.common.TestingServerStarter;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.curator.test.TestingServer;
-
 import java.time.Duration;
 import java.util.Arrays;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executors;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.curator.test.TestingServer;
 
 @Slf4j
 public class EndToEndAutoScaleUpTest {
@@ -55,7 +55,7 @@ public class EndToEndAutoScaleUpTest {
             ControllerWrapper controllerWrapper = new ControllerWrapper(zkTestServer.getConnectString(), port, false);
             Controller controller = controllerWrapper.getController();
 
-            ClientFactory internalCF = new ClientFactoryImpl(NameUtils.INTERNAL_SCOPE_NAME, controller, new ConnectionFactoryImpl(false));
+            ClientFactory internalCF = new ClientFactoryImpl(NameUtils.INTERNAL_SCOPE_NAME, controller, new ConnectionFactoryImpl(ClientConfig.builder().build()));
 
             ServiceBuilder serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());
             serviceBuilder.initialize();
@@ -69,7 +69,7 @@ public class EndToEndAutoScaleUpTest {
 
             @Cleanup
             PravegaConnectionListener server = new PravegaConnectionListener(false, "localhost", 12345, store,
-                    statsRecorder);
+                    statsRecorder, null, null, null);
             server.startListening();
 
             controllerWrapper.awaitRunning();
diff --git a/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleUpWithTxnTest.java b/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleUpWithTxnTest.java
index 5d566a6..3b1df73 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleUpWithTxnTest.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/demo/EndToEndAutoScaleUpWithTxnTest.java
@@ -9,18 +9,28 @@
  */
 package io.pravega.test.integration.demo;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
 import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.stream.EventStreamReader;
+import io.pravega.client.stream.EventStreamWriter;
+import io.pravega.client.stream.EventWriterConfig;
 import io.pravega.client.stream.ReaderConfig;
 import io.pravega.client.stream.ReaderGroupConfig;
+import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.Stream;
+import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.Transaction;
+import io.pravega.client.stream.impl.ClientFactoryImpl;
+import io.pravega.client.stream.impl.Controller;
+import io.pravega.client.stream.impl.JavaSerializer;
 import io.pravega.client.stream.impl.StreamImpl;
-import io.pravega.controller.util.Config;
+import io.pravega.client.stream.mock.MockClientFactory;
 import io.pravega.common.util.Retry;
+import io.pravega.controller.util.Config;
 import io.pravega.segmentstore.contracts.StreamSegmentStore;
 import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
 import io.pravega.segmentstore.server.host.stat.AutoScalerConfig;
@@ -29,20 +39,7 @@ import io.pravega.segmentstore.server.host.stat.SegmentStatsRecorder;
 import io.pravega.segmentstore.server.store.ServiceBuilder;
 import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.shared.NameUtils;
-import io.pravega.client.stream.EventStreamWriter;
-import io.pravega.client.stream.EventWriterConfig;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.StreamConfiguration;
-import io.pravega.client.stream.Transaction;
-import io.pravega.client.stream.impl.ClientFactoryImpl;
-import io.pravega.client.stream.impl.Controller;
-import io.pravega.client.stream.impl.JavaSerializer;
-import io.pravega.client.stream.mock.MockClientFactory;
 import io.pravega.test.common.TestingServerStarter;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.curator.test.TestingServer;
-
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
@@ -50,6 +47,9 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.curator.test.TestingServer;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
@@ -70,7 +70,7 @@ public class EndToEndAutoScaleUpWithTxnTest {
             controllerWrapper.getControllerService().createScope(NameUtils.INTERNAL_SCOPE_NAME).get();
 
             @Cleanup
-            ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
+            ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
             @Cleanup
             ClientFactory internalCF = new ClientFactoryImpl(NameUtils.INTERNAL_SCOPE_NAME, controller, connectionFactory);
 
@@ -86,7 +86,7 @@ public class EndToEndAutoScaleUpWithTxnTest {
 
             @Cleanup
             PravegaConnectionListener server = new PravegaConnectionListener(false, "localhost", 12345, store,
-                    statsRecorder);
+                    statsRecorder, null, null, null);
             server.startListening();
 
             controllerWrapper.awaitRunning();
diff --git a/test/integration/src/main/java/io/pravega/test/integration/selftest/SelfTestRunner.java b/test/integration/src/main/java/io/pravega/test/integration/selftest/SelfTestRunner.java
index 783b6db..78652e5 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/selftest/SelfTestRunner.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/selftest/SelfTestRunner.java
@@ -129,7 +129,9 @@ public class SelfTestRunner {
         return ServiceBuilderConfig
                 .builder()
                 .include(ServiceConfig.builder()
-                                      .with(ServiceConfig.THREAD_POOL_SIZE, 30))
+                                      .with(ServiceConfig.THREAD_POOL_SIZE, 30)
+                                      .with(ServiceConfig.CERT_FILE, "../config/cert.pem")
+                                      .with(ServiceConfig.KEY_FILE, "../config/key.pem"))
                 .include(DurableLogConfig.builder()
                                          .with(DurableLogConfig.CHECKPOINT_COMMIT_COUNT, 100)
                                          .with(DurableLogConfig.CHECKPOINT_MIN_COMMIT_COUNT, 100)
diff --git a/test/integration/src/main/java/io/pravega/test/integration/selftest/TestConfig.java b/test/integration/src/main/java/io/pravega/test/integration/selftest/TestConfig.java
index f3d91d8..37f198b 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/selftest/TestConfig.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/selftest/TestConfig.java
@@ -55,6 +55,7 @@ public class TestConfig {
     private static final Property<Integer> ZK_PORT = Property.named("zkPort", 9000);
     private static final Property<Integer> BK_BASE_PORT = Property.named("bkBasePort", 9100);
     private static final Property<Integer> SEGMENT_STORE_BASE_PORT = Property.named("segmentStorePort", 9300);
+    private static final Property<Boolean> ENABLE_SECURITY = Property.named("enableSecurity", false);
     private static final String TEST_OUTPUT_PATH = "/tmp/pravega";
     private static final String LOG_PATH_FORMAT = TEST_OUTPUT_PATH + "/selftest.%s.log";
     private static final String METRICS_PATH_FORMAT = TEST_OUTPUT_PATH + "/selftest.metrics.%s";
@@ -113,6 +114,8 @@ public class TestConfig {
     @Getter
     private final boolean pauseBeforeExit;
     @Getter
+    private final boolean enableSecurity;
+    @Getter
     private final String testId = Long.toHexString(System.currentTimeMillis());
 
     //endregion
@@ -158,6 +161,7 @@ public class TestConfig {
         this.readsEnabled = properties.getBoolean(READS_ENABLED);
         this.metricsEnabled = properties.getBoolean(METRICS_ENABLED);
         this.pauseBeforeExit = properties.getBoolean(PAUSE_BEFORE_EXIT);
+        this.enableSecurity = properties.getBoolean(ENABLE_SECURITY);
         checkOverlappingPorts();
     }
 
diff --git a/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/ClientReader.java b/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/ClientReader.java
index 523c158..5bf0b20 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/ClientReader.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/ClientReader.java
@@ -10,6 +10,7 @@
 package io.pravega.test.integration.selftest.adapters;
 
 import com.google.common.base.Preconditions;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.segment.impl.NoSuchEventException;
@@ -20,6 +21,7 @@ import io.pravega.client.stream.ReaderConfig;
 import io.pravega.client.stream.ReaderGroupConfig;
 import io.pravega.client.stream.ReinitializationRequiredException;
 import io.pravega.client.stream.Sequence;
+import io.pravega.client.stream.impl.DefaultCredentials;
 import io.pravega.common.Exceptions;
 import io.pravega.common.concurrent.CancellationToken;
 import io.pravega.common.concurrent.Futures;
@@ -150,7 +152,11 @@ class ClientReader implements StoreReader, AutoCloseable {
         StreamReader(String streamName) {
             this.readerGroup = UUID.randomUUID().toString().replace("-", "");
             this.readerId = UUID.randomUUID().toString().replace("-", "");
-            try (ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(ClientAdapterBase.SCOPE, ClientReader.this.controllerUri)) {
+            try (ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(ClientAdapterBase.SCOPE,
+                    ClientConfig.builder().controllerURI(ClientReader.this.controllerUri)
+                            .trustStore("../../config/cert.pem")
+                            .credentials(new DefaultCredentials("1111_aaaa", "admin"))
+                            .validateHostName(false).build())) {
                 readerGroupManager.createReaderGroup(this.readerGroup, READER_GROUP_CONFIG, Collections.singleton(streamName));
             }
 
diff --git a/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/ExternalAdapter.java b/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/ExternalAdapter.java
index f1b6fae..ebf513a 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/ExternalAdapter.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/ExternalAdapter.java
@@ -9,9 +9,11 @@
  */
 package io.pravega.test.integration.selftest.adapters;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.StreamManager;
 import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.impl.DefaultCredentials;
 import io.pravega.common.Exceptions;
 import io.pravega.common.util.Retry;
 import io.pravega.test.integration.selftest.TestConfig;
@@ -57,14 +59,23 @@ class ExternalAdapter extends ClientAdapterBase {
             URI controllerUri = new URI(getControllerUrl());
 
             // Create Stream Manager, Scope and Client Factory.
-            this.streamManager.set(StreamManager.create(controllerUri));
+            this.streamManager.set(StreamManager.create(ClientConfig.builder()
+                            .trustStore("../../config/cert.pem")
+                            .credentials(new DefaultCredentials("1111_aaaa", "admin"))
+                    .validateHostName(false)
+                    .controllerURI(controllerUri)
+                    .build()));
             Retry.withExpBackoff(500, 2, 10)
                  .retryWhen(ex -> true)
                  .throwingOn(Exception.class)
                  .run(() -> this.streamManager.get().createScope(SCOPE));
 
             // Create Client Factory.
-            this.clientFactory.set(ClientFactory.withScope(SCOPE, controllerUri));
+            this.clientFactory.set(ClientFactory.withScope(SCOPE, ClientConfig.builder()
+                    .trustStore("../../config/cert.pem")
+                    .credentials(new DefaultCredentials("1111_aaaa", "admin"))
+                    .validateHostName(false)
+                    .controllerURI(controllerUri).build()));
 
             // Create, Seal and Delete a dummy segment - this verifies that the client is properly setup and that all the
             // components are running properly.
@@ -124,7 +135,7 @@ class ExternalAdapter extends ClientAdapterBase {
 
     @Override
     protected String getControllerUrl() {
-        return String.format("tcp://%s:%d", this.testConfig.getControllerHost(), this.testConfig.getControllerPort(0));
+        return String.format((this.testConfig.isEnableSecurity() ? "ssl" : "tcp") + "://%s:%d", this.testConfig.getControllerHost(), this.testConfig.getControllerPort(0));
     }
 
     //endregion
diff --git a/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/OutOfProcessAdapter.java b/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/OutOfProcessAdapter.java
index 1b3f02b..6600d1b 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/OutOfProcessAdapter.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/OutOfProcessAdapter.java
@@ -157,6 +157,9 @@ class OutOfProcessAdapter extends ExternalAdapter {
         this.bookieProcess.set(ProcessStarter
                 .forClass(BookKeeperServiceRunner.class)
                 .sysProp(BookKeeperServiceRunner.PROPERTY_BASE_PORT, this.testConfig.getBkPort(0))
+                .sysProp(BookKeeperServiceRunner.PROPERTY_SECURE_BK, this.testConfig.isEnableSecurity())
+                .sysProp(BookKeeperServiceRunner.TLS_KEY_STORE, "../../config/bookie.keystore.jks")
+                .sysProp(BookKeeperServiceRunner.TLS_KEY_STORE_PASSWD, "../../config/bookie.keystore.jks.passwd")
                 .sysProp(BookKeeperServiceRunner.PROPERTY_BOOKIE_COUNT, bookieCount)
                 .sysProp(BookKeeperServiceRunner.PROPERTY_ZK_PORT, this.testConfig.getZkPort())
                 .sysProp(BookKeeperServiceRunner.PROPERTY_LEDGERS_PATH, TestConfig.BK_LEDGER_PATH)
@@ -183,6 +186,13 @@ class OutOfProcessAdapter extends ExternalAdapter {
                 .sysProp("CONTAINER_COUNT", this.testConfig.getContainerCount())
                 .sysProp("ZK_URL", getZkUrl())
                 .sysProp("CONTROLLER_SERVER_PORT", port)
+                .sysProp("AUTHORIZATION_ENABLED", this.testConfig.isEnableSecurity())
+                .sysProp("USER_PASSWORD_FILE", "../../config/passwd")
+                .sysProp("TLS_ENABLED", this.testConfig.isEnableSecurity())
+                .sysProp("TLS_CERT_FILE", "../../config/cert.pem")
+                .sysProp("TLS_TRUST_STORE", "../../config/cert.pem")
+                .sysProp("TLS_KEY_FILE", "../../config/key.pem")
+                .sysProp("TOKEN_SIGNING_KEY", "secret")
                 .sysProp("REST_SERVER_IP", TestConfig.LOCALHOST)
                 .sysProp("REST_SERVER_PORT", restPort)
                 .sysProp("CONTROLLER_RPC_PUBLISHED_HOST", TestConfig.LOCALHOST)
@@ -208,11 +218,22 @@ class OutOfProcessAdapter extends ExternalAdapter {
                 .forClass(ServiceStarter.class)
                 .sysProp(ServiceBuilderConfig.CONFIG_FILE_PROPERTY_NAME, getSegmentStoreConfigFilePath())
                 .sysProp(configProperty(ServiceConfig.COMPONENT_CODE, ServiceConfig.ZK_URL), getZkUrl())
+                .sysProp(configProperty(ServiceConfig.COMPONENT_CODE, ServiceConfig.ENABLE_TLS), this.testConfig.isEnableSecurity())
+                .sysProp(configProperty(ServiceConfig.COMPONENT_CODE, ServiceConfig.KEY_FILE), "../../config/key.pem")
+                .sysProp(configProperty(ServiceConfig.COMPONENT_CODE, ServiceConfig.CERT_FILE), "../../config/cert.pem")
                 .sysProp(configProperty(BookKeeperConfig.COMPONENT_CODE, BookKeeperConfig.ZK_ADDRESS), getZkUrl())
                 .sysProp(configProperty(ServiceConfig.COMPONENT_CODE, ServiceConfig.LISTENING_PORT), port)
                 .sysProp(configProperty(ServiceConfig.COMPONENT_CODE, ServiceConfig.STORAGE_IMPLEMENTATION), ServiceConfig.StorageType.FILESYSTEM)
                 .sysProp(configProperty(FileSystemStorageConfig.COMPONENT_CODE, FileSystemStorageConfig.ROOT), getSegmentStoreStoragePath())
                 .sysProp(configProperty(AutoScalerConfig.COMPONENT_CODE, AutoScalerConfig.CONTROLLER_URI), getControllerUrl())
+                .sysProp(configProperty(AutoScalerConfig.COMPONENT_CODE, AutoScalerConfig.AUTH_ENABLED), this.testConfig.isEnableSecurity())
+                .sysProp(configProperty(AutoScalerConfig.COMPONENT_CODE, AutoScalerConfig.AUTH_PASSWORD), "1111_aaaa")
+                .sysProp(configProperty(AutoScalerConfig.COMPONENT_CODE, AutoScalerConfig.AUTH_USERNAME), "admin")
+                .sysProp(configProperty(AutoScalerConfig.COMPONENT_CODE, AutoScalerConfig.TLS_ENABLED), this.testConfig.isEnableSecurity())
+                .sysProp(configProperty(AutoScalerConfig.COMPONENT_CODE, AutoScalerConfig.TLS_CERT_FILE), "../../config/cert.pem")
+                .sysProp(configProperty(AutoScalerConfig.COMPONENT_CODE, AutoScalerConfig.TOKEN_SIGNING_KEY), "secret")
+                .sysProp(configProperty(BookKeeperConfig.COMPONENT_CODE, BookKeeperConfig.BK_TLS_ENABLED), this.testConfig.isEnableSecurity())
+                .sysProp(configProperty(BookKeeperConfig.COMPONENT_CODE, BookKeeperConfig.TLS_TRUST_STORE_PATH), "../../config/bookie.truststore.jks")
                 .stdOut(ProcessBuilder.Redirect.to(new File(this.testConfig.getComponentOutLogPath("segmentStore", segmentStoreId))))
                 .stdErr(ProcessBuilder.Redirect.to(new File(this.testConfig.getComponentErrLogPath("segmentStore", segmentStoreId))));
         if (this.testConfig.getBookieCount() > 0) {
diff --git a/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/TruncateableArray.java b/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/TruncateableArray.java
index 8075f34..36fa8df 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/TruncateableArray.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/selftest/adapters/TruncateableArray.java
@@ -9,11 +9,10 @@
  */
 package io.pravega.test.integration.selftest.adapters;
 
-import io.pravega.common.io.StreamHelpers;
-import io.pravega.common.util.ArrayView;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterators;
-
+import io.pravega.common.io.StreamHelpers;
+import io.pravega.common.util.ArrayView;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
diff --git a/test/integration/src/main/java/io/pravega/test/integration/utils/SetupUtils.java b/test/integration/src/main/java/io/pravega/test/integration/utils/SetupUtils.java
index 979273f..e948613 100644
--- a/test/integration/src/main/java/io/pravega/test/integration/utils/SetupUtils.java
+++ b/test/integration/src/main/java/io/pravega/test/integration/utils/SetupUtils.java
@@ -9,15 +9,11 @@
  */
 package io.pravega.test.integration.utils;
 
+import com.google.common.base.Preconditions;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
-import io.pravega.controller.util.Config;
-import io.pravega.test.integration.demo.ControllerWrapper;
-import io.pravega.segmentstore.contracts.StreamSegmentStore;
-import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
-import io.pravega.segmentstore.server.store.ServiceBuilder;
-import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.client.stream.EventStreamReader;
 import io.pravega.client.stream.EventStreamWriter;
 import io.pravega.client.stream.EventWriterConfig;
@@ -25,19 +21,23 @@ import io.pravega.client.stream.ReaderConfig;
 import io.pravega.client.stream.ReaderGroupConfig;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.controller.util.Config;
+import io.pravega.segmentstore.contracts.StreamSegmentStore;
+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
+import io.pravega.segmentstore.server.store.ServiceBuilder;
+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
 import io.pravega.test.common.TestingServerStarter;
-import com.google.common.base.Preconditions;
-import lombok.Cleanup;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.curator.test.TestingServer;
-
-import javax.annotation.concurrent.NotThreadSafe;
+import io.pravega.test.integration.demo.ControllerWrapper;
 import java.net.URI;
 import java.util.Collections;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.concurrent.NotThreadSafe;
+import lombok.Cleanup;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.curator.test.TestingServer;
 
 /**
  * Utility functions for creating the test setup.
@@ -134,7 +134,7 @@ public final class SetupUtils {
         Preconditions.checkArgument(numSegments > 0);
 
         @Cleanup
-        StreamManager streamManager = StreamManager.create(this.controllerUri);
+        StreamManager streamManager = StreamManager.create(ClientConfig.builder().controllerURI(this.controllerUri).build());
         streamManager.createScope(this.scope);
         streamManager.createStream(this.scope, streamName,
                 StreamConfiguration.builder()
@@ -156,7 +156,7 @@ public final class SetupUtils {
         Preconditions.checkState(this.started.get(), "Services not yet started");
         Preconditions.checkNotNull(streamName);
 
-        ClientFactory clientFactory = ClientFactory.withScope(this.scope, this.controllerUri);
+        ClientFactory clientFactory = ClientFactory.withScope(this.scope, ClientConfig.builder().controllerURI(this.controllerUri).build());
         return clientFactory.createEventWriter(
                 streamName,
                 new IntegerSerializer(),
@@ -174,14 +174,15 @@ public final class SetupUtils {
         Preconditions.checkState(this.started.get(), "Services not yet started");
         Preconditions.checkNotNull(streamName);
 
-        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(this.scope, this.controllerUri);
+        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(this.scope,
+                ClientConfig.builder().controllerURI(controllerUri).build());
         final String readerGroup = "testReaderGroup" + this.scope + streamName;
         readerGroupManager.createReaderGroup(
                 readerGroup,
                 ReaderGroupConfig.builder().startingTime(0).build(),
                 Collections.singleton(streamName));
 
-        ClientFactory clientFactory = ClientFactory.withScope(this.scope, this.controllerUri);
+        ClientFactory clientFactory = ClientFactory.withScope(this.scope, ClientConfig.builder().controllerURI(this.controllerUri).build());
         final String readerGroupId = UUID.randomUUID().toString();
         return clientFactory.createReader(
                 readerGroupId,
diff --git a/test/integration/src/test/java/io/pravega/test/integration/AppendTest.java b/test/integration/src/test/java/io/pravega/test/integration/AppendTest.java
index 716a530..c11b2f0 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/AppendTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/AppendTest.java
@@ -17,6 +17,7 @@ import io.netty.util.ResourceLeakDetector;
 import io.netty.util.ResourceLeakDetector.Level;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import io.netty.util.internal.logging.Slf4JLoggerFactory;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.segment.impl.Segment;
@@ -63,7 +64,6 @@ import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.function.Consumer;
-
 import lombok.Cleanup;
 import org.junit.After;
 import org.junit.Before;
@@ -102,7 +102,7 @@ public class AppendTest {
         EmbeddedChannel channel = createChannel(store);
 
         UUID uuid = UUID.randomUUID();
-        NoSuchSegment setup = (NoSuchSegment) sendRequest(channel, new SetupAppend(1, uuid, segment));
+        NoSuchSegment setup = (NoSuchSegment) sendRequest(channel, new SetupAppend(1, uuid, segment, ""));
 
         assertEquals(segment, setup.getSegment());
     }
@@ -116,11 +116,11 @@ public class AppendTest {
         @Cleanup
         EmbeddedChannel channel = createChannel(store);
 
-        SegmentCreated created = (SegmentCreated) sendRequest(channel, new CreateSegment(1, segment, CreateSegment.NO_SCALE, 0));
+        SegmentCreated created = (SegmentCreated) sendRequest(channel, new CreateSegment(1, segment, CreateSegment.NO_SCALE, 0, ""));
         assertEquals(segment, created.getSegment());
 
         UUID uuid = UUID.randomUUID();
-        AppendSetup setup = (AppendSetup) sendRequest(channel, new SetupAppend(2, uuid, segment));
+        AppendSetup setup = (AppendSetup) sendRequest(channel, new SetupAppend(2, uuid, segment, ""));
 
         assertEquals(segment, setup.getSegment());
         assertEquals(uuid, setup.getWriterId());
@@ -140,11 +140,11 @@ public class AppendTest {
         @Cleanup
         EmbeddedChannel channel = createChannel(store);
 
-        SegmentCreated created = (SegmentCreated) sendRequest(channel, new CreateSegment(1, segment, CreateSegment.NO_SCALE, 0));
+        SegmentCreated created = (SegmentCreated) sendRequest(channel, new CreateSegment(1, segment, CreateSegment.NO_SCALE, 0, ""));
         assertEquals(segment, created.getSegment());
 
         UUID uuid = UUID.randomUUID();
-        AppendSetup setup = (AppendSetup) sendRequest(channel, new SetupAppend(2, uuid, segment));
+        AppendSetup setup = (AppendSetup) sendRequest(channel, new SetupAppend(2, uuid, segment, ""));
 
         assertEquals(segment, setup.getSegment());
         assertEquals(uuid, setup.getWriterId());
@@ -189,7 +189,7 @@ public class AppendTest {
                 new CommandDecoder(),
                 new AppendDecoder(),
                 lsh);
-        lsh.setRequestProcessor(new AppendProcessor(store, lsh, new PravegaRequestProcessor(store, lsh)));
+        lsh.setRequestProcessor(new AppendProcessor(store, lsh, new PravegaRequestProcessor(store, lsh), null));
         return channel;
     }
 
@@ -207,7 +207,7 @@ public class AppendTest {
         server.startListening();
 
         @Cleanup
-        ConnectionFactory clientCF = new ConnectionFactoryImpl(false);
+        ConnectionFactory clientCF = new ConnectionFactoryImpl(ClientConfig.builder().build());
         Controller controller = new MockController(endpoint, port, clientCF);
         controller.createScope(scope);
         controller.createStream(StreamConfiguration.builder().scope(scope).streamName(stream).build());
@@ -216,7 +216,7 @@ public class AppendTest {
 
         Segment segment = Futures.getAndHandleExceptions(controller.getCurrentSegments(scope, stream), RuntimeException::new).getSegments().iterator().next();
         @Cleanup
-        SegmentOutputStream out = segmentClient.createOutputStreamForSegment(segment, segmentSealedCallback, EventWriterConfig.builder().build());
+        SegmentOutputStream out = segmentClient.createOutputStreamForSegment(segment, segmentSealedCallback, EventWriterConfig.builder().build(), "");
         CompletableFuture<Boolean> ack = new CompletableFuture<>();
         out.write(new PendingEvent(null, ByteBuffer.wrap(testString.getBytes()), ack));
         assertTrue(ack.get(5, TimeUnit.SECONDS));
diff --git a/test/integration/src/test/java/io/pravega/test/integration/ControllerFailoverTest.java b/test/integration/src/test/java/io/pravega/test/integration/ControllerFailoverTest.java
index 60f635f..fc492af 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/ControllerFailoverTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/ControllerFailoverTest.java
@@ -9,24 +9,24 @@
  */
 package io.pravega.test.integration;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.admin.StreamManager;
-import io.pravega.test.common.TestingServerStarter;
-import io.pravega.test.integration.demo.ControllerWrapper;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.segmentstore.contracts.StreamSegmentStore;
 import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
 import io.pravega.segmentstore.server.store.ServiceBuilder;
 import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.test.common.TestUtils;
+import io.pravega.test.common.TestingServerStarter;
+import io.pravega.test.integration.demo.ControllerWrapper;
+import java.net.URI;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.curator.test.TestingServer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.net.URI;
-
 /**
  * Tests for validating controller fail over behaviour.
  */
@@ -95,7 +95,7 @@ public class ControllerFailoverTest {
         controllerWrapper.awaitRunning();
 
         URI controllerURI = URI.create("tcp://localhost:" + controllerPort);
-        StreamManager streamManager = StreamManager.create(controllerURI);
+        StreamManager streamManager = StreamManager.create( ClientConfig.builder().controllerURI(controllerURI).build());
 
         // Create scope
         streamManager.createScope(SCOPE);
diff --git a/test/integration/src/test/java/io/pravega/test/integration/ControllerRestApiTest.java b/test/integration/src/test/java/io/pravega/test/integration/ControllerRestApiTest.java
index dcaa01b..21ae266 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/ControllerRestApiTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/ControllerRestApiTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.integration;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -51,7 +52,6 @@ import javax.ws.rs.core.Response;
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.commons.lang.RandomStringUtils;
-import org.glassfish.jersey.client.ClientConfig;
 import org.junit.AfterClass;
 import org.junit.Assert;
 import org.junit.BeforeClass;
@@ -80,7 +80,7 @@ public class ControllerRestApiTest {
     private String resourceURl;
 
     public ControllerRestApiTest() {
-        ClientConfig clientConfig = new ClientConfig();
+        org.glassfish.jersey.client.ClientConfig clientConfig = new org.glassfish.jersey.client.ClientConfig();
         clientConfig.register(JacksonJsonProvider.class);
         clientConfig.property("sun.net.http.allowRestrictedHeaders", "true");
         client = ClientBuilder.newClient(clientConfig);
@@ -258,7 +258,8 @@ public class ControllerRestApiTest {
         final String reader1 = RandomStringUtils.randomAlphanumeric(10);
         final String reader2 = RandomStringUtils.randomAlphanumeric(10);
         try (ClientFactory clientFactory = new ClientFactoryImpl(testScope, createController(controllerUri, inlineExecutor));
-             ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(testScope, controllerUri)) {
+             ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(testScope,
+                     ClientConfig.builder().controllerURI(controllerUri).build())) {
             readerGroupManager.createReaderGroup(readerGroupName1, ReaderGroupConfig.builder().startingTime(0).build(),
                     new HashSet<>(Arrays.asList(testStream1, testStream2)));
             readerGroupManager.createReaderGroup(readerGroupName2, ReaderGroupConfig.builder().startingTime(0).build(),
@@ -311,6 +312,8 @@ public class ControllerRestApiTest {
     }
 
     private Controller createController(URI controllerUri, InlineExecutor executor) {
-        return new ControllerImpl(controllerUri, ControllerImplConfig.builder().retryAttempts(1).build(), executor);
+        return new ControllerImpl(ControllerImplConfig.builder()
+                                                      .clientConfig(ClientConfig.builder().controllerURI(controllerUri).build())
+                                                      .retryAttempts(1).build(), executor);
     }
 }
diff --git a/test/integration/src/test/java/io/pravega/test/integration/MultiReadersEndToEndTest.java b/test/integration/src/test/java/io/pravega/test/integration/MultiReadersEndToEndTest.java
index 567ee7d..fddf2d9 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/MultiReadersEndToEndTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/MultiReadersEndToEndTest.java
@@ -10,16 +10,10 @@
 package io.pravega.test.integration;
 
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
-import io.pravega.common.concurrent.Futures;
-import io.pravega.test.integration.utils.IntegerSerializer;
-import io.pravega.test.integration.utils.SetupUtils;
-import io.pravega.segmentstore.contracts.StreamSegmentStore;
-import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
-import io.pravega.segmentstore.server.store.ServiceBuilder;
-import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.client.stream.EventStreamReader;
 import io.pravega.client.stream.EventStreamWriter;
 import io.pravega.client.stream.EventWriterConfig;
@@ -30,7 +24,14 @@ import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.client.stream.mock.MockClientFactory;
 import io.pravega.client.stream.mock.MockStreamManager;
+import io.pravega.common.concurrent.Futures;
+import io.pravega.segmentstore.contracts.StreamSegmentStore;
+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
+import io.pravega.segmentstore.server.store.ServiceBuilder;
+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
+import io.pravega.test.integration.utils.IntegerSerializer;
+import io.pravega.test.integration.utils.SetupUtils;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -100,7 +101,8 @@ public class MultiReadersEndToEndTest {
     private void runTest(final Set<String> streamNames, final int numParallelReaders, final int numSegments)
             throws Exception {
         @Cleanup
-        StreamManager streamManager = StreamManager.create(SETUP_UTILS.getControllerUri());
+        StreamManager streamManager = StreamManager.create(ClientConfig.builder()
+                                                                       .controllerURI(SETUP_UTILS.getControllerUri()).build());
         streamManager.createScope(SETUP_UTILS.getScope());
         streamNames.stream().forEach(stream -> {
             streamManager.createStream(SETUP_UTILS.getScope(),
@@ -114,7 +116,8 @@ public class MultiReadersEndToEndTest {
         });
 
         @Cleanup
-        ClientFactory clientFactory = ClientFactory.withScope(SETUP_UTILS.getScope(), SETUP_UTILS.getControllerUri());
+        ClientFactory clientFactory = ClientFactory.withScope(SETUP_UTILS.getScope(), ClientConfig.builder()
+                                                                                                  .controllerURI(SETUP_UTILS.getControllerUri()).build());
         streamNames.stream().forEach(stream -> {
             EventStreamWriter<Integer> eventWriter = clientFactory.createEventWriter(
                     stream, new IntegerSerializer(), EventWriterConfig.builder().build());
@@ -129,7 +132,8 @@ public class MultiReadersEndToEndTest {
 
         @Cleanup
         ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(SETUP_UTILS.getScope(),
-                                                                             SETUP_UTILS.getControllerUri());
+                                    ClientConfig.builder()
+                                                .controllerURI(SETUP_UTILS.getControllerUri()).build());
         readerGroupManager.createReaderGroup(readerGroupName,
                                              ReaderGroupConfig.builder().startingTime(0).build(),
                                              streamNames);
diff --git a/test/integration/src/test/java/io/pravega/test/integration/ReadFromDeletedStreamTest.java b/test/integration/src/test/java/io/pravega/test/integration/ReadFromDeletedStreamTest.java
index 2a84eaa..fac8282 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/ReadFromDeletedStreamTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/ReadFromDeletedStreamTest.java
@@ -45,7 +45,7 @@ public class ReadFromDeletedStreamTest {
         StreamSegmentStore store = serviceBuilder.createStreamSegmentService();
 
         @Cleanup
-        PravegaConnectionListener server = new PravegaConnectionListener(false, "localhost", 12345, store, null);
+        PravegaConnectionListener server = new PravegaConnectionListener(false, "localhost", 12345, store, null, null, null, null);
         server.startListening();
 
         streamManager.createScope("test");
diff --git a/test/integration/src/test/java/io/pravega/test/integration/ReadTest.java b/test/integration/src/test/java/io/pravega/test/integration/ReadTest.java
index ba9b206..84d9560 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/ReadTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/ReadTest.java
@@ -14,6 +14,7 @@ import io.netty.util.ResourceLeakDetector;
 import io.netty.util.ResourceLeakDetector.Level;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import io.netty.util.internal.logging.Slf4JLoggerFactory;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
 import io.pravega.client.segment.impl.EndOfSegmentException;
@@ -60,7 +61,6 @@ import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.function.Consumer;
-
 import lombok.Cleanup;
 import org.junit.After;
 import org.junit.Before;
@@ -135,7 +135,7 @@ public class ReadTest {
         @Cleanup
         EmbeddedChannel channel = AppendTest.createChannel(segmentStore);
 
-        SegmentRead result = (SegmentRead) AppendTest.sendRequest(channel, new ReadSegment(segmentName, 0, 10000));
+        SegmentRead result = (SegmentRead) AppendTest.sendRequest(channel, new ReadSegment(segmentName, 0, 10000, ""));
 
         assertEquals(result.getSegment(), segmentName);
         assertEquals(result.getOffset(), 0);
@@ -161,7 +161,7 @@ public class ReadTest {
         @Cleanup
         PravegaConnectionListener server = new PravegaConnectionListener(false, port, store);
         server.startListening();
-        ConnectionFactory clientCF = new ConnectionFactoryImpl(false);
+        ConnectionFactory clientCF = new ConnectionFactoryImpl(ClientConfig.builder().build());
         Controller controller = new MockController(endpoint, port, clientCF);
         controller.createScope(scope);
         controller.createStream(StreamConfiguration.builder().scope(scope).streamName(stream).build());
@@ -174,7 +174,7 @@ public class ReadTest {
                                  .getSegments().iterator().next();
 
         @Cleanup("close")
-        SegmentOutputStream out = segmentproducerClient.createOutputStreamForSegment(segment, segmentSealedCallback, EventWriterConfig.builder().build());
+        SegmentOutputStream out = segmentproducerClient.createOutputStreamForSegment(segment, segmentSealedCallback, EventWriterConfig.builder().build(), "");
         out.write(new PendingEvent(null, ByteBuffer.wrap(testString.getBytes()), new CompletableFuture<>()));
         out.flush();
 
diff --git a/test/integration/src/test/java/io/pravega/test/integration/ReadWriteTest.java b/test/integration/src/test/java/io/pravega/test/integration/ReadWriteTest.java
index 9dfdd46..56fb0ad 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/ReadWriteTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/ReadWriteTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.integration;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -139,7 +140,7 @@ public class ReadWriteTest {
             log.info("Create stream status {}", createStreamStatus);
         }
 
-        try (ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
+        try (ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
              ClientFactory clientFactory = new ClientFactoryImpl(scope, controller, connectionFactory);
              ReaderGroupManager readerGroupManager = new ReaderGroupManagerImpl(scope, controller, clientFactory, connectionFactory)) {
 
diff --git a/test/integration/src/test/java/io/pravega/test/integration/ReaderGroupNotificationTest.java b/test/integration/src/test/java/io/pravega/test/integration/ReaderGroupNotificationTest.java
index 973092b..79d65a0 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/ReaderGroupNotificationTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/ReaderGroupNotificationTest.java
@@ -9,25 +9,7 @@
  */
 package io.pravega.test.integration;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import org.apache.curator.test.TestingServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
@@ -58,8 +40,26 @@ import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
 import io.pravega.test.common.TestingServerStarter;
 import io.pravega.test.integration.demo.ControllerWrapper;
+import java.net.URI;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
+import org.apache.curator.test.TestingServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 @Slf4j
 public class ReaderGroupNotificationTest {
@@ -129,7 +129,9 @@ public class ReaderGroupNotificationTest {
         controllerWrapper.getControllerService().createScope(SCOPE).get();
         controller.createStream(config).get();
         @Cleanup
-        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder()
+                                                                                    .controllerURI(URI.create("tcp://localhost"))
+                                                                                    .build());
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl(SCOPE, controller, connectionFactory);
         @Cleanup
@@ -189,7 +191,9 @@ public class ReaderGroupNotificationTest {
         controllerWrapper.getControllerService().createScope(SCOPE).get();
         controller.createStream(config).get();
         @Cleanup
-        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder()
+                                                                                    .controllerURI(URI.create("tcp://localhost"))
+                                                                                    .build());
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl(SCOPE, controller, connectionFactory);
         @Cleanup
diff --git a/test/integration/src/test/java/io/pravega/test/integration/StreamCutsTest.java b/test/integration/src/test/java/io/pravega/test/integration/StreamCutsTest.java
index 6684e03..51b5f73 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/StreamCutsTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/StreamCutsTest.java
@@ -9,7 +9,7 @@
  */
 package io.pravega.test.integration;
 
-
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
@@ -38,13 +38,6 @@ import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
 import io.pravega.test.common.TestingServerStarter;
 import io.pravega.test.integration.demo.ControllerWrapper;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.curator.test.TestingServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -53,6 +46,12 @@ import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.curator.test.TestingServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -112,7 +111,7 @@ public class StreamCutsTest {
         controllerWrapper.getControllerService().createScope("test").get();
         controller.createStream(config).get();
         @Cleanup
-        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl("test", controller, connectionFactory);
         @Cleanup
diff --git a/test/integration/src/test/java/io/pravega/test/integration/UnreadBytesTest.java b/test/integration/src/test/java/io/pravega/test/integration/UnreadBytesTest.java
index b66b39d..8cd0373 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/UnreadBytesTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/UnreadBytesTest.java
@@ -9,15 +9,7 @@
  */
 package io.pravega.test.integration;
 
-import java.net.URI;
-import java.util.Collections;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import org.apache.curator.test.TestingServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.stream.Checkpoint;
@@ -39,8 +31,17 @@ import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
 import io.pravega.test.common.TestingServerStarter;
 import io.pravega.test.integration.demo.ControllerWrapper;
+import java.net.URI;
+import java.util.Collections;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
+import org.apache.curator.test.TestingServer;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -104,13 +105,13 @@ public class UnreadBytesTest {
         controller.createStream(config).get();
 
         @Cleanup
-        ClientFactory clientFactory = ClientFactory.withScope("unreadbytes", controllerUri);
+        ClientFactory clientFactory = ClientFactory.withScope("unreadbytes", ClientConfig.builder().controllerURI(controllerUri).build());
         @Cleanup
         EventStreamWriter<String> writer = clientFactory.createEventWriter("unreadbytes", new JavaSerializer<>(),
                 EventWriterConfig.builder().build());
 
         @Cleanup
-        ReaderGroupManager groupManager = ReaderGroupManager.withScope("unreadbytes", controllerUri);
+        ReaderGroupManager groupManager = ReaderGroupManager.withScope("unreadbytes",  ClientConfig.builder().controllerURI(controllerUri).build());
         ReaderGroup readerGroup = groupManager.createReaderGroup("group", ReaderGroupConfig
                 .builder().disableAutomaticCheckpoints().build(), Collections
                 .singleton("unreadbytes"));
diff --git a/test/integration/src/test/java/io/pravega/test/integration/controller/server/EventProcessorTest.java b/test/integration/src/test/java/io/pravega/test/integration/controller/server/EventProcessorTest.java
index b2942a0..a0cd756 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/controller/server/EventProcessorTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/controller/server/EventProcessorTest.java
@@ -9,14 +9,20 @@
  */
 package io.pravega.test.integration.controller.server;
 
+import com.google.common.base.Preconditions;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
-import io.pravega.common.concurrent.Futures;
-import io.pravega.shared.controller.event.ControllerEvent;
+import io.pravega.client.stream.EventStreamWriter;
+import io.pravega.client.stream.EventWriterConfig;
 import io.pravega.client.stream.Position;
-import io.pravega.shared.controller.event.RequestProcessor;
-import io.pravega.test.common.TestingServerStarter;
+import io.pravega.client.stream.ScalingPolicy;
+import io.pravega.client.stream.StreamConfiguration;
+import io.pravega.client.stream.impl.ClientFactoryImpl;
+import io.pravega.client.stream.impl.Controller;
+import io.pravega.client.stream.impl.JavaSerializer;
+import io.pravega.common.concurrent.Futures;
 import io.pravega.controller.eventProcessor.CheckpointConfig;
 import io.pravega.controller.eventProcessor.EventProcessorConfig;
 import io.pravega.controller.eventProcessor.EventProcessorGroup;
@@ -27,20 +33,15 @@ import io.pravega.controller.eventProcessor.impl.EventProcessor;
 import io.pravega.controller.eventProcessor.impl.EventProcessorGroupConfigImpl;
 import io.pravega.controller.eventProcessor.impl.EventProcessorSystemImpl;
 import io.pravega.controller.store.checkpoint.CheckpointStoreFactory;
-import io.pravega.test.integration.demo.ControllerWrapper;
 import io.pravega.segmentstore.contracts.StreamSegmentStore;
 import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
 import io.pravega.segmentstore.server.store.ServiceBuilder;
 import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
-import io.pravega.client.stream.EventStreamWriter;
-import io.pravega.client.stream.EventWriterConfig;
-import io.pravega.client.stream.ScalingPolicy;
-import io.pravega.client.stream.StreamConfiguration;
-import io.pravega.client.stream.impl.ClientFactoryImpl;
-import io.pravega.client.stream.impl.Controller;
-import io.pravega.client.stream.impl.JavaSerializer;
+import io.pravega.shared.controller.event.ControllerEvent;
+import io.pravega.shared.controller.event.RequestProcessor;
 import io.pravega.test.common.TestUtils;
-import com.google.common.base.Preconditions;
+import io.pravega.test.common.TestingServerStarter;
+import io.pravega.test.integration.demo.ControllerWrapper;
 import java.util.concurrent.CompletableFuture;
 import lombok.AllArgsConstructor;
 import lombok.Cleanup;
@@ -158,7 +159,7 @@ public class EventProcessorTest {
         }
 
         @Cleanup
-        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl(scope, controller, connectionFactory);
 
diff --git a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndChannelLeakTest.java b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndChannelLeakTest.java
index 109918c..b111eb9 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndChannelLeakTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndChannelLeakTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.integration.endtoendtest;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
@@ -34,6 +35,11 @@ import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
 import io.pravega.test.common.TestingServerStarter;
 import io.pravega.test.integration.demo.ControllerWrapper;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.curator.test.TestingServer;
@@ -41,13 +47,9 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 @Slf4j
 public class EndToEndChannelLeakTest {
@@ -104,7 +106,7 @@ public class EndToEndChannelLeakTest {
         controllerWrapper.getControllerService().createScope(SCOPE).get();
         controller.createStream(config).get();
         @Cleanup
-        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl(SCOPE, controller, connectionFactory);
 
@@ -173,7 +175,7 @@ public class EndToEndChannelLeakTest {
         controllerWrapper.getControllerService().createScope(SCOPE).get();
         controller.createStream(config).get();
         @Cleanup
-        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactoryImpl connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         @Cleanup
         ClientFactoryImpl clientFactory = new ClientFactoryImpl(SCOPE, controller, connectionFactory);
 
diff --git a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndStatsTest.java b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndStatsTest.java
index fa7d3f9..b9ef74a 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndStatsTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndStatsTest.java
@@ -35,6 +35,8 @@ import io.pravega.shared.segment.StreamSegmentNameUtils;
 import io.pravega.test.common.TestUtils;
 import io.pravega.test.common.TestingServerStarter;
 import io.pravega.test.integration.demo.ControllerWrapper;
+import java.util.HashMap;
+import java.util.concurrent.atomic.AtomicInteger;
 import lombok.Cleanup;
 import lombok.Getter;
 import lombok.extern.slf4j.Slf4j;
@@ -43,9 +45,6 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.HashMap;
-import java.util.concurrent.atomic.AtomicInteger;
-
 import static org.junit.Assert.assertEquals;
 
 @Slf4j
@@ -72,7 +71,7 @@ public class EndToEndStatsTest {
         statsRecorder = new TestStatsRecorder();
 
         server = new PravegaConnectionListener(false, "localhost", servicePort, store,
-                statsRecorder);
+                statsRecorder, null, null, null);
         server.startListening();
 
         controllerWrapper = new ControllerWrapper(zkTestServer.getConnectString(),
diff --git a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndTruncationTest.java b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndTruncationTest.java
index f69ab92..7bfa1a6 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndTruncationTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndTruncationTest.java
@@ -10,6 +10,7 @@
 package io.pravega.test.integration.endtoendtest;
 
 import com.google.common.collect.Lists;
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
@@ -35,6 +36,12 @@ import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
 import io.pravega.test.common.TestingServerStarter;
 import io.pravega.test.integration.demo.ControllerWrapper;
+import java.net.URI;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.curator.test.TestingServer;
@@ -42,12 +49,6 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -107,7 +108,9 @@ public class EndToEndTruncationTest {
         controllerWrapper.getControllerService().createScope("test").get();
         controller.createStream(config).get();
         @Cleanup
-        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder()
+                                                                                    .controllerURI(URI.create("tcp://localhost"))
+                                                                                    .build());
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl("test", controller, connectionFactory);
         @Cleanup
diff --git a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndTxnWithScaleTest.java b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndTxnWithScaleTest.java
index 78c63f9..7bd98d9 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndTxnWithScaleTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndTxnWithScaleTest.java
@@ -9,17 +9,12 @@
  */
 package io.pravega.test.integration.endtoendtest;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
 import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
-import io.pravega.test.common.TestingServerStarter;
-import io.pravega.test.integration.demo.ControllerWrapper;
-import io.pravega.segmentstore.contracts.StreamSegmentStore;
-import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
-import io.pravega.segmentstore.server.store.ServiceBuilder;
-import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.client.stream.EventRead;
 import io.pravega.client.stream.EventStreamReader;
 import io.pravega.client.stream.EventStreamWriter;
@@ -34,14 +29,18 @@ import io.pravega.client.stream.impl.ClientFactoryImpl;
 import io.pravega.client.stream.impl.Controller;
 import io.pravega.client.stream.impl.JavaSerializer;
 import io.pravega.client.stream.impl.StreamImpl;
+import io.pravega.segmentstore.contracts.StreamSegmentStore;
+import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;
+import io.pravega.segmentstore.server.store.ServiceBuilder;
+import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
-
+import io.pravega.test.common.TestingServerStarter;
+import io.pravega.test.integration.demo.ControllerWrapper;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
-
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.curator.test.TestingServer;
@@ -109,7 +108,7 @@ public class EndToEndTxnWithScaleTest {
         controllerWrapper.getControllerService().createScope("test").get();
         controller.createStream(config).get();
         @Cleanup
-        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl("test", controller, connectionFactory);
         @Cleanup
diff --git a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndWithScaleTest.java b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndWithScaleTest.java
index 6533444..8784171 100644
--- a/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndWithScaleTest.java
+++ b/test/integration/src/test/java/io/pravega/test/integration/endtoendtest/EndToEndWithScaleTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.integration.endtoendtest;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.impl.ReaderGroupManagerImpl;
@@ -34,13 +35,12 @@ import io.pravega.segmentstore.server.store.ServiceBuilderConfig;
 import io.pravega.test.common.TestUtils;
 import io.pravega.test.common.TestingServerStarter;
 import io.pravega.test.integration.demo.ControllerWrapper;
-
+import java.net.URI;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
-
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.curator.test.TestingServer;
@@ -106,7 +106,9 @@ public class EndToEndWithScaleTest {
         controllerWrapper.getControllerService().createScope("test").get();
         controller.createStream(config).get();
         @Cleanup
-        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
+        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder()
+                                                                                    .controllerURI(URI.create("tcp://localhost"))
+                                                                                    .build());
         @Cleanup
         ClientFactory clientFactory = new ClientFactoryImpl("test", controller, connectionFactory);
         @Cleanup
diff --git a/test/system/src/main/java/io/pravega/test/system/framework/DockerBasedTestExecutor.java b/test/system/src/main/java/io/pravega/test/system/framework/DockerBasedTestExecutor.java
index cab2511..ff0c0d4 100644
--- a/test/system/src/main/java/io/pravega/test/system/framework/DockerBasedTestExecutor.java
+++ b/test/system/src/main/java/io/pravega/test/system/framework/DockerBasedTestExecutor.java
@@ -20,8 +20,6 @@ import com.spotify.docker.client.messages.HostConfig;
 import com.spotify.docker.client.messages.PortBinding;
 import io.pravega.common.Exceptions;
 import io.pravega.common.concurrent.Futures;
-import lombok.extern.slf4j.Slf4j;
-import org.junit.Assert;
 import java.lang.reflect.Method;
 import java.nio.file.Path;
 import java.nio.file.Paths;
@@ -34,6 +32,9 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Assert;
+
 import static io.pravega.test.system.framework.Utils.DOCKER_NETWORK;
 import static io.pravega.test.system.framework.Utils.getConfig;
 import static org.junit.Assert.assertFalse;
diff --git a/test/system/src/main/java/io/pravega/test/system/framework/Utils.java b/test/system/src/main/java/io/pravega/test/system/framework/Utils.java
index 9c2f959..60e1402 100644
--- a/test/system/src/main/java/io/pravega/test/system/framework/Utils.java
+++ b/test/system/src/main/java/io/pravega/test/system/framework/Utils.java
@@ -19,7 +19,6 @@ import io.pravega.test.system.framework.services.marathon.BookkeeperService;
 import io.pravega.test.system.framework.services.marathon.PravegaControllerService;
 import io.pravega.test.system.framework.services.marathon.PravegaSegmentStoreService;
 import io.pravega.test.system.framework.services.marathon.ZookeeperService;
-
 import java.net.URI;
 
 /**
diff --git a/test/system/src/main/java/io/pravega/test/system/framework/services/docker/BookkeeperDockerService.java b/test/system/src/main/java/io/pravega/test/system/framework/services/docker/BookkeeperDockerService.java
index 6c8d15e..fe06d18 100644
--- a/test/system/src/main/java/io/pravega/test/system/framework/services/docker/BookkeeperDockerService.java
+++ b/test/system/src/main/java/io/pravega/test/system/framework/services/docker/BookkeeperDockerService.java
@@ -22,14 +22,14 @@ import com.spotify.docker.client.messages.swarm.ServiceMode;
 import com.spotify.docker.client.messages.swarm.ServiceSpec;
 import com.spotify.docker.client.messages.swarm.TaskSpec;
 import java.net.URI;
-import lombok.extern.slf4j.Slf4j;
-
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+
 import static io.pravega.test.system.framework.Utils.DOCKER_NETWORK;
 
 @Slf4j
diff --git a/test/system/src/main/java/io/pravega/test/system/framework/services/docker/PravegaControllerDockerService.java b/test/system/src/main/java/io/pravega/test/system/framework/services/docker/PravegaControllerDockerService.java
index e66d7ae..ab67350 100644
--- a/test/system/src/main/java/io/pravega/test/system/framework/services/docker/PravegaControllerDockerService.java
+++ b/test/system/src/main/java/io/pravega/test/system/framework/services/docker/PravegaControllerDockerService.java
@@ -25,10 +25,11 @@ import java.time.Duration;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+
 import static io.pravega.test.system.framework.Utils.DOCKER_CONTROLLER_PORT;
 import static io.pravega.test.system.framework.Utils.DOCKER_NETWORK;
 import static io.pravega.test.system.framework.Utils.REST_PORT;
-import lombok.extern.slf4j.Slf4j;
 
 @Slf4j
 public class PravegaControllerDockerService extends DockerBasedService {
diff --git a/test/system/src/main/java/io/pravega/test/system/framework/services/docker/PravegaSegmentStoreDockerService.java b/test/system/src/main/java/io/pravega/test/system/framework/services/docker/PravegaSegmentStoreDockerService.java
index 850cacc..f0b79af 100644
--- a/test/system/src/main/java/io/pravega/test/system/framework/services/docker/PravegaSegmentStoreDockerService.java
+++ b/test/system/src/main/java/io/pravega/test/system/framework/services/docker/PravegaSegmentStoreDockerService.java
@@ -23,14 +23,14 @@ import com.spotify.docker.client.messages.swarm.ServiceMode;
 import com.spotify.docker.client.messages.swarm.ServiceSpec;
 import com.spotify.docker.client.messages.swarm.TaskSpec;
 import java.net.URI;
-import lombok.extern.slf4j.Slf4j;
-
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+
 import static io.pravega.test.system.framework.Utils.DOCKER_NETWORK;
 
 @Slf4j
diff --git a/test/system/src/test/java/io/pravega/test/system/AbstractScaleTests.java b/test/system/src/test/java/io/pravega/test/system/AbstractScaleTests.java
index 8f06fbd..b7fc387 100644
--- a/test/system/src/test/java/io/pravega/test/system/AbstractScaleTests.java
+++ b/test/system/src/test/java/io/pravega/test/system/AbstractScaleTests.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.netty.impl.ConnectionFactory;
 import io.pravega.client.netty.impl.ConnectionFactoryImpl;
@@ -34,13 +35,17 @@ abstract class AbstractScaleTests {
     @Getter(lazy = true)
     private final URI controllerURI = createControllerURI();
     @Getter(lazy = true)
-    private final ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
+    private final ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
     @Getter(lazy = true)
-    private final ClientFactory clientFactory = new ClientFactoryImpl(SCOPE, new ControllerImpl(getControllerURI(),
-            ControllerImplConfig.builder().build(), getConnectionFactory().getInternalExecutor()));
+    private final ClientFactory clientFactory = new ClientFactoryImpl(SCOPE, new ControllerImpl(
+            ControllerImplConfig.builder().clientConfig(
+                    ClientConfig.builder().controllerURI(getControllerURI()).build())
+                                .build(), getConnectionFactory().getInternalExecutor()));
     @Getter(lazy = true)
-    private final ControllerImpl controller = new ControllerImpl(getControllerURI(),
-            ControllerImplConfig.builder().build(), getConnectionFactory().getInternalExecutor());
+    private final ControllerImpl controller = new ControllerImpl(
+            ControllerImplConfig.builder().clientConfig(
+                    ClientConfig.builder().controllerURI(getControllerURI()).build()
+            ).build(), getConnectionFactory().getInternalExecutor());
 
     private URI createControllerURI() {
         Service conService = Utils.createPravegaControllerService(null);
diff --git a/test/system/src/test/java/io/pravega/test/system/ControllerFailoverTest.java b/test/system/src/test/java/io/pravega/test/system/ControllerFailoverTest.java
index 10e2eea..0f8fabb 100644
--- a/test/system/src/test/java/io/pravega/test/system/ControllerFailoverTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/ControllerFailoverTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.client.stream.Transaction;
@@ -138,8 +139,10 @@ public class ControllerFailoverTest {
         long scaleGracePeriod = 30000;
 
         // Connect with first controller instance.
-        final Controller controller1 = new ControllerImpl(controllerURIDirect,
-                ControllerImplConfig.builder().build(), EXECUTOR_SERVICE);
+        final Controller controller1 = new ControllerImpl(
+                ControllerImplConfig.builder()
+                                    .clientConfig( ClientConfig.builder().controllerURI(controllerURIDirect).build())
+                                    .build(), EXECUTOR_SERVICE);
 
         // Create scope, stream, and a transaction with high timeout value.
         controller1.createScope(scope).join();
@@ -176,8 +179,10 @@ public class ControllerFailoverTest {
         log.info("Controller Service direct URI: {}", controllerURIDirect);
 
         // Connect to another controller instance.
-        final Controller controller2 = new ControllerImpl(controllerURIDirect,
-                ControllerImplConfig.builder().build(), EXECUTOR_SERVICE);
+        final Controller controller2 = new ControllerImpl(
+                ControllerImplConfig.builder()
+                                    .clientConfig(ClientConfig.builder().controllerURI(controllerURIDirect).build())
+                                    .build(), EXECUTOR_SERVICE);
 
         // Fetch status of transaction.
         log.info("Fetching status of transaction {}, time elapsed since its creation={}",
diff --git a/test/system/src/test/java/io/pravega/test/system/ControllerRestApiTest.java b/test/system/src/test/java/io/pravega/test/system/ControllerRestApiTest.java
index fc81ec2..21b5428 100644
--- a/test/system/src/test/java/io/pravega/test/system/ControllerRestApiTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/ControllerRestApiTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -40,30 +41,30 @@ import io.pravega.test.system.framework.Environment;
 import io.pravega.test.system.framework.SystemTestRunner;
 import io.pravega.test.system.framework.Utils;
 import io.pravega.test.system.framework.services.Service;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
 import mesosphere.marathon.client.MarathonException;
 import org.apache.commons.lang3.RandomStringUtils;
-import org.glassfish.jersey.client.ClientConfig;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import javax.ws.rs.client.Client;
-import javax.ws.rs.client.WebTarget;
-import javax.ws.rs.client.ClientBuilder;
-import javax.ws.rs.client.Invocation;
-import javax.ws.rs.client.Entity;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.Response;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
+
+import static javax.ws.rs.core.Response.Status.CREATED;
 import static javax.ws.rs.core.Response.Status.NOT_FOUND;
-import static javax.ws.rs.core.Response.Status.OK;
 import static javax.ws.rs.core.Response.Status.NO_CONTENT;
-import static javax.ws.rs.core.Response.Status.CREATED;
+import static javax.ws.rs.core.Response.Status.OK;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -77,7 +78,7 @@ public class ControllerRestApiTest {
     private String resourceURl;
 
     public ControllerRestApiTest() {
-        ClientConfig clientConfig = new ClientConfig();
+        org.glassfish.jersey.client.ClientConfig clientConfig = new org.glassfish.jersey.client.ClientConfig();
         clientConfig.register(JacksonJsonProvider.class);
         clientConfig.property("sun.net.http.allowRestrictedHeaders", "true");
         client = ClientBuilder.newClient(clientConfig);
@@ -274,7 +275,7 @@ public class ControllerRestApiTest {
         final String testStream1 = RandomStringUtils.randomAlphanumeric(10);
         final String testStream2 = RandomStringUtils.randomAlphanumeric(10);
         URI controllerUri = ctlURIs.get(0);
-        try (StreamManager streamManager = new StreamManagerImpl(controllerUri)) {
+        try (StreamManager streamManager = new StreamManagerImpl(ClientConfig.builder().controllerURI(controllerUri).build())) {
             log.info("Creating scope: {}", testScope);
             streamManager.createScope(testScope);
 
@@ -295,9 +296,12 @@ public class ControllerRestApiTest {
         final String reader2 = RandomStringUtils.randomAlphanumeric(10);
         @Cleanup("shutdown")
         InlineExecutor executor = new InlineExecutor();
-        Controller controller = new ControllerImpl(controllerUri, ControllerImplConfig.builder().build(), executor);
+        Controller controller = new ControllerImpl(ControllerImplConfig.builder()
+                                     .clientConfig(ClientConfig.builder().controllerURI(controllerUri).build())
+                                     .build(), executor);
         try (ClientFactory clientFactory = new ClientFactoryImpl(testScope, controller);
-             ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(testScope, controllerUri)) {
+             ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(testScope,
+                     ClientConfig.builder().controllerURI(controllerUri).build())) {
             readerGroupManager.createReaderGroup(readerGroupName1, ReaderGroupConfig.builder().startingTime(0).build(),
                     new HashSet<>(Arrays.asList(testStream1, testStream2)));
             readerGroupManager.createReaderGroup(readerGroupName2, ReaderGroupConfig.builder().startingTime(0).build(),
diff --git a/test/system/src/test/java/io/pravega/test/system/MultiControllerTest.java b/test/system/src/test/java/io/pravega/test/system/MultiControllerTest.java
index 28295f7..f62986a 100644
--- a/test/system/src/test/java/io/pravega/test/system/MultiControllerTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/MultiControllerTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.stream.impl.ControllerImpl;
 import io.pravega.client.stream.impl.ControllerImplConfig;
 import io.pravega.common.concurrent.Futures;
@@ -35,6 +36,7 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+
 import static io.pravega.test.system.framework.Utils.DOCKER_BASED;
 
 @Slf4j
@@ -182,8 +184,10 @@ public class MultiControllerTest {
     }
 
     CompletableFuture<Boolean> createScope(String scopeName, URI controllerURI) {
-        final ControllerImpl controllerClient = new ControllerImpl(controllerURI,
-                ControllerImplConfig.builder().build(), EXECUTOR_SERVICE);
+        final ControllerImpl controllerClient = new ControllerImpl(
+                ControllerImplConfig.builder()
+                                    .clientConfig(ClientConfig.builder().controllerURI(controllerURI).build())
+                                    .build(), EXECUTOR_SERVICE);
         return controllerClient.createScope(scopeName);
     }
 }
diff --git a/test/system/src/test/java/io/pravega/test/system/MultiReaderTxnWriterWithFailoverTest.java b/test/system/src/test/java/io/pravega/test/system/MultiReaderTxnWriterWithFailoverTest.java
index a740725..52dba3a 100644
--- a/test/system/src/test/java/io/pravega/test/system/MultiReaderTxnWriterWithFailoverTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/MultiReaderTxnWriterWithFailoverTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -37,6 +38,7 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
+
 import static org.junit.Assert.assertTrue;
 
 @Slf4j
@@ -99,17 +101,19 @@ public class MultiReaderTxnWriterWithFailoverTest extends AbstractFailoverTests
         controllerExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(2,
                                                                                   "MultiReaderTxnWriterWithFailoverTest-controller");
         //get Controller Uri
-        controller = new ControllerImpl(controllerURIDirect,
-                                        ControllerImplConfig.builder().maxBackoffMillis(5000).build(),
+        controller = new ControllerImpl(
+                                        ControllerImplConfig.builder()
+                                                            .clientConfig(ClientConfig.builder().controllerURI(controllerURIDirect).build())
+                                                            .maxBackoffMillis(5000).build(),
                                         controllerExecutorService);
         testState = new TestState(true);
         //read and write count variables
         testState.writersListComplete.add(0, testState.writersComplete);
-        streamManager = new StreamManagerImpl(controllerURIDirect);
+        streamManager = new StreamManagerImpl( ClientConfig.builder().controllerURI(controllerURIDirect).build());
         createScopeAndStream(scope, STREAM_NAME, config, streamManager);
         log.info("Scope passed to client factory {}", scope);
         clientFactory = new ClientFactoryImpl(scope, controller);
-        readerGroupManager = ReaderGroupManager.withScope(scope, controllerURIDirect);
+        readerGroupManager = ReaderGroupManager.withScope(scope,  ClientConfig.builder().controllerURI(controllerURIDirect).build());
     }
 
     @After
diff --git a/test/system/src/test/java/io/pravega/test/system/MultiReaderWriterWithFailOverTest.java b/test/system/src/test/java/io/pravega/test/system/MultiReaderWriterWithFailOverTest.java
index 5d2235b..06ffa2a 100644
--- a/test/system/src/test/java/io/pravega/test/system/MultiReaderWriterWithFailOverTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/MultiReaderWriterWithFailOverTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -37,6 +38,7 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
+
 import static org.junit.Assert.assertTrue;
 
 @Slf4j
@@ -100,18 +102,19 @@ public class MultiReaderWriterWithFailOverTest extends  AbstractFailoverTests {
         controllerExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(2,
                 "MultiReaderWriterWithFailoverTest-controller");
         //get Controller Uri
-        controller = new ControllerImpl(controllerURIDirect,
-                ControllerImplConfig.builder().maxBackoffMillis(5000).build(),
+        controller = new ControllerImpl(ControllerImplConfig.builder()
+                                    .clientConfig(ClientConfig.builder().controllerURI(controllerURIDirect).build())
+                                    .maxBackoffMillis(5000).build(),
                 controllerExecutorService);
 
         testState = new TestState(false);
         //read and write count variables
         testState.writersListComplete.add(0, testState.writersComplete);
-        streamManager = new StreamManagerImpl(controllerURIDirect);
+        streamManager = new StreamManagerImpl(ClientConfig.builder().controllerURI(controllerURIDirect).build());
         createScopeAndStream(scope, STREAM_NAME, config, streamManager);
         log.info("Scope passed to client factory {}", scope);
         clientFactory = new ClientFactoryImpl(scope, controller);
-        readerGroupManager = ReaderGroupManager.withScope(scope, controllerURIDirect);
+        readerGroupManager = ReaderGroupManager.withScope(scope, ClientConfig.builder().controllerURI(controllerURIDirect).build());
 
     }
 
diff --git a/test/system/src/test/java/io/pravega/test/system/MultiSegmentStoreTest.java b/test/system/src/test/java/io/pravega/test/system/MultiSegmentStoreTest.java
index 1a1b8f0..51df52e 100644
--- a/test/system/src/test/java/io/pravega/test/system/MultiSegmentStoreTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/MultiSegmentStoreTest.java
@@ -9,14 +9,10 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
-import io.pravega.common.concurrent.Futures;
-import io.pravega.test.system.framework.Environment;
-import io.pravega.test.system.framework.SystemTestRunner;
-import io.pravega.test.system.framework.Utils;
-import io.pravega.test.system.framework.services.Service;
 import io.pravega.client.stream.EventStreamReader;
 import io.pravega.client.stream.EventStreamWriter;
 import io.pravega.client.stream.EventWriterConfig;
@@ -26,6 +22,17 @@ import io.pravega.client.stream.ReinitializationRequiredException;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.client.stream.impl.JavaSerializer;
+import io.pravega.common.concurrent.Futures;
+import io.pravega.test.system.framework.Environment;
+import io.pravega.test.system.framework.SystemTestRunner;
+import io.pravega.test.system.framework.Utils;
+import io.pravega.test.system.framework.services.Service;
+import java.io.Serializable;
+import java.net.URI;
+import java.util.Collections;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.ExecutionException;
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
 import mesosphere.marathon.client.MarathonException;
@@ -35,12 +42,6 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import java.io.Serializable;
-import java.net.URI;
-import java.util.Collections;
-import java.util.List;
-import java.util.UUID;
-import java.util.concurrent.ExecutionException;
 
 /**
  * Test cases for deploying multiple segment stores.
@@ -154,7 +155,7 @@ public class MultiSegmentStoreTest {
         String stream = "teststream" + RandomStringUtils.randomAlphanumeric(10);
 
         @Cleanup
-        StreamManager streamManager = StreamManager.create(controllerUri);
+        StreamManager streamManager = StreamManager.create(ClientConfig.builder().controllerURI(controllerUri).build());
         Assert.assertTrue(streamManager.createScope(scope));
 
         // Create stream with large number of segments so that most segment containers are used.
@@ -165,7 +166,8 @@ public class MultiSegmentStoreTest {
                 .build()));
 
         @Cleanup
-        ClientFactory clientFactory = ClientFactory.withScope(scope, controllerUri);
+        ClientFactory clientFactory = ClientFactory.withScope(scope,
+                ClientConfig.builder().controllerURI(controllerUri).build());
 
         log.info("Invoking writer with controller URI: {}", controllerUri);
         @Cleanup
@@ -183,7 +185,7 @@ public class MultiSegmentStoreTest {
 
         log.info("Invoking reader with controller URI: {}", controllerUri);
         final String readerGroup = "testreadergroup" + RandomStringUtils.randomAlphanumeric(10);
-        ReaderGroupManager groupManager = ReaderGroupManager.withScope(scope, controllerUri);
+        ReaderGroupManager groupManager = ReaderGroupManager.withScope(scope, ClientConfig.builder().controllerURI(controllerUri).build());
         groupManager.createReaderGroup(readerGroup,
                 ReaderGroupConfig.builder().disableAutomaticCheckpoints().startingTime(0).build(),
                 Collections.singleton(stream));
diff --git a/test/system/src/test/java/io/pravega/test/system/PravegaTest.java b/test/system/src/test/java/io/pravega/test/system/PravegaTest.java
index 76a5262..3a4668b 100644
--- a/test/system/src/test/java/io/pravega/test/system/PravegaTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/PravegaTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.netty.impl.ConnectionFactory;
@@ -42,6 +43,7 @@ import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+
 import static org.junit.Assert.assertTrue;
 
 @Slf4j
@@ -125,9 +127,10 @@ public class PravegaTest {
 
         log.info("Invoking create stream with Controller URI: {}", controllerUri);
         @Cleanup
-        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
-        ControllerImpl controller = new ControllerImpl(controllerUri,
-                ControllerImplConfig.builder().build(), connectionFactory.getInternalExecutor());
+        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
+        ControllerImpl controller = new ControllerImpl(ControllerImplConfig.builder()
+                                    .clientConfig(ClientConfig.builder().controllerURI(controllerUri).build())
+                                    .build(), connectionFactory.getInternalExecutor());
 
         assertTrue(controller.createScope(STREAM_SCOPE).get());
         assertTrue(controller.createStream(config).get());
@@ -148,7 +151,7 @@ public class PravegaTest {
         URI controllerUri = ctlURIs.get(0);
 
         @Cleanup
-        ClientFactory clientFactory = ClientFactory.withScope(STREAM_SCOPE, controllerUri);
+        ClientFactory clientFactory = ClientFactory.withScope(STREAM_SCOPE, ClientConfig.builder().controllerURI(controllerUri).build());
         log.info("Invoking Writer test with Controller URI: {}", controllerUri);
         @Cleanup
         EventStreamWriter<Serializable> writer = clientFactory.createEventWriter(STREAM_NAME,
@@ -162,7 +165,7 @@ public class PravegaTest {
             Thread.sleep(500);
         }
         log.info("Invoking Reader test.");
-        ReaderGroupManager groupManager = ReaderGroupManager.withScope(STREAM_SCOPE, controllerUri);
+        ReaderGroupManager groupManager = ReaderGroupManager.withScope(STREAM_SCOPE, ClientConfig.builder().controllerURI(controllerUri).build());
         groupManager.createReaderGroup(READER_GROUP, ReaderGroupConfig.builder().startingTime(0).build(),
                                        Collections.singleton(STREAM_NAME));
         EventStreamReader<String> reader = clientFactory.createReader(UUID.randomUUID().toString(),
diff --git a/test/system/src/test/java/io/pravega/test/system/ReadTxnWriteAutoScaleWithFailoverTest.java b/test/system/src/test/java/io/pravega/test/system/ReadTxnWriteAutoScaleWithFailoverTest.java
index 3d324c2..e2a2e4a 100644
--- a/test/system/src/test/java/io/pravega/test/system/ReadTxnWriteAutoScaleWithFailoverTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/ReadTxnWriteAutoScaleWithFailoverTest.java
@@ -10,6 +10,7 @@
 
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -26,6 +27,11 @@ import io.pravega.test.system.framework.Environment;
 import io.pravega.test.system.framework.SystemTestRunner;
 import io.pravega.test.system.framework.Utils;
 import io.pravega.test.system.framework.services.Service;
+import java.net.URI;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ExecutionException;
+import java.util.stream.Collectors;
 import lombok.extern.slf4j.Slf4j;
 import mesosphere.marathon.client.MarathonException;
 import org.junit.After;
@@ -34,11 +40,7 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
-import java.net.URI;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ExecutionException;
-import java.util.stream.Collectors;
+
 import static org.junit.Assert.assertTrue;
 
 @Slf4j
@@ -105,17 +107,18 @@ public class ReadTxnWriteAutoScaleWithFailoverTest extends AbstractFailoverTests
         controllerExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(2,
                 "ReadTxnWriteAutoScaleWithFailoverTest-controller");
         //get Controller Uri
-        controller = new ControllerImpl(controllerURIDirect,
-                ControllerImplConfig.builder().maxBackoffMillis(5000).build(),
+        controller = new ControllerImpl(ControllerImplConfig.builder()
+                                         .clientConfig( ClientConfig.builder().controllerURI(controllerURIDirect).build())
+                                         .maxBackoffMillis(5000).build(),
                 controllerExecutorService);
         testState = new TestState(true);
         testState.writersListComplete.add(0, testState.writersComplete);
         testState.writersListComplete.add(1, testState.newWritersComplete);
-        streamManager = new StreamManagerImpl(controllerURIDirect);
+        streamManager = new StreamManagerImpl( ClientConfig.builder().controllerURI(controllerURIDirect).build());
         createScopeAndStream(scope, stream, config, streamManager);
         log.info("Scope passed to client factory {}", scope);
         clientFactory = new ClientFactoryImpl(scope, controller);
-        readerGroupManager = ReaderGroupManager.withScope(scope, controllerURIDirect);
+        readerGroupManager = ReaderGroupManager.withScope(scope, ClientConfig.builder().controllerURI(controllerURIDirect).build());
     }
 
     @After
diff --git a/test/system/src/test/java/io/pravega/test/system/ReadTxnWriteScaleWithFailoverTest.java b/test/system/src/test/java/io/pravega/test/system/ReadTxnWriteScaleWithFailoverTest.java
index b76d95f..f061b43 100644
--- a/test/system/src/test/java/io/pravega/test/system/ReadTxnWriteScaleWithFailoverTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/ReadTxnWriteScaleWithFailoverTest.java
@@ -10,6 +10,7 @@
 
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -27,13 +28,6 @@ import io.pravega.test.system.framework.Environment;
 import io.pravega.test.system.framework.SystemTestRunner;
 import io.pravega.test.system.framework.Utils;
 import io.pravega.test.system.framework.services.Service;
-import lombok.extern.slf4j.Slf4j;
-import mesosphere.marathon.client.MarathonException;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
 import java.net.URI;
 import java.util.Collections;
 import java.util.HashMap;
@@ -43,6 +37,14 @@ import java.util.Random;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.stream.Collectors;
+import lombok.extern.slf4j.Slf4j;
+import mesosphere.marathon.client.MarathonException;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
 import static org.junit.Assert.assertTrue;
 
 @Slf4j
@@ -104,16 +106,18 @@ public class ReadTxnWriteScaleWithFailoverTest extends AbstractFailoverTests {
         controllerExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(2,
                 "ReadTxnWriteScaleWithFailoverTest-controller");
         //get Controller Uri
-        controller = new ControllerImpl(controllerURIDirect,
-                ControllerImplConfig.builder().maxBackoffMillis(5000).build(),
+        controller = new ControllerImpl(ControllerImplConfig.builder()
+                                    .clientConfig( ClientConfig.builder().controllerURI(controllerURIDirect).build())
+                                    .maxBackoffMillis(5000).build(),
                 controllerExecutorService);
         testState = new TestState(true);
         testState.writersListComplete.add(0, testState.writersComplete);
-        streamManager = new StreamManagerImpl(controllerURIDirect);
+        streamManager = new StreamManagerImpl(ClientConfig.builder().controllerURI(controllerURIDirect).build());
         createScopeAndStream(scope, stream, config, streamManager);
         log.info("Scope passed to client factory {}", scope);
         clientFactory = new ClientFactoryImpl(scope, controller);
-        readerGroupManager = ReaderGroupManager.withScope(scope, controllerURIDirect);
+        readerGroupManager = ReaderGroupManager.withScope(scope,
+                ClientConfig.builder().controllerURI(controllerURIDirect).build());
     }
 
     @After
diff --git a/test/system/src/test/java/io/pravega/test/system/ReadWithAutoScaleTest.java b/test/system/src/test/java/io/pravega/test/system/ReadWithAutoScaleTest.java
index 4bf2c1c..898c17c 100644
--- a/test/system/src/test/java/io/pravega/test/system/ReadWithAutoScaleTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/ReadWithAutoScaleTest.java
@@ -11,12 +11,6 @@ package io.pravega.test.system;
 
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
-import io.pravega.common.concurrent.Futures;
-import io.pravega.common.util.Retry;
-import io.pravega.test.system.framework.Environment;
-import io.pravega.test.system.framework.SystemTestRunner;
-import io.pravega.test.system.framework.Utils;
-import io.pravega.test.system.framework.services.Service;
 import io.pravega.client.stream.EventStreamReader;
 import io.pravega.client.stream.EventStreamWriter;
 import io.pravega.client.stream.EventWriterConfig;
@@ -26,9 +20,15 @@ import io.pravega.client.stream.ReinitializationRequiredException;
 import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.client.stream.Transaction;
-import io.pravega.client.stream.impl.ControllerImpl;
 import io.pravega.client.stream.impl.Controller;
+import io.pravega.client.stream.impl.ControllerImpl;
 import io.pravega.client.stream.impl.JavaSerializer;
+import io.pravega.common.concurrent.Futures;
+import io.pravega.common.util.Retry;
+import io.pravega.test.system.framework.Environment;
+import io.pravega.test.system.framework.SystemTestRunner;
+import io.pravega.test.system.framework.Utils;
+import io.pravega.test.system.framework.services.Service;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.util.Collection;
@@ -49,6 +49,7 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+
 import static java.time.Duration.ofSeconds;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertEquals;
diff --git a/test/system/src/test/java/io/pravega/test/system/ReadWriteAndAutoScaleWithFailoverTest.java b/test/system/src/test/java/io/pravega/test/system/ReadWriteAndAutoScaleWithFailoverTest.java
index 122167c..d6493d4 100644
--- a/test/system/src/test/java/io/pravega/test/system/ReadWriteAndAutoScaleWithFailoverTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/ReadWriteAndAutoScaleWithFailoverTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -25,6 +26,11 @@ import io.pravega.test.system.framework.Environment;
 import io.pravega.test.system.framework.SystemTestRunner;
 import io.pravega.test.system.framework.Utils;
 import io.pravega.test.system.framework.services.Service;
+import java.net.URI;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ExecutionException;
+import java.util.stream.Collectors;
 import lombok.extern.slf4j.Slf4j;
 import mesosphere.marathon.client.MarathonException;
 import org.junit.After;
@@ -33,11 +39,7 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
-import java.net.URI;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ExecutionException;
-import java.util.stream.Collectors;
+
 import static org.junit.Assert.assertTrue;
 
 @Slf4j
@@ -104,18 +106,21 @@ public class ReadWriteAndAutoScaleWithFailoverTest extends AbstractFailoverTests
         controllerExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(2,
                                                                                   "ReadWriteAndAutoScaleWithFailoverTest-controller");
         //get Controller Uri
-        controller = new ControllerImpl(controllerURIDirect,
-                                        ControllerImplConfig.builder().maxBackoffMillis(5000).build(),
+        controller = new ControllerImpl(ControllerImplConfig.builder()
+                                                            .clientConfig( ClientConfig.builder().controllerURI(controllerURIDirect).build())
+                                                            .maxBackoffMillis(5000).build(),
+
                                         controllerExecutorService);
         testState = new TestState(false);
         testState.writersListComplete.add(0, testState.writersComplete);
         testState.writersListComplete.add(1, testState.newWritersComplete);
-        streamManager = new StreamManagerImpl(controllerURIDirect);
+        streamManager = new StreamManagerImpl( ClientConfig.builder().controllerURI(controllerURIDirect).build());
         createScopeAndStream(scope, AUTO_SCALE_STREAM, config, streamManager);
         log.info("Scope passed to client factory {}", scope);
 
         clientFactory = new ClientFactoryImpl(scope, controller);
-        readerGroupManager = ReaderGroupManager.withScope(scope, controllerURIDirect);
+        readerGroupManager = ReaderGroupManager.withScope(scope,
+                ClientConfig.builder().controllerURI(controllerURIDirect).build());
     }
 
     @After
diff --git a/test/system/src/test/java/io/pravega/test/system/ReadWriteAndScaleWithFailoverTest.java b/test/system/src/test/java/io/pravega/test/system/ReadWriteAndScaleWithFailoverTest.java
index 0a6e82b..e52a120 100644
--- a/test/system/src/test/java/io/pravega/test/system/ReadWriteAndScaleWithFailoverTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/ReadWriteAndScaleWithFailoverTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -26,15 +27,6 @@ import io.pravega.test.system.framework.Environment;
 import io.pravega.test.system.framework.SystemTestRunner;
 import io.pravega.test.system.framework.Utils;
 import io.pravega.test.system.framework.services.Service;
-import lombok.extern.slf4j.Slf4j;
-import mesosphere.marathon.client.MarathonException;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.Timeout;
-import org.junit.runner.RunWith;
 import java.net.URI;
 import java.util.Collections;
 import java.util.HashMap;
@@ -44,6 +36,16 @@ import java.util.Random;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.stream.Collectors;
+import lombok.extern.slf4j.Slf4j;
+import mesosphere.marathon.client.MarathonException;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+import org.junit.runner.RunWith;
+
 import static org.junit.Assert.assertTrue;
 
 @Slf4j
@@ -108,16 +110,18 @@ public class ReadWriteAndScaleWithFailoverTest extends AbstractFailoverTests {
         controllerExecutorService = ExecutorServiceHelpers.newScheduledThreadPool(2,
                 "ReadWriteAndScaleWithFailoverTest-controller");
         //get Controller Uri
-        controller = new ControllerImpl(controllerURIDirect,
-                ControllerImplConfig.builder().maxBackoffMillis(5000).build(),
+        controller = new ControllerImpl(ControllerImplConfig.builder()
+                                    .clientConfig(ClientConfig.builder().controllerURI(controllerURIDirect).build())
+                                    .maxBackoffMillis(5000).build(),
                 controllerExecutorService);
         testState = new TestState(false);
         testState.writersListComplete.add(0, testState.writersComplete);
-        streamManager = new StreamManagerImpl(controllerURIDirect);
+        streamManager = new StreamManagerImpl( ClientConfig.builder().controllerURI(controllerURIDirect).build());
         createScopeAndStream(scope, SCALE_STREAM, config, streamManager);
         log.info("Scope passed to client factory {}", scope);
         clientFactory = new ClientFactoryImpl(scope, controller);
-        readerGroupManager = ReaderGroupManager.withScope(scope, controllerURIDirect);
+        readerGroupManager = ReaderGroupManager.withScope(scope,
+                ClientConfig.builder().controllerURI(controllerURIDirect).build());
     }
 
     @After
diff --git a/test/system/src/test/java/io/pravega/test/system/ReaderCheckpointTest.java b/test/system/src/test/java/io/pravega/test/system/ReaderCheckpointTest.java
index 17e8f4a..b8ae309 100644
--- a/test/system/src/test/java/io/pravega/test/system/ReaderCheckpointTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/ReaderCheckpointTest.java
@@ -9,30 +9,6 @@
  */
 package io.pravega.test.system;
 
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import io.pravega.common.concurrent.Futures;
-import java.io.Serializable;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.IntSummaryStatistics;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.function.Supplier;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-import java.util.stream.Stream;
-import io.pravega.test.system.framework.Utils;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.Timeout;
-import org.junit.runner.RunWith;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -49,11 +25,36 @@ import io.pravega.client.stream.ScalingPolicy;
 import io.pravega.client.stream.StreamConfiguration;
 import io.pravega.client.stream.impl.JavaSerializer;
 import io.pravega.common.concurrent.ExecutorServiceHelpers;
+import io.pravega.common.concurrent.Futures;
 import io.pravega.test.system.framework.Environment;
 import io.pravega.test.system.framework.SystemTestRunner;
+import io.pravega.test.system.framework.Utils;
 import io.pravega.test.system.framework.services.Service;
+import java.io.Serializable;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.IntSummaryStatistics;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
 import lombok.Cleanup;
 import lombok.extern.slf4j.Slf4j;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+import org.junit.runner.RunWith;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 @Slf4j
 @RunWith(SystemTestRunner.class)
diff --git a/test/system/src/test/java/io/pravega/test/system/RetentionTest.java b/test/system/src/test/java/io/pravega/test/system/RetentionTest.java
index d4beee3..3e24a86 100644
--- a/test/system/src/test/java/io/pravega/test/system/RetentionTest.java
+++ b/test/system/src/test/java/io/pravega/test/system/RetentionTest.java
@@ -9,6 +9,7 @@
  */
 package io.pravega.test.system;
 
+import io.pravega.client.ClientConfig;
 import io.pravega.client.ClientFactory;
 import io.pravega.client.admin.ReaderGroupManager;
 import io.pravega.client.admin.StreamManager;
@@ -32,14 +33,6 @@ import io.pravega.test.system.framework.Environment;
 import io.pravega.test.system.framework.SystemTestRunner;
 import io.pravega.test.system.framework.Utils;
 import io.pravega.test.system.framework.services.Service;
-import lombok.extern.slf4j.Slf4j;
-import mesosphere.marathon.client.MarathonException;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.Timeout;
-import org.junit.runner.RunWith;
 import java.io.Serializable;
 import java.net.URI;
 import java.time.Duration;
@@ -48,6 +41,15 @@ import java.util.List;
 import java.util.Random;
 import java.util.UUID;
 import java.util.concurrent.ScheduledExecutorService;
+import lombok.extern.slf4j.Slf4j;
+import mesosphere.marathon.client.MarathonException;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+import org.junit.runner.RunWith;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -131,9 +133,11 @@ public class RetentionTest {
     @Test
     public void retentionTest() throws Exception {
 
-        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(false);
-        ControllerImpl controller = new ControllerImpl(controllerURI,
-                ControllerImplConfig.builder().build(), connectionFactory.getInternalExecutor());
+        ConnectionFactory connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());
+        ControllerImpl controller = new ControllerImpl(ControllerImplConfig.builder().clientConfig(
+                ClientConfig.builder().controllerURI(controllerURI).build())
+                .build(),
+                 connectionFactory.getInternalExecutor());
 
         ClientFactory clientFactory = new ClientFactoryImpl(SCOPE, controller);
         log.info("Invoking Writer test with Controller URI: {}", controllerURI);
