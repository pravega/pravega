/**
 * Copyright Pravega Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.pravega.controller.store.kvtable;

import io.pravega.client.tables.KeyValueTableConfiguration;
import io.pravega.common.Exceptions;
import io.pravega.common.concurrent.ExecutorServiceHelpers;
import io.pravega.controller.store.kvtable.records.KVTSegmentRecord;
import io.pravega.controller.store.stream.StoreException;
import io.pravega.controller.store.stream.StreamMetadataStore;
import io.pravega.controller.stream.api.grpc.v1.Controller;
import java.util.List;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.Timeout;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

/**
 * Stream metadata test.
 */
public abstract class KVTableMetadataStoreTest {

    //Ensure each test completes within 10 seconds.
    @Rule 
    public Timeout globalTimeout = new Timeout(30, TimeUnit.SECONDS);
    protected KVTableMetadataStore store;
    protected StreamMetadataStore streamStore;
    protected final ScheduledExecutorService executor = ExecutorServiceHelpers.newScheduledThreadPool(10, "test");
    protected final String scope = "storescope";
    protected final String kvtable1 = "kvt1";
    protected final String kvtable2 = "kvt2";
    protected final KeyValueTableConfiguration configuration1 = KeyValueTableConfiguration.builder().partitionCount(2).build();
    protected final KeyValueTableConfiguration configuration2 = KeyValueTableConfiguration.builder().partitionCount(3).build();

    @Before
    public abstract void setupStore() throws Exception;

    @After
    public abstract void cleanupStore() throws Exception;

    @After
    public void tearDown() {
        ExecutorServiceHelpers.shutdown(executor);
    }

    abstract Controller.CreateScopeStatus createScope(String scopeName) throws Exception;

    @Test
    public void testKVTableMetadataStore() throws Exception {
        Controller.CreateScopeStatus scopeCreateStatus = createScope(scope);
        assertTrue(scopeCreateStatus.getStatus().equals(Controller.CreateScopeStatus.Status.SUCCESS)
                || scopeCreateStatus.getStatus().equals(Controller.CreateScopeStatus.Status.SCOPE_EXISTS));

        byte[] newUUID1 = store.newScope(scope).newId();
        store.createEntryForKVTable(scope, kvtable1, newUUID1, executor).get();
        long start = System.currentTimeMillis();
        store.createKeyValueTable(scope, kvtable1, configuration1, start, null, executor).get();
        store.setState(scope, kvtable1, KVTableState.ACTIVE, null, executor).get();

        byte[] newUUID2 = store.newScope(scope).newId();
        store.createEntryForKVTable(scope, kvtable2, newUUID2, executor).get();
        store.createKeyValueTable(scope, kvtable2, configuration2, start, null, executor).get();
        store.setState(scope, kvtable2, KVTableState.ACTIVE, null, executor).get();

        assertEquals(configuration1, store.getConfiguration(scope, kvtable1, null, executor).get());
        // endregion

        // region checkSegments
        List<KVTSegmentRecord> segments = store.getActiveSegments(scope, kvtable1, null, executor).get();
        assertEquals(2, segments.size());

        segments = store.getActiveSegments(scope, kvtable2, null, executor).get();
        assertEquals(3, segments.size());
        // endregion
    }

    @Test
    public void listTablesInScope() throws Exception {
        // list KeyValueTables in scope
        Controller.CreateScopeStatus scopeCreateStatus = createScope(scope);
        assertTrue(scopeCreateStatus.getStatus().equals(Controller.CreateScopeStatus.Status.SUCCESS)
                || scopeCreateStatus.getStatus().equals(Controller.CreateScopeStatus.Status.SCOPE_EXISTS));

        byte[] newUUID1 = store.newScope(scope).newId();
        store.createEntryForKVTable(scope, kvtable1, newUUID1, executor).get();
        long start = System.currentTimeMillis();
        store.createKeyValueTable(scope, kvtable1, configuration1, start, null, executor).get();
        store.setState(scope, kvtable1, KVTableState.ACTIVE, null, executor).get();

        byte[] newUUID2 = store.newScope(scope).newId();
        store.createEntryForKVTable(scope, kvtable2, newUUID2, executor).get();
        store.createKeyValueTable(scope, kvtable2, configuration2, start, null, executor).get();
        store.setState(scope, kvtable2, KVTableState.ACTIVE, null, executor).get();

        Pair<List<String>, String> kvTablesInScope = store.listKeyValueTables(scope,
                                                    Controller.ContinuationToken.newBuilder().build().getToken(),
                                                    2, executor).get();

        assertEquals("List kvtables in scope", 2, kvTablesInScope.getKey().size());
        assertTrue("Found KVTable1", kvTablesInScope.getKey().contains(kvtable1));
        assertTrue("Found KVTable2", kvTablesInScope.getKey().contains(kvtable2));

        // List streams in non-existent scope 'Scope1'
        try {
            store.listKeyValueTables("Scope1", Controller.ContinuationToken.newBuilder().build().getToken(),
                    2, executor).join();
        } catch (StoreException se) {
            assertTrue("List streams in non-existent scope Scope1",
                    se instanceof StoreException.DataNotFoundException);
        } catch (CompletionException ce) {
            assertTrue("List streams in non-existent scope Scope1",
                    Exceptions.unwrap(ce) instanceof StoreException.DataNotFoundException);
        }
    }

    @Test
    public void deleteKeyValueTableTest() throws Exception {
        final String scopeName = "ScopeDelete";
        final String kvtName = "KVTableDelete";
        KeyValueTableConfiguration config = KeyValueTableConfiguration.builder().partitionCount(3).build();

        // create KeyValueTable in scope
        Controller.CreateScopeStatus scopeCreateStatus = createScope(scopeName);
        assertTrue(scopeCreateStatus.getStatus().equals(Controller.CreateScopeStatus.Status.SUCCESS));

        byte[] newUUID1 = store.newScope(scopeName).newId();
        store.createEntryForKVTable(scopeName, kvtName, newUUID1, executor).get();
        long start = System.currentTimeMillis();
        store.createKeyValueTable(scopeName, kvtName, config, start, null, executor).get();
        store.setState(scopeName, kvtName, KVTableState.ACTIVE, null, executor).get();
        assertTrue(store.checkTableExists(scopeName, kvtName).join());
        store.deleteKeyValueTable(scopeName, kvtName, null, executor).get();
        assertFalse(store.checkTableExists(scopeName, kvtName).join());
    }
}
